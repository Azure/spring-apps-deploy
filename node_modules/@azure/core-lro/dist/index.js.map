{"version":3,"file":"index.js","sources":["../src/poller.ts","../src/lroEngine/logger.ts","../src/lroEngine/impl.ts","../src/lroEngine/operation.ts","../src/lroEngine/lroEngine.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { PollOperation, PollOperationState } from \"./pollOperation\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\n\n/**\n * CancelOnProgress is used as the return value of a Poller's onProgress method.\n * When a user invokes onProgress, they're required to pass in a function that will be\n * called as a callback with the new data received each time the poll operation is updated.\n * onProgress returns a function that will prevent any further update to reach the original callback.\n */\nexport type CancelOnProgress = () => void;\n\n/**\n * PollProgressCallback<TState> is the type of the callback functions sent to onProgress.\n * These functions will receive a TState that is defined by your implementation of\n * the Poller class.\n */\nexport type PollProgressCallback<TState> = (state: TState) => void;\n\n/**\n * When a poller is manually stopped through the `stopPolling` method,\n * the poller will be rejected with an instance of the PollerStoppedError.\n */\nexport class PollerStoppedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PollerStoppedError\";\n    Object.setPrototypeOf(this, PollerStoppedError.prototype);\n  }\n}\n\n/**\n * When the operation is cancelled, the poller will be rejected with an instance\n * of the PollerCancelledError.\n */\nexport class PollerCancelledError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PollerCancelledError\";\n    Object.setPrototypeOf(this, PollerCancelledError.prototype);\n  }\n}\n\n/**\n * Abstract representation of a poller, intended to expose just the minimal API that the user needs to work with.\n */\n// eslint-disable-next-line no-use-before-define\nexport interface PollerLike<TState extends PollOperationState<TResult>, TResult> {\n  /**\n   * Returns a promise that will resolve once a single polling request finishes.\n   * It does this by calling the update method of the Poller's operation.\n   */\n  poll(options?: { abortSignal?: AbortSignalLike }): Promise<void>;\n  /**\n   * Returns a promise that will resolve once the underlying operation is completed.\n   */\n  pollUntilDone(): Promise<TResult>;\n  /**\n   * Invokes the provided callback after each polling is completed,\n   * sending the current state of the poller's operation.\n   *\n   * It returns a method that can be used to stop receiving updates on the given callback function.\n   */\n  onProgress(callback: (state: TState) => void): CancelOnProgress;\n  /**\n   * Returns true if the poller has finished polling.\n   */\n  isDone(): boolean;\n  /**\n   * Stops the poller. After this, no manual or automated requests can be sent.\n   */\n  stopPolling(): void;\n  /**\n   * Returns true if the poller is stopped.\n   */\n  isStopped(): boolean;\n  /**\n   * Attempts to cancel the underlying operation.\n   */\n  cancelOperation(options?: { abortSignal?: AbortSignalLike }): Promise<void>;\n  /**\n   * Returns the state of the operation.\n   * The TState defined in PollerLike can be a subset of the TState defined in\n   * the Poller implementation.\n   */\n  getOperationState(): TState;\n  /**\n   * Returns the result value of the operation,\n   * regardless of the state of the poller.\n   * It can return undefined or an incomplete form of the final TResult value\n   * depending on the implementation.\n   */\n  getResult(): TResult | undefined;\n  /**\n   * Returns a serialized version of the poller's operation\n   * by invoking the operation's toString method.\n   */\n  toString(): string;\n}\n\n/**\n * A class that represents the definition of a program that polls through consecutive requests\n * until it reaches a state of completion.\n *\n * A poller can be executed manually, by polling request by request by calling to the `poll()` method repeatedly, until its operation is completed.\n * It also provides a way to wait until the operation completes, by calling `pollUntilDone()` and waiting until the operation finishes.\n * Pollers can also request the cancellation of the ongoing process to whom is providing the underlying long running operation.\n *\n * ```ts\n * const poller = new MyPoller();\n *\n * // Polling just once:\n * await poller.poll();\n *\n * // We can try to cancel the request here, by calling:\n * //\n * //     await poller.cancelOperation();\n * //\n *\n * // Getting the final result:\n * const result = await poller.pollUntilDone();\n * ```\n *\n * The Poller is defined by two types, a type representing the state of the poller, which\n * must include a basic set of properties from `PollOperationState<TResult>`,\n * and a return type defined by `TResult`, which can be anything.\n *\n * The Poller class implements the `PollerLike` interface, which allows poller implementations to avoid having\n * to export the Poller's class directly, and instead only export the already instantiated poller with the PollerLike type.\n *\n * ```ts\n * class Client {\n *   public async makePoller: PollerLike<MyOperationState, MyResult> {\n *     const poller = new MyPoller({});\n *     // It might be preferred to return the poller after the first request is made,\n *     // so that some information can be obtained right away.\n *     await poller.poll();\n *     return poller;\n *   }\n * }\n *\n * const poller: PollerLike<MyOperationState, MyResult> = myClient.makePoller();\n * ```\n *\n * A poller can be created through its constructor, then it can be polled until it's completed.\n * At any point in time, the state of the poller can be obtained without delay through the getOperationState method.\n * At any point in time, the intermediate forms of the result type can be requested without delay.\n * Once the underlying operation is marked as completed, the poller will stop and the final value will be returned.\n *\n * ```ts\n * const poller = myClient.makePoller();\n * const state: MyOperationState = poller.getOperationState();\n *\n * // The intermediate result can be obtained at any time.\n * const result: MyResult | undefined = poller.getResult();\n *\n * // The final result can only be obtained after the poller finishes.\n * const result: MyResult = await poller.pollUntilDone();\n * ```\n *\n */\n// eslint-disable-next-line no-use-before-define\nexport abstract class Poller<TState extends PollOperationState<TResult>, TResult>\n  implements PollerLike<TState, TResult>\n{\n  private stopped: boolean = true;\n  private resolve?: (value: TResult) => void;\n  private reject?: (error: PollerStoppedError | PollerCancelledError | Error) => void;\n  private pollOncePromise?: Promise<void>;\n  private cancelPromise?: Promise<void>;\n  private promise: Promise<TResult>;\n  private pollProgressCallbacks: PollProgressCallback<TState>[] = [];\n\n  /**\n   * The poller's operation is available in full to any of the methods of the Poller class\n   * and any class extending the Poller class.\n   */\n  protected operation: PollOperation<TState, TResult>;\n\n  /**\n   * A poller needs to be initialized by passing in at least the basic properties of the `PollOperation<TState, TResult>`.\n   *\n   * When writing an implementation of a Poller, this implementation needs to deal with the initialization\n   * of any custom state beyond the basic definition of the poller. The basic poller assumes that the poller's\n   * operation has already been defined, at least its basic properties. The code below shows how to approach\n   * the definition of the constructor of a new custom poller.\n   *\n   * ```ts\n   * export class MyPoller extends Poller<MyOperationState, string> {\n   *   constructor({\n   *     // Anything you might need outside of the basics\n   *   }) {\n   *     let state: MyOperationState = {\n   *       privateProperty: private,\n   *       publicProperty: public,\n   *     };\n   *\n   *     const operation = {\n   *       state,\n   *       update,\n   *       cancel,\n   *       toString\n   *     }\n   *\n   *     // Sending the operation to the parent's constructor.\n   *     super(operation);\n   *\n   *     // You can assign more local properties here.\n   *   }\n   * }\n   * ```\n   *\n   * Inside of this constructor, a new promise is created. This will be used to\n   * tell the user when the poller finishes (see `pollUntilDone()`). The promise's\n   * resolve and reject methods are also used internally to control when to resolve\n   * or reject anyone waiting for the poller to finish.\n   *\n   * The constructor of a custom implementation of a poller is where any serialized version of\n   * a previous poller's operation should be deserialized into the operation sent to the\n   * base constructor. For example:\n   *\n   * ```ts\n   * export class MyPoller extends Poller<MyOperationState, string> {\n   *   constructor(\n   *     baseOperation: string | undefined\n   *   ) {\n   *     let state: MyOperationState = {};\n   *     if (baseOperation) {\n   *       state = {\n   *         ...JSON.parse(baseOperation).state,\n   *         ...state\n   *       };\n   *     }\n   *     const operation = {\n   *       state,\n   *       // ...\n   *     }\n   *     super(operation);\n   *   }\n   * }\n   * ```\n   *\n   * @param operation - Must contain the basic properties of `PollOperation<State, TResult>`.\n   */\n  constructor(operation: PollOperation<TState, TResult>) {\n    this.operation = operation;\n    this.promise = new Promise<TResult>(\n      (\n        resolve: (result: TResult) => void,\n        reject: (error: PollerStoppedError | PollerCancelledError | Error) => void\n      ) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      }\n    );\n    // This prevents the UnhandledPromiseRejectionWarning in node.js from being thrown.\n    // The above warning would get thrown if `poller.poll` is called, it returns an error,\n    // and pullUntilDone did not have a .catch or await try/catch on it's return value.\n    this.promise.catch(() => {\n      /* intentionally blank */\n    });\n  }\n\n  /**\n   * Defines how much to wait between each poll request.\n   * This has to be implemented by your custom poller.\n   *\n   * \\@azure/core-http has a simple implementation of a delay function that waits as many milliseconds as specified.\n   * This can be used as follows:\n   *\n   * ```ts\n   * import { delay } from \"@azure/core-http\";\n   *\n   * export class MyPoller extends Poller<MyOperationState, string> {\n   *   // The other necessary definitions.\n   *\n   *   async delay(): Promise<void> {\n   *     const milliseconds = 1000;\n   *     return delay(milliseconds);\n   *   }\n   * }\n   * ```\n   *\n   */\n  protected abstract delay(): Promise<void>;\n\n  /**\n   * Starts a loop that will break only if the poller is done\n   * or if the poller is stopped.\n   */\n  private async startPolling(): Promise<void> {\n    if (this.stopped) {\n      this.stopped = false;\n    }\n    while (!this.isStopped() && !this.isDone()) {\n      await this.poll();\n      await this.delay();\n    }\n  }\n\n  /**\n   * pollOnce does one polling, by calling to the update method of the underlying\n   * poll operation to make any relevant change effective.\n   *\n   * It only optionally receives an object with an abortSignal property, from \\@azure/abort-controller's AbortSignalLike.\n   *\n   * @param options - Optional properties passed to the operation's update method.\n   */\n  private async pollOnce(options: { abortSignal?: AbortSignalLike } = {}): Promise<void> {\n    if (!this.isDone()) {\n      try {\n        this.operation = await this.operation.update({\n          abortSignal: options.abortSignal,\n          fireProgress: this.fireProgress.bind(this),\n        });\n      } catch (e: any) {\n        this.operation.state.error = e;\n      }\n    }\n    this.processUpdatedState();\n  }\n\n  /**\n   * fireProgress calls the functions passed in via onProgress the method of the poller.\n   *\n   * It loops over all of the callbacks received from onProgress, and executes them, sending them\n   * the current operation state.\n   *\n   * @param state - The current operation state.\n   */\n  private fireProgress(state: TState): void {\n    for (const callback of this.pollProgressCallbacks) {\n      callback(state);\n    }\n  }\n\n  /**\n   * Invokes the underlying operation's cancel method.\n   */\n  private async cancelOnce(options: { abortSignal?: AbortSignalLike } = {}): Promise<void> {\n    this.operation = await this.operation.cancel(options);\n  }\n\n  /**\n   * Returns a promise that will resolve once a single polling request finishes.\n   * It does this by calling the update method of the Poller's operation.\n   *\n   * It only optionally receives an object with an abortSignal property, from \\@azure/abort-controller's AbortSignalLike.\n   *\n   * @param options - Optional properties passed to the operation's update method.\n   */\n  public poll(options: { abortSignal?: AbortSignalLike } = {}): Promise<void> {\n    if (!this.pollOncePromise) {\n      this.pollOncePromise = this.pollOnce(options);\n      const clearPollOncePromise = (): void => {\n        this.pollOncePromise = undefined;\n      };\n      this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);\n    }\n    return this.pollOncePromise;\n  }\n\n  private processUpdatedState(): void {\n    if (this.operation.state.error) {\n      this.stopped = true;\n      this.reject!(this.operation.state.error);\n      throw this.operation.state.error;\n    }\n    if (this.operation.state.isCancelled) {\n      this.stopped = true;\n      const error = new PollerCancelledError(\"Poller cancelled\");\n      this.reject!(error);\n      throw error;\n    } else if (this.isDone() && this.resolve) {\n      // If the poller has finished polling, this means we now have a result.\n      // However, it can be the case that TResult is instantiated to void, so\n      // we are not expecting a result anyway. To assert that we might not\n      // have a result eventually after finishing polling, we cast the result\n      // to TResult.\n      this.resolve(this.operation.state.result as TResult);\n    }\n  }\n\n  /**\n   * Returns a promise that will resolve once the underlying operation is completed.\n   */\n  public async pollUntilDone(): Promise<TResult> {\n    if (this.stopped) {\n      this.startPolling().catch(this.reject);\n    }\n    // This is needed because the state could have been updated by\n    // `cancelOperation`, e.g. the operation is canceled or an error occurred.\n    this.processUpdatedState();\n    return this.promise;\n  }\n\n  /**\n   * Invokes the provided callback after each polling is completed,\n   * sending the current state of the poller's operation.\n   *\n   * It returns a method that can be used to stop receiving updates on the given callback function.\n   */\n  public onProgress(callback: (state: TState) => void): CancelOnProgress {\n    this.pollProgressCallbacks.push(callback);\n    return (): void => {\n      this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c) => c !== callback);\n    };\n  }\n\n  /**\n   * Returns true if the poller has finished polling.\n   */\n  public isDone(): boolean {\n    const state: PollOperationState<TResult> = this.operation.state;\n    return Boolean(state.isCompleted || state.isCancelled || state.error);\n  }\n\n  /**\n   * Stops the poller from continuing to poll.\n   */\n  public stopPolling(): void {\n    if (!this.stopped) {\n      this.stopped = true;\n      if (this.reject) {\n        this.reject(new PollerStoppedError(\"This poller is already stopped\"));\n      }\n    }\n  }\n\n  /**\n   * Returns true if the poller is stopped.\n   */\n  public isStopped(): boolean {\n    return this.stopped;\n  }\n\n  /**\n   * Attempts to cancel the underlying operation.\n   *\n   * It only optionally receives an object with an abortSignal property, from \\@azure/abort-controller's AbortSignalLike.\n   *\n   * If it's called again before it finishes, it will throw an error.\n   *\n   * @param options - Optional properties passed to the operation's update method.\n   */\n  public cancelOperation(options: { abortSignal?: AbortSignalLike } = {}): Promise<void> {\n    if (!this.cancelPromise) {\n      this.cancelPromise = this.cancelOnce(options);\n    } else if (options.abortSignal) {\n      throw new Error(\"A cancel request is currently pending\");\n    }\n    return this.cancelPromise;\n  }\n\n  /**\n   * Returns the state of the operation.\n   *\n   * Even though TState will be the same type inside any of the methods of any extension of the Poller class,\n   * implementations of the pollers can customize what's shared with the public by writing their own\n   * version of the `getOperationState` method, and by defining two types, one representing the internal state of the poller\n   * and a public type representing a safe to share subset of the properties of the internal state.\n   * Their definition of getOperationState can then return their public type.\n   *\n   * Example:\n   *\n   * ```ts\n   * // Let's say we have our poller's operation state defined as:\n   * interface MyOperationState extends PollOperationState<ResultType> {\n   *   privateProperty?: string;\n   *   publicProperty?: string;\n   * }\n   *\n   * // To allow us to have a true separation of public and private state, we have to define another interface:\n   * interface PublicState extends PollOperationState<ResultType> {\n   *   publicProperty?: string;\n   * }\n   *\n   * // Then, we define our Poller as follows:\n   * export class MyPoller extends Poller<MyOperationState, ResultType> {\n   *   // ... More content is needed here ...\n   *\n   *   public getOperationState(): PublicState {\n   *     const state: PublicState = this.operation.state;\n   *     return {\n   *       // Properties from PollOperationState<TResult>\n   *       isStarted: state.isStarted,\n   *       isCompleted: state.isCompleted,\n   *       isCancelled: state.isCancelled,\n   *       error: state.error,\n   *       result: state.result,\n   *\n   *       // The only other property needed by PublicState.\n   *       publicProperty: state.publicProperty\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * You can see this in the tests of this repository, go to the file:\n   * `../test/utils/testPoller.ts`\n   * and look for the getOperationState implementation.\n   */\n  public getOperationState(): TState {\n    return this.operation.state;\n  }\n\n  /**\n   * Returns the result value of the operation,\n   * regardless of the state of the poller.\n   * It can return undefined or an incomplete form of the final TResult value\n   * depending on the implementation.\n   */\n  public getResult(): TResult | undefined {\n    const state: PollOperationState<TResult> = this.operation.state;\n    return state.result;\n  }\n\n  /**\n   * Returns a serialized version of the poller's operation\n   * by invoking the operation's toString method.\n   */\n  public toString(): string {\n    return this.operation.toString();\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\n\n/**\n * The `@azure/logger` configuration for this package.\n * @internal\n */\nexport const logger = createClientLogger(\"core-lro\");\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  GetLroStatusFromResponse,\n  LongRunningOperation,\n  LroBody,\n  LroInfo,\n  LroResourceLocationConfig,\n  LroResponse,\n  LroStatus,\n  PollerConfig,\n  RawResponse,\n  ResumablePollOperationState,\n} from \"./models\";\nimport { PollOperationState } from \"../pollOperation\";\nimport { logger } from \"./logger\";\n\nexport function throwIfUndefined<T>(\n  input: T | undefined,\n  options: { errorMessage?: string } = {}\n): T {\n  if (input === undefined) {\n    throw new Error(options.errorMessage ?? \"undefined variable\");\n  }\n  return input;\n}\n\nexport function updatePollingUrl(inputs: { rawResponse: RawResponse; info: LroInfo }): void {\n  const { info, rawResponse } = inputs;\n  switch (info.mode) {\n    case \"OperationLocation\": {\n      const operationLocation = getOperationLocation(rawResponse);\n      const azureAsyncOperation = getAzureAsyncOperation(rawResponse);\n      info.pollingUrl =\n        getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation }) ??\n        throwIfUndefined(info.pollingUrl);\n      break;\n    }\n    case \"ResourceLocation\": {\n      info.pollingUrl = getLocation(rawResponse) ?? throwIfUndefined(info.pollingUrl);\n      break;\n    }\n  }\n}\n\nfunction getOperationLocationPollingUrl(inputs: {\n  operationLocation?: string;\n  azureAsyncOperation?: string;\n}): string | undefined {\n  const { azureAsyncOperation, operationLocation } = inputs;\n  return operationLocation ?? azureAsyncOperation;\n}\n\nfunction getLocation(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"location\"];\n}\n\nfunction getOperationLocation(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"operation-location\"];\n}\n\nfunction getAzureAsyncOperation(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"azure-asyncoperation\"];\n}\n\nfunction findResourceLocation(inputs: {\n  requestMethod: string;\n  location?: string;\n  requestPath: string;\n  lroResourceLocationConfig?: LroResourceLocationConfig;\n}): string | undefined {\n  const { location, requestMethod, requestPath, lroResourceLocationConfig } = inputs;\n  switch (requestMethod) {\n    case \"PUT\": {\n      return requestPath;\n    }\n    case \"DELETE\": {\n      return undefined;\n    }\n    default: {\n      switch (lroResourceLocationConfig) {\n        case \"azure-async-operation\": {\n          return undefined;\n        }\n        case \"original-uri\": {\n          return requestPath;\n        }\n        case \"location\":\n        default: {\n          return location;\n        }\n      }\n    }\n  }\n}\n\nfunction inferLroMode(inputs: {\n  rawResponse: RawResponse;\n  requestPath: string;\n  requestMethod: string;\n  lroResourceLocationConfig?: LroResourceLocationConfig;\n}): LroInfo {\n  const { rawResponse, requestMethod, requestPath, lroResourceLocationConfig } = inputs;\n  const operationLocation = getOperationLocation(rawResponse);\n  const azureAsyncOperation = getAzureAsyncOperation(rawResponse);\n  const location = getLocation(rawResponse);\n  if (operationLocation !== undefined || azureAsyncOperation !== undefined) {\n    return {\n      mode: \"OperationLocation\",\n      pollingUrl: operationLocation ?? azureAsyncOperation,\n      resourceLocation: findResourceLocation({\n        requestMethod,\n        location,\n        requestPath,\n        lroResourceLocationConfig,\n      }),\n    };\n  } else if (location !== undefined) {\n    return {\n      mode: \"ResourceLocation\",\n      pollingUrl: location,\n    };\n  } else if (requestMethod === \"PUT\") {\n    return {\n      mode: \"Body\",\n      pollingUrl: requestPath,\n    };\n  } else {\n    return {\n      mode: \"None\",\n    };\n  }\n}\n\nclass SimpleRestError extends Error {\n  public statusCode?: number;\n  constructor(message: string, statusCode: number) {\n    super(message);\n    this.name = \"RestError\";\n    this.statusCode = statusCode;\n\n    Object.setPrototypeOf(this, SimpleRestError.prototype);\n  }\n}\n\nfunction throwIfError(rawResponse: RawResponse): void {\n  const code = rawResponse.statusCode;\n  if (code >= 400) {\n    throw new SimpleRestError(\n      `Received unexpected HTTP status code ${code} while polling. This may indicate a server issue.`,\n      code\n    );\n  }\n}\n\nfunction getStatus(rawResponse: RawResponse): string {\n  const { status } = (rawResponse.body as LroBody) ?? {};\n  return typeof status === \"string\" ? status.toLowerCase() : \"succeeded\";\n}\n\nfunction getProvisioningState(rawResponse: RawResponse): string {\n  const { properties, provisioningState } = (rawResponse.body as LroBody) ?? {};\n  const state = properties?.provisioningState ?? provisioningState;\n  return typeof state === \"string\" ? state.toLowerCase() : \"succeeded\";\n}\n\nfunction isCanceled<TResult, TState extends PollOperationState<TResult>>(operation: {\n  state: TState;\n  operationStatus: string;\n}): boolean {\n  const { state, operationStatus } = operation;\n  if ([\"canceled\", \"cancelled\"].includes(operationStatus)) {\n    state.isCancelled = true;\n    return true;\n  }\n  return false;\n}\n\nfunction isTerminal<TResult, TState extends PollOperationState<TResult>>(operation: {\n  state: TState;\n  operationStatus: string;\n}): boolean {\n  const { state, operationStatus } = operation;\n  if (operationStatus === \"failed\") {\n    throw new Error(`The long-running operation has failed.`);\n  }\n  return operationStatus === \"succeeded\" || isCanceled({ state, operationStatus });\n}\n\nfunction getOperationStatus<TResult, TState extends PollOperationState<TResult>>(result: {\n  rawResponse: RawResponse;\n  state: TState;\n  info: LroInfo;\n  responseKind?: \"Initial\" | \"Polling\";\n}): {\n  operationStatus?: string | number;\n  shouldStopPolling: boolean;\n} {\n  const { rawResponse, state, info, responseKind = \"Polling\" } = result;\n  throwIfError(rawResponse);\n  switch (info.mode) {\n    case \"OperationLocation\": {\n      const operationStatus = getStatus(rawResponse);\n      return {\n        operationStatus,\n        shouldStopPolling: responseKind === \"Polling\" && isTerminal({ state, operationStatus }),\n      };\n    }\n    case \"Body\": {\n      const operationStatus = getProvisioningState(rawResponse);\n      return {\n        operationStatus,\n        shouldStopPolling: isTerminal({ state, operationStatus }),\n      };\n    }\n    case \"ResourceLocation\": {\n      const operationStatus = rawResponse.statusCode;\n      return {\n        operationStatus,\n        shouldStopPolling: responseKind === \"Polling\" && operationStatus !== 202,\n      };\n    }\n    case \"None\": {\n      return {\n        shouldStopPolling: true,\n      };\n    }\n  }\n}\n\nfunction shouldStopPolling<TResult, TState extends PollOperationState<TResult>>(result: {\n  rawResponse: RawResponse;\n  state: TState;\n  info: LroInfo;\n  responseKind?: \"Initial\" | \"Polling\";\n}): boolean {\n  const { rawResponse, state, info, responseKind = \"Polling\" } = result;\n  const { shouldStopPolling: isPollingStopped, operationStatus } = getOperationStatus({\n    info,\n    rawResponse,\n    state,\n    responseKind,\n  });\n  if (operationStatus) {\n    logger.verbose(\n      `LRO: Status:\\n\\tPolling from: ${\n        info.pollingUrl\n      }\\n\\tOperation status: ${operationStatus}\\n\\tPolling status: ${\n        isPollingStopped ? \"Stopped\" : \"Running\"\n      }`\n    );\n  } else {\n    logger.verbose(`LRO: Status: Not an LRO`);\n  }\n  return isPollingStopped;\n}\n\n/**\n * Creates a polling operation.\n */\nexport function createPoll<TResult>(\n  lroPrimitives: LongRunningOperation<TResult>\n): (\n  pollingURL: string,\n  pollerConfig: PollerConfig,\n  getLroStatusFromResponse: GetLroStatusFromResponse<TResult>\n) => Promise<LroStatus<TResult>> {\n  return async (\n    path: string,\n    pollerConfig: PollerConfig,\n    getLroStatusFromResponse: GetLroStatusFromResponse<TResult>\n  ): Promise<LroStatus<TResult>> => {\n    const response = await lroPrimitives.sendPollRequest(path);\n    const retryAfter: string | undefined = response.rawResponse.headers[\"retry-after\"];\n    if (retryAfter !== undefined) {\n      // Retry-After header value is either in HTTP date format, or in seconds\n      const retryAfterInSeconds = parseInt(retryAfter);\n      pollerConfig.intervalInMs = isNaN(retryAfterInSeconds)\n        ? calculatePollingIntervalFromDate(new Date(retryAfter), pollerConfig.intervalInMs)\n        : retryAfterInSeconds * 1000;\n    }\n    return getLroStatusFromResponse(response);\n  };\n}\n\nfunction calculatePollingIntervalFromDate(\n  retryAfterDate: Date,\n  defaultIntervalInMs: number\n): number {\n  const timeNow = Math.floor(new Date().getTime());\n  const retryAfterTime = retryAfterDate.getTime();\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n  return defaultIntervalInMs;\n}\n\nexport function buildResult<TResult, TState extends PollOperationState<TResult>>(inputs: {\n  response: TResult;\n  state: TState;\n  processResult?: (result: unknown, state: TState) => TResult;\n}): TResult {\n  const { processResult, response, state } = inputs;\n  return processResult ? processResult(response, state) : response;\n}\n\n/**\n * Creates a callback to be used to initialize the polling operation state.\n */\nexport function createStateInitializer<\n  TResult,\n  TState extends PollOperationState<TResult>\n>(inputs: {\n  state: ResumablePollOperationState<TResult>;\n  requestPath: string;\n  requestMethod: string;\n  lroResourceLocationConfig?: LroResourceLocationConfig;\n  processResult?: (result: unknown, state: TState) => TResult;\n}): (response: LroResponse<TResult>) => void {\n  const { requestMethod, requestPath, state, lroResourceLocationConfig, processResult } = inputs;\n  return (response: LroResponse<TResult>): void => {\n    const { rawResponse } = response;\n    state.isStarted = true;\n    state.config = inferLroMode({\n      rawResponse,\n      requestPath,\n      requestMethod,\n      lroResourceLocationConfig,\n    });\n    logger.verbose(`LRO: Operation description:`, state.config);\n    /** short circuit before polling */\n    if (\n      shouldStopPolling({\n        rawResponse,\n        state,\n        info: state.config,\n        responseKind: \"Initial\",\n      })\n    ) {\n      state.result = buildResult({\n        response: response.flatResponse,\n        state: state as TState,\n        processResult,\n      });\n      state.isCompleted = true;\n    }\n  };\n}\n\nexport function createGetLroStatusFromResponse<\n  TResult,\n  TState extends PollOperationState<TResult>\n>(inputs: {\n  lro: LongRunningOperation<TResult>;\n  state: TState;\n  info: LroInfo;\n}): (response: LroResponse<TResult>) => LroStatus<TResult> {\n  const { lro, state, info } = inputs;\n  const location = info.resourceLocation;\n  return (response: LroResponse<TResult>): LroStatus<TResult> => {\n    const isTerminalStatus = shouldStopPolling({\n      info,\n      rawResponse: response.rawResponse,\n      state,\n    });\n    return {\n      ...response,\n      done: isTerminalStatus && !location,\n      next: !(isTerminalStatus && location)\n        ? undefined\n        : () =>\n            lro.sendPollRequest(location).then((res) => ({\n              ...res,\n              done: true,\n            })),\n    };\n  };\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  GetLroStatusFromResponse,\n  LongRunningOperation,\n  LroResourceLocationConfig,\n  LroResponse,\n  LroStatus,\n  PollerConfig,\n  RawResponse,\n  ResumablePollOperationState,\n} from \"./models\";\nimport { PollOperation, PollOperationState } from \"../pollOperation\";\nimport {\n  buildResult,\n  createGetLroStatusFromResponse,\n  createPoll,\n  createStateInitializer,\n  throwIfUndefined,\n  updatePollingUrl,\n} from \"./impl\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { logger } from \"./logger\";\n\nexport class GenericPollOperation<TResult, TState extends PollOperationState<TResult>>\n  implements PollOperation<TState, TResult>\n{\n  private poll?: (\n    pollingURL: string,\n    pollerConfig: PollerConfig,\n    getLroStatusFromResponse: GetLroStatusFromResponse<TResult>\n  ) => Promise<LroStatus<TResult>>;\n  private pollerConfig?: PollerConfig;\n  private getLroStatusFromResponse?: GetLroStatusFromResponse<TResult>;\n\n  constructor(\n    public state: TState & ResumablePollOperationState<TResult>,\n    private lro: LongRunningOperation<TResult>,\n    private lroResourceLocationConfig?: LroResourceLocationConfig,\n    private processResult?: (result: unknown, state: TState) => TResult,\n    private updateState?: (state: TState, lastResponse: RawResponse) => void,\n    private isDone?: (lastResponse: TResult, state: TState) => boolean\n  ) {}\n\n  public setPollerConfig(pollerConfig: PollerConfig): void {\n    this.pollerConfig = pollerConfig;\n  }\n\n  /**\n   * General update function for LROPoller, the general process is as follows\n   * 1. Check initial operation result to determine the strategy to use\n   *  - Strategies: Location, Azure-AsyncOperation, Original Uri\n   * 2. Check if the operation result has a terminal state\n   *  - Terminal state will be determined by each strategy\n   *  2.1 If it is terminal state Check if a final GET request is required, if so\n   *      send final GET request and return result from operation. If no final GET\n   *      is required, just return the result from operation.\n   *      - Determining what to call for final request is responsibility of each strategy\n   *  2.2 If it is not terminal state, call the polling operation and go to step 1\n   *      - Determining what to call for polling is responsibility of each strategy\n   *      - Strategies will always use the latest URI for polling if provided otherwise\n   *        the last known one\n   */\n  async update(options?: {\n    abortSignal?: AbortSignalLike;\n    fireProgress?: (state: TState) => void;\n  }): Promise<PollOperation<TState, TResult>> {\n    const state = this.state;\n    let lastResponse: LroResponse<TResult> | undefined = undefined;\n    if (!state.isStarted) {\n      const initializeState = createStateInitializer({\n        state,\n        requestPath: this.lro.requestPath,\n        requestMethod: this.lro.requestMethod,\n        lroResourceLocationConfig: this.lroResourceLocationConfig,\n        processResult: this.processResult,\n      });\n      lastResponse = await this.lro.sendInitialRequest();\n      initializeState(lastResponse);\n    }\n\n    if (!state.isCompleted) {\n      const config = throwIfUndefined(state.config, {\n        errorMessage:\n          \"Bad state: LRO mode is undefined. Check if the serialized state is well-formed.\",\n      });\n      if (!this.poll) {\n        this.poll = createPoll(this.lro);\n      }\n      if (!this.getLroStatusFromResponse) {\n        const isDone = this.isDone;\n        this.getLroStatusFromResponse = isDone\n          ? (response: LroResponse<TResult>) => ({\n              ...response,\n              done: isDone(response.flatResponse, this.state),\n            })\n          : createGetLroStatusFromResponse({\n              lro: this.lro,\n              info: config,\n              state: this.state,\n            });\n      }\n      const currentState = await this.poll(\n        throwIfUndefined(config.pollingUrl),\n        this.pollerConfig!,\n        this.getLroStatusFromResponse\n      );\n      if (currentState.done) {\n        state.result = buildResult({\n          response: currentState.flatResponse,\n          state,\n          processResult: this.processResult,\n        });\n        state.isCompleted = true;\n      } else {\n        this.poll = currentState.next ?? this.poll;\n        updatePollingUrl({\n          rawResponse: currentState.rawResponse,\n          info: config,\n        });\n        /** for backward compatability */\n        state.pollingURL = config.pollingUrl;\n      }\n      lastResponse = currentState;\n    }\n    if (lastResponse) {\n      this.updateState?.(state, lastResponse?.rawResponse);\n    } else {\n      logger.error(`LRO: no response was received`);\n    }\n    options?.fireProgress?.(state);\n    return this;\n  }\n\n  async cancel(): Promise<PollOperation<TState, TResult>> {\n    logger.error(\"`cancelOperation` is deprecated because it wasn't implemented\");\n    return this;\n  }\n\n  /**\n   * Serializes the Poller operation.\n   */\n  public toString(): string {\n    return JSON.stringify({\n      state: this.state,\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  LongRunningOperation,\n  LroEngineOptions,\n  PollerConfig,\n  ResumablePollOperationState,\n} from \"./models\";\nimport { GenericPollOperation } from \"./operation\";\nimport { PollOperationState } from \"../pollOperation\";\nimport { Poller } from \"../poller\";\n\nfunction deserializeState<TResult, TState>(\n  serializedState: string\n): TState & ResumablePollOperationState<TResult> {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`LroEngine: Unable to deserialize state: ${serializedState}`);\n  }\n}\n\n/**\n * The LRO Engine, a class that performs polling.\n */\nexport class LroEngine<TResult, TState extends PollOperationState<TResult>> extends Poller<\n  TState,\n  TResult\n> {\n  private config: PollerConfig;\n\n  constructor(lro: LongRunningOperation<TResult>, options?: LroEngineOptions<TResult, TState>) {\n    const { intervalInMs = 2000, resumeFrom } = options || {};\n    const state: TState & ResumablePollOperationState<TResult> = resumeFrom\n      ? deserializeState(resumeFrom)\n      : ({} as TState & ResumablePollOperationState<TResult>);\n\n    const operation = new GenericPollOperation(\n      state,\n      lro,\n      options?.lroResourceLocationConfig,\n      options?.processResult,\n      options?.updateState,\n      options?.isDone\n    );\n    super(operation);\n\n    this.config = { intervalInMs: intervalInMs };\n    operation.setPollerConfig(this.config);\n  }\n\n  /**\n   * The method used by the poller to wait before attempting to update its operation.\n   */\n  delay(): Promise<void> {\n    return new Promise((resolve) => setTimeout(() => resolve(), this.config.intervalInMs));\n  }\n}\n"],"names":["createClientLogger"],"mappings":"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"}