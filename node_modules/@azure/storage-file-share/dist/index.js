'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreHttp = require('@azure/core-http');
var tslib = require('tslib');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');
var abortController = require('@azure/abort-controller');
var os = require('os');
var crypto = require('crypto');
require('@azure/core-paging');
var stream = require('stream');
var events = require('events');
var fs = require('fs');
var util = require('util');

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant permissions for that operation. Once all the
 * values are set, this should be serialized with toString and set as the permissions field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */
class AccountSASPermissions {
    constructor() {
        /**
         * Permission to read resources and list queues and tables granted.
         */
        this.read = false;
        /**
         * Permission to write resources granted.
         */
        this.write = false;
        /**
         * Permission to delete blobs and files granted.
         */
        this.delete = false;
        /**
         * Permission to list blob containers, blobs, shares, directories, and files granted.
         */
        this.list = false;
        /**
         * Permission to add messages, table entities, and append to blobs granted.
         */
        this.add = false;
        /**
         * Permission to create blobs and files granted.
         */
        this.create = false;
        /**
         * Permissions to update messages and table entities granted.
         */
        this.update = false;
        /**
         * Permission to get and delete messages granted.
         */
        this.process = false;
    }
    /**
     * Parse initializes the AccountSASPermissions fields from a string.
     *
     * @param permissions -
     */
    static parse(permissions) {
        const accountSASPermissions = new AccountSASPermissions();
        for (const c of permissions) {
            switch (c) {
                case "r":
                    accountSASPermissions.read = true;
                    break;
                case "w":
                    accountSASPermissions.write = true;
                    break;
                case "d":
                    accountSASPermissions.delete = true;
                    break;
                case "l":
                    accountSASPermissions.list = true;
                    break;
                case "a":
                    accountSASPermissions.add = true;
                    break;
                case "c":
                    accountSASPermissions.create = true;
                    break;
                case "u":
                    accountSASPermissions.update = true;
                    break;
                case "p":
                    accountSASPermissions.process = true;
                    break;
                default:
                    throw new RangeError(`Invalid permission character: ${c}`);
            }
        }
        return accountSASPermissions;
    }
    /**
     * Produces the SAS permissions string for an Azure Storage account.
     * Call this method to set AccountSASSignatureValues Permissions field.
     *
     * Using this method will guarantee the resource types are in
     * an order accepted by the service.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     */
    toString() {
        // The order of the characters should be as specified here to ensure correctness:
        // https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
        // Use a string array instead of string concatenating += operator for performance
        const permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.list) {
            permissions.push("l");
        }
        if (this.add) {
            permissions.push("a");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.update) {
            permissions.push("u");
        }
        if (this.process) {
            permissions.push("p");
        }
        return permissions.join("");
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the resources accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that resource type. Once all the
 * values are set, this should be serialized with toString and set as the resources field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the resources string without this class, but
 * the order of the resources is particular and this class guarantees correctness.
 */
class AccountSASResourceTypes {
    constructor() {
        /**
         * Permission to access service level APIs granted.
         */
        this.service = false;
        /**
         * Permission to access container level APIs (Blob Containers, Tables, Queues, File Shares) granted.
         */
        this.container = false;
        /**
         * Permission to access object level APIs (Blobs, Table Entities, Queue Messages, Files) granted.
         */
        this.object = false;
    }
    /**
     * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid resource type.
     *
     * @param resourceTypes -
     */
    static parse(resourceTypes) {
        const accountSASResourceTypes = new AccountSASResourceTypes();
        for (const c of resourceTypes) {
            switch (c) {
                case "s":
                    accountSASResourceTypes.service = true;
                    break;
                case "c":
                    accountSASResourceTypes.container = true;
                    break;
                case "o":
                    accountSASResourceTypes.object = true;
                    break;
                default:
                    throw new RangeError(`Invalid resource type: ${c}`);
            }
        }
        return accountSASResourceTypes;
    }
    /**
     * Converts the given resource types to a string.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     */
    toString() {
        const resourceTypes = [];
        if (this.service) {
            resourceTypes.push("s");
        }
        if (this.container) {
            resourceTypes.push("c");
        }
        if (this.object) {
            resourceTypes.push("o");
        }
        return resourceTypes.join("");
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the services accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that service. Once all the
 * values are set, this should be serialized with toString and set as the services field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the services string without this class, but
 * the order of the services is particular and this class guarantees correctness.
 */
class AccountSASServices {
    constructor() {
        /**
         * Permission to access blob resources granted.
         */
        this.blob = false;
        /**
         * Permission to access file resources granted.
         */
        this.file = false;
        /**
         * Permission to access queue resources granted.
         */
        this.queue = false;
        /**
         * Permission to access table resources granted.
         */
        this.table = false;
    }
    /**
     * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid service.
     *
     * @param services -
     */
    static parse(services) {
        const accountSASServices = new AccountSASServices();
        for (const c of services) {
            switch (c) {
                case "b":
                    accountSASServices.blob = true;
                    break;
                case "f":
                    accountSASServices.file = true;
                    break;
                case "q":
                    accountSASServices.queue = true;
                    break;
                case "t":
                    accountSASServices.table = true;
                    break;
                default:
                    throw new RangeError(`Invalid service character: ${c}`);
            }
        }
        return accountSASServices;
    }
    /**
     * Converts the given services to a string.
     *
     */
    toString() {
        const services = [];
        if (this.blob) {
            services.push("b");
        }
        if (this.table) {
            services.push("t");
        }
        if (this.queue) {
            services.push("q");
        }
        if (this.file) {
            services.push("f");
        }
        return services.join("");
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Generate SasIPRange format string. For example:
 *
 * "8.8.8.8" or "1.1.1.1-255.255.255.255"
 *
 * @param ipRange - A range of IP addresses.
 * @returns string representation of the IP range.
 */
function ipRangeToString(ipRange) {
    return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "12.8.0";
const SERVICE_VERSION = "2020-10-02";
const FILE_MAX_SIZE_BYTES = 4 * 1024 * 1024 * 1024 * 1024; // 4TB
const FILE_RANGE_MAX_SIZE_BYTES = 4 * 1024 * 1024; // 4MB
const DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
const DEFAULT_HIGH_LEVEL_CONCURRENCY = 5;
const URLConstants = {
    Parameters: {
        FORCE_BROWSER_NO_CACHE: "_",
        SHARE_SNAPSHOT: "sharesnapshot",
        SIGNATURE: "sig",
        TIMEOUT: "timeout"
    }
};
const HeaderConstants = {
    AUTHORIZATION: "authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "content-encoding",
    CONTENT_LANGUAGE: "content-language",
    CONTENT_LENGTH: "content-length",
    CONTENT_MD5: "content-md5",
    CONTENT_TYPE: "content-type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date"
};
const StorageFileLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "x-ms-cache-control",
    "x-ms-content-disposition",
    "x-ms-content-encoding",
    "x-ms-content-language",
    "x-ms-content-length",
    "x-ms-content-md5",
    "x-ms-content-type",
    "x-ms-file-attributes",
    "x-ms-file-change-time",
    "x-ms-file-creation-time",
    "x-ms-file-id",
    "x-ms-file-last-write-time",
    "x-ms-file-parent-id",
    "x-ms-handle-id",
    "x-ms-number-of-handles-closed",
    "x-ms-recursive",
    "x-ms-share-quota",
    "x-ms-type",
    "x-ms-write"
];
const StorageFileLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "copyid",
    "restype"
];

// Copyright (c) Microsoft Corporation.
/**
 * Reserved URL characters must be properly escaped for Storage services like Blob or File.
 *
 * ## URL encode and escape strategy for JS SDKs
 *
 * When customers pass a URL string into XXXClient classes constructor, the URL string may already be URL encoded or not.
 * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL
 * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XXXClient constructors.
 *
 * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.
 *
 * This is what legacy V2 SDK does, simple and works for most of the cases.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b:",
 *   SDK will encode it to "http://account.blob.core.windows.net/con/b%3A" and send to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%3A",
 *   SDK will encode it to "http://account.blob.core.windows.net/con/b%253A" and send to server. A blob named "b%3A" will be created.
 *
 * But this strategy will make it not possible to create a blob with "?" in it's name. Because when customer URL string is
 * "http://account.blob.core.windows.net/con/blob?name", the "?name" will be treated as URL paramter instead of blob name.
 * If customer URL string is "http://account.blob.core.windows.net/con/blob%3Fname", a blob named "blob%3Fname" will be created.
 * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.
 * We cannot accept a SDK cannot create a blob name with "?". So we implement strategy two:
 *
 * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.
 *
 * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b:",
 *   SDK will escape ":" like "http://account.blob.core.windows.net/con/b%3A" and send to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%3A",
 *   There is no special characters, so send "http://account.blob.core.windows.net/con/b%3A" to server. A blob named "b:" will be created.
 * - When customer URL string is "http://account.blob.core.windows.net/con/b%253A",
 *   There is no special characters, so send "http://account.blob.core.windows.net/con/b%253A" to server. A blob named "b%3A" will be created.
 *
 * This strategy gives us flexibility to create with any special characters. But "%" will be treated as a special characters, if the URL string
 * is not encoded, there shouldn't a "%" in the URL string, otherwise the URL is not a valid URL.
 * If customer needs to create a blob with "%" in it's blob name, use "%25" insead of "%". Just like above 3rd sample.
 * And following URL strings are invalid:
 * - "http://account.blob.core.windows.net/con/b%"
 * - "http://account.blob.core.windows.net/con/b%2"
 * - "http://account.blob.core.windows.net/con/b%G"
 *
 * Another special character is "?", use "%2F" to represent a blob name with "?" in a URL string.
 *
 * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `ContainerClient.getBlobClient(blobName)`
 *
 * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata
 *
 * @param url -
 */
function escapeURLPath(url) {
    const urlParsed = coreHttp.URLBuilder.parse(url);
    let path = urlParsed.getPath();
    path = path || "/";
    path = escape(path);
    urlParsed.setPath(path);
    return urlParsed.toString();
}
function getValueInConnString(connectionString, argument) {
    const elements = connectionString.split(";");
    for (const element of elements) {
        if (element.trim().startsWith(argument)) {
            return element.trim().match(argument + "=(.*)")[1];
        }
    }
    return "";
}
/**
 * Extracts the parts of an Azure Storage account connection string.
 *
 * @param connectionString - Connection string.
 * @returns String key value pairs of the storage account's url and credentials.
 */
function extractConnectionStringParts(connectionString) {
    // Matching FileEndpoint in the Account connection string
    let fileEndpoint = getValueInConnString(connectionString, "FileEndpoint");
    // Slicing off '/' at the end if exists
    // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)
    fileEndpoint = fileEndpoint.endsWith("/") ? fileEndpoint.slice(0, -1) : fileEndpoint;
    if (connectionString.search("DefaultEndpointsProtocol=") !== -1 &&
        connectionString.search("AccountKey=") !== -1) {
        // Account connection string
        let defaultEndpointsProtocol = "";
        let accountName = "";
        let accountKey = Buffer.from("accountKey", "base64");
        let endpointSuffix = "";
        // Get account name and key
        accountName = getValueInConnString(connectionString, "AccountName");
        accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64");
        if (!fileEndpoint) {
            // FileEndpoint is not present in the Account connection string
            // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.file.${endpointSuffix}`
            defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
            const protocol = defaultEndpointsProtocol.toLowerCase();
            if (protocol !== "https" && protocol !== "http") {
                throw new Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
            }
            endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix");
            if (!endpointSuffix) {
                throw new Error("Invalid EndpointSuffix in the provided Connection String");
            }
            fileEndpoint = `${defaultEndpointsProtocol}://${accountName}.file.${endpointSuffix}`;
        }
        if (!accountName) {
            throw new Error("Invalid AccountName in the provided Connection String");
        }
        else if (accountKey.length === 0) {
            throw new Error("Invalid AccountKey in the provided Connection String");
        }
        return {
            kind: "AccountConnString",
            url: fileEndpoint,
            accountName,
            accountKey
        };
    }
    else {
        // SAS connection string
        const accountSas = getValueInConnString(connectionString, "SharedAccessSignature");
        const accountName = getAccountNameFromUrl(fileEndpoint);
        if (!fileEndpoint) {
            throw new Error("Invalid FileEndpoint in the provided SAS Connection String");
        }
        else if (!accountSas) {
            throw new Error("Invalid SharedAccessSignature in the provided SAS Connection String");
        }
        return { kind: "SASConnString", url: fileEndpoint, accountName, accountSas };
    }
}
/**
 * Internal escape method implemented Strategy Two mentioned in escapeURL() description.
 *
 * @param text -
 */
function escape(text) {
    return encodeURIComponent(text)
        .replace(/%2F/g, "/") // Don't escape for "/"
        .replace(/'/g, "%27") // Escape for "'"
        .replace(/\+/g, "%20")
        .replace(/%25/g, "%"); // Revert encoded "%"
}
/**
 * Append a string to URL path. Will remove duplicated "/" in front of the string
 * when URL path ends with a "/".
 *
 * @param url - Source URL string
 * @param name - String to be appended to URL
 * @returns An updated URL string
 */
function appendToURLPath(url, name) {
    const urlParsed = coreHttp.URLBuilder.parse(url);
    let path = urlParsed.getPath();
    path = path ? (path.endsWith("/") ? `${path}${name}` : `${path}/${name}`) : name;
    urlParsed.setPath(path);
    return urlParsed.toString();
}
/**
 * Append a string to URL query.
 *
 * @param url - Source URL string.
 * @param queryParts - String to be appended to the URL query.
 * @returns An updated URL string.
 */
function appendToURLQuery(url, queryParts) {
    const urlParsed = coreHttp.URLBuilder.parse(url);
    let query = urlParsed.getQuery();
    if (query) {
        query += "&" + queryParts;
    }
    else {
        query = queryParts;
    }
    urlParsed.setQuery(query);
    return urlParsed.toString();
}
/**
 * Set URL parameter name and value. If name exists in URL parameters, old value
 * will be replaced by name key. If not provide value, the parameter will be deleted.
 *
 * @param url - Source URL string
 * @param name - Parameter name
 * @param value - Parameter value
 * @returns An updated URL string
 */
function setURLParameter(url, name, value) {
    const urlParsed = coreHttp.URLBuilder.parse(url);
    urlParsed.setQueryParameter(name, value);
    return urlParsed.toString();
}
/**
 * Get URL path from an URL string.
 *
 * @param url - Source URL string
 */
function getURLPath(url) {
    const urlParsed = coreHttp.URLBuilder.parse(url);
    return urlParsed.getPath();
}
/**
 * Get URL query key value pairs from an URL string.
 *
 * @param url -
 */
function getURLQueries(url) {
    let queryString = coreHttp.URLBuilder.parse(url).getQuery();
    if (!queryString) {
        return {};
    }
    queryString = queryString.trim();
    queryString = queryString.startsWith("?") ? queryString.substr(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
        const indexOfEqual = value.indexOf("=");
        const lastIndexOfEqual = value.lastIndexOf("=");
        return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual;
    });
    const queries = {};
    for (const querySubString of querySubStrings) {
        const splitResults = querySubString.split("=");
        const key = splitResults[0];
        const value = splitResults[1];
        queries[key] = value;
    }
    return queries;
}
/**
 * Rounds a date off to seconds.
 *
 * @param date -
 * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;
 *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.
 * @returns Date string in ISO8061 format, with or without 7 milliseconds component
 */
function truncatedISO8061Date(date, withMilliseconds = true) {
    // Date.toISOString() will return like "2018-10-29T06:34:36.139Z"
    const dateString = date.toISOString();
    return withMilliseconds
        ? dateString.substring(0, dateString.length - 1) + "0000" + "Z"
        : dateString.substring(0, dateString.length - 5) + "Z";
}
/**
 * Delay specified time interval.
 *
 * @param timeInMs -
 * @param aborter -
 * @param abortError -
 */
async function delay(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject) => {
        /* eslint-disable-next-line prefer-const */
        let timeout;
        const abortHandler = () => {
            if (timeout !== undefined) {
                clearTimeout(timeout);
            }
            reject(abortError);
        };
        const resolveHandler = () => {
            if (aborter !== undefined) {
                aborter.removeEventListener("abort", abortHandler);
            }
            resolve();
        };
        /* eslint-disable-next-line prefer-const */
        timeout = setTimeout(resolveHandler, timeInMs);
        if (aborter !== undefined) {
            aborter.addEventListener("abort", abortHandler);
        }
    });
}
/**
 * Extracts account name from the url
 * @param url - url to extract the account name from
 * @returns with the account name
 */
function getAccountNameFromUrl(url) {
    const parsedUrl = coreHttp.URLBuilder.parse(url);
    let accountName;
    try {
        if (parsedUrl.getHost().split(".")[1] === "file") {
            // `${defaultEndpointsProtocol}://${accountName}.file.${endpointSuffix}`;
            // Slicing off '/' at the end if exists
            url = url.endsWith("/") ? url.slice(0, -1) : url;
            accountName = parsedUrl.getHost().split(".")[0];
        }
        else if (isIpEndpointStyle(parsedUrl)) {
            // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/
            // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/
            // .getPath() -> /devstoreaccount1/
            accountName = parsedUrl.getPath().split("/")[1];
        }
        else {
            // Custom domain case: "https://customdomain.com/containername/blob".
            accountName = "";
        }
        return accountName;
    }
    catch (error) {
        throw new Error("Unable to extract accountName with provided information.");
    }
}
function isIpEndpointStyle(parsedUrl) {
    if (parsedUrl.getHost() === undefined) {
        return false;
    }
    const host = parsedUrl.getHost() + (parsedUrl.getPort() === undefined ? "" : ":" + parsedUrl.getPort());
    // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.
    // Case 2: localhost(:port), use broad regex to match port part.
    // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.
    // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.
    return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host);
}
function getShareNameAndPathFromUrl(url) {
    //  URL may look like the following
    // "https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString";
    // "https://myaccount.file.core.windows.net/myshare/mydirectory/file";
    // "https://myaccount.file.core.windows.net/myshare/mydirectory?sasString";
    // "https://myaccount.file.core.windows.net/myshare/mydirectory";
    // "https://myaccount.file.core.windows.net/myshare?sasString";
    // "https://myaccount.file.core.windows.net/myshare";
    // IPv4/IPv6 address hosts, Endpoints - `http://187.24.0.1:1000/devstoreaccount1/mydirectory/file`
    // http://localhost:1000/devstoreaccount1/mydirectory/file
    // mydirectory can consist of multiple directories - dir1/dir2/dir3
    let shareName;
    let path;
    let baseName;
    try {
        const parsedUrl = coreHttp.URLBuilder.parse(url);
        if (parsedUrl.getHost().split(".")[1] === "file") {
            // "https://myaccount.file.core.windows.net/myshare/mydirectory/file";
            // .getPath() -> /myshare/mydirectory/file
            const pathComponents = parsedUrl.getPath().match("/([^/]*)(/(.*))?");
            shareName = pathComponents[1];
            path = pathComponents[3];
        }
        else if (isIpEndpointStyle(parsedUrl)) {
            // IPv4/IPv6 address hosts... Example - http://187.24.0.1:1000/devstoreaccount1/mydirectory/file
            // Single word domain without a [dot] in the endpoint... Example - http://localhost:1000/devstoreaccount1/mydirectory/file
            // .getPath() -> /devstoreaccount1/mydirectory/file
            const pathComponents = parsedUrl.getPath().match("/([^/]*)/([^/]*)(/(.*))?");
            shareName = pathComponents[2];
            path = pathComponents[4];
        }
        else {
            // "https://customdomain.com/myshare/mydirectory/file";
            // .getPath() -> /myshare/mydirectory/file
            const pathComponents = parsedUrl.getPath().match("/([^/]*)(/(.*))?");
            shareName = pathComponents[1];
            path = pathComponents[3];
        }
        // decode the encoded shareName and filePath - to get all the special characters that might be present in it
        shareName = decodeURIComponent(shareName);
        path = decodeURIComponent(path);
        // Cast to string is required as TypeScript cannot infer that split() always returns
        // an array with length >= 1
        baseName = path.split("/").pop();
        if (!shareName) {
            throw new Error("Provided shareName is invalid.");
        }
        else {
            return { baseName, shareName, path };
        }
    }
    catch (error) {
        throw new Error("Unable to extract shareName and filePath/directoryPath with provided information.");
    }
}
function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : undefined;
}

// Copyright (c) Microsoft Corporation.
(function (SASProtocol) {
    /**
     * Protocol that allows HTTPS only
     */
    SASProtocol["Https"] = "https";
    /**
     * Protocol that allows both HTTPS and HTTP
     */
    SASProtocol["HttpsAndHttp"] = "https,http";
})(exports.SASProtocol || (exports.SASProtocol = {}));
/**
 * Represents the components that make up an Azure Storage SAS' query parameters. This type is not constructed directly
 * by the user; it is only generated by the {@link AccountSASSignatureValues} and {@link FileSASSignatureValues}
 * types. Once generated, it can be encoded into a {@link String} and appended to a URL directly (though caution should
 * be taken here in case there are existing query parameters, which might affect the appropriate means of appending
 * these query parameters).
 *
 * NOTE: Instances of this class are immutable.
 */
class SASQueryParameters {
    /**
     * Creates an instance of SASQueryParameters.
     *
     * @param version - Representing the storage version
     * @param signature - Representing the signature for the SAS token
     * @param permissions - Representing the storage permissions
     * @param services - Representing the storage services being accessed (only for Account SAS)
     * @param resourceTypes - Representing the storage resource types being accessed (only for Account SAS)
     * @param protocol - Representing the allowed HTTP protocol(s)
     * @param startsOn - Representing the start time for this SAS token
     * @param expiresOn - Representing the expiry time for this SAS token
     * @param ipRange - Representing the range of valid IP addresses for this SAS token
     * @param identifier - Representing the signed identifier (only for Service SAS)
     * @param resource - Representing the storage container or blob (only for Service SAS)
     * @param cacheControl - Representing the cache-control header (only for Blob/File Service SAS)
     * @param contentDisposition - Representing the content-disposition header (only for Blob/File Service SAS)
     * @param contentEncoding - Representing the content-encoding header (only for Blob/File Service SAS)
     * @param contentLanguage - Representing the content-language header (only for Blob/File Service SAS)
     * @param contentType - Representing the content-type header (only for Blob/File Service SAS)
     */
    constructor(version, signature, permissions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType) {
        this.version = version;
        this.services = services;
        this.resourceTypes = resourceTypes;
        this.expiresOn = expiresOn;
        this.permissions = permissions;
        this.protocol = protocol;
        this.startsOn = startsOn;
        this.ipRangeInner = ipRange;
        this.identifier = identifier;
        this.resource = resource;
        this.signature = signature;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType;
    }
    /**
     * Optional. IP range allowed for this SAS.
     *
     * @readonly
     */
    get ipRange() {
        if (this.ipRangeInner) {
            return {
                end: this.ipRangeInner.end,
                start: this.ipRangeInner.start
            };
        }
        return undefined;
    }
    /**
     * Encodes all SAS query parameters into a string that can be appended to a URL.
     *
     */
    toString() {
        const params = [
            "sv",
            "ss",
            "srt",
            "spr",
            "st",
            "se",
            "sip",
            "si",
            "sr",
            "sp",
            "sig",
            "rscc",
            "rscd",
            "rsce",
            "rscl",
            "rsct"
        ];
        const queries = [];
        for (const param of params) {
            switch (param) {
                case "sv":
                    this.tryAppendQueryParameter(queries, param, this.version);
                    break;
                case "ss":
                    this.tryAppendQueryParameter(queries, param, this.services);
                    break;
                case "srt":
                    this.tryAppendQueryParameter(queries, param, this.resourceTypes);
                    break;
                case "spr":
                    this.tryAppendQueryParameter(queries, param, this.protocol);
                    break;
                case "st":
                    this.tryAppendQueryParameter(queries, param, this.startsOn ? truncatedISO8061Date(this.startsOn, false) : undefined);
                    break;
                case "se":
                    this.tryAppendQueryParameter(queries, param, this.expiresOn ? truncatedISO8061Date(this.expiresOn, false) : undefined);
                    break;
                case "sip":
                    this.tryAppendQueryParameter(queries, param, this.ipRange ? ipRangeToString(this.ipRange) : undefined);
                    break;
                case "si":
                    this.tryAppendQueryParameter(queries, param, this.identifier);
                    break;
                case "sr":
                    this.tryAppendQueryParameter(queries, param, this.resource);
                    break;
                case "sp":
                    this.tryAppendQueryParameter(queries, param, this.permissions);
                    break;
                case "sig":
                    this.tryAppendQueryParameter(queries, param, this.signature);
                    break;
                case "rscc":
                    this.tryAppendQueryParameter(queries, param, this.cacheControl);
                    break;
                case "rscd":
                    this.tryAppendQueryParameter(queries, param, this.contentDisposition);
                    break;
                case "rsce":
                    this.tryAppendQueryParameter(queries, param, this.contentEncoding);
                    break;
                case "rscl":
                    this.tryAppendQueryParameter(queries, param, this.contentLanguage);
                    break;
                case "rsct":
                    this.tryAppendQueryParameter(queries, param, this.contentType);
                    break;
            }
        }
        return queries.join("&");
    }
    /**
     * A private helper method used to filter and append query key/value pairs into an array.
     *
     * @param queries -
     * @param key -
     * @param value -
     */
    tryAppendQueryParameter(queries, key, value) {
        if (!value) {
            return;
        }
        key = encodeURIComponent(key);
        value = encodeURIComponent(value);
        if (key.length > 0 && value.length > 0) {
            queries.push(`${key}=${value}`);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Generates a {@link SASQueryParameters} object which contains all SAS query parameters needed to make an actual
 * REST request.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
 *
 * @param sharedKeyCredential -
 */
function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    const version = accountSASSignatureValues.version
        ? accountSASSignatureValues.version
        : SERVICE_VERSION;
    const parsedPermissions = AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString()).toString();
    const parsedServices = AccountSASServices.parse(accountSASSignatureValues.services).toString();
    const parsedResourceTypes = AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString();
    const stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn
            ? truncatedISO8061Date(accountSASSignatureValues.startsOn, false)
            : "",
        truncatedISO8061Date(accountSASSignatureValues.expiresOn, false),
        accountSASSignatureValues.ipRange ? ipRangeToString(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version,
        "" // Account SAS requires an additional newline character
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, parsedPermissions, parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange);
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a file. Setting
 * a value to true means that any SAS which uses these permissions will grant permissions for that operation. Once all
 * the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */
class FileSASPermissions {
    constructor() {
        /**
         * Specifies Read access granted.
         */
        this.read = false;
        /**
         * Specifies Create access granted.
         */
        this.create = false;
        /**
         * Specifies Write access granted.
         */
        this.write = false;
        /**
         * Specifies Delete access granted.
         */
        this.delete = false;
    }
    /**
     * Creates a FileSASPermissions from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */
    static parse(permissions) {
        const fileSASPermissions = new FileSASPermissions();
        for (const char of permissions) {
            switch (char) {
                case "r":
                    fileSASPermissions.read = true;
                    break;
                case "c":
                    fileSASPermissions.create = true;
                    break;
                case "w":
                    fileSASPermissions.write = true;
                    break;
                case "d":
                    fileSASPermissions.delete = true;
                    break;
                default:
                    throw new RangeError(`Invalid permission: ${char}`);
            }
        }
        return fileSASPermissions;
    }
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * @returns A string which represents the FileSASPermissions
     */
    toString() {
        const permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        return permissions.join("");
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a share.
 * Setting a value to true means that any SAS which uses these permissions will grant permissions for that operation.
 * Once all the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */
class ShareSASPermissions {
    constructor() {
        /**
         * Specifies Read access granted.
         */
        this.read = false;
        /**
         * Specifies Create access granted.
         */
        this.create = false;
        /**
         * Specifies Write access granted.
         */
        this.write = false;
        /**
         * Specifies Delete access granted.
         */
        this.delete = false;
        /**
         * Specifies List access granted.
         */
        this.list = false;
    }
    /**
     * Creates an {@link ShareSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */
    static parse(permissions) {
        const shareSASPermissions = new ShareSASPermissions();
        for (const char of permissions) {
            switch (char) {
                case "r":
                    shareSASPermissions.read = true;
                    break;
                case "c":
                    shareSASPermissions.create = true;
                    break;
                case "w":
                    shareSASPermissions.write = true;
                    break;
                case "d":
                    shareSASPermissions.delete = true;
                    break;
                case "l":
                    shareSASPermissions.list = true;
                    break;
                default:
                    throw new RangeError(`Invalid permission ${char}`);
            }
        }
        return shareSASPermissions;
    }
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * The order of the characters should be as specified here to ensure correctness.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     */
    toString() {
        const permissions = [];
        if (this.read) {
            permissions.push("r");
        }
        if (this.create) {
            permissions.push("c");
        }
        if (this.write) {
            permissions.push("w");
        }
        if (this.delete) {
            permissions.push("d");
        }
        if (this.list) {
            permissions.push("l");
        }
        return permissions.join("");
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param fileSASSignatureValues -
 * @param sharedKeyCredential -
 */
function generateFileSASQueryParameters(fileSASSignatureValues, sharedKeyCredential) {
    if (!fileSASSignatureValues.identifier &&
        !(fileSASSignatureValues.permissions && fileSASSignatureValues.expiresOn)) {
        throw new RangeError("Must provide 'permissions' and 'expiresOn' for File SAS generation when 'identifier' is not provided.");
    }
    const version = fileSASSignatureValues.version ? fileSASSignatureValues.version : SERVICE_VERSION;
    let resource = "s";
    if (fileSASSignatureValues.filePath) {
        resource = "f";
    }
    let verifiedPermissions;
    // Calling parse and toString guarantees the proper ordering and throws on invalid characters.
    if (fileSASSignatureValues.permissions) {
        if (fileSASSignatureValues.filePath) {
            verifiedPermissions = FileSASPermissions.parse(fileSASSignatureValues.permissions.toString()).toString();
        }
        else {
            verifiedPermissions = ShareSASPermissions.parse(fileSASSignatureValues.permissions.toString()).toString();
        }
    }
    // Signature is generated on the un-url-encoded values.
    const stringToSign = [
        verifiedPermissions,
        fileSASSignatureValues.startsOn
            ? truncatedISO8061Date(fileSASSignatureValues.startsOn, false)
            : "",
        fileSASSignatureValues.expiresOn
            ? truncatedISO8061Date(fileSASSignatureValues.expiresOn, false)
            : "",
        getCanonicalName(sharedKeyCredential.accountName, fileSASSignatureValues.shareName, fileSASSignatureValues.filePath),
        fileSASSignatureValues.identifier,
        fileSASSignatureValues.ipRange ? ipRangeToString(fileSASSignatureValues.ipRange) : "",
        fileSASSignatureValues.protocol,
        version,
        fileSASSignatureValues.cacheControl,
        fileSASSignatureValues.contentDisposition,
        fileSASSignatureValues.contentEncoding,
        fileSASSignatureValues.contentLanguage,
        fileSASSignatureValues.contentType
    ].join("\n");
    const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return new SASQueryParameters(version, signature, verifiedPermissions, undefined, undefined, fileSASSignatureValues.protocol, fileSASSignatureValues.startsOn, fileSASSignatureValues.expiresOn, fileSASSignatureValues.ipRange, fileSASSignatureValues.identifier, resource, fileSASSignatureValues.cacheControl, fileSASSignatureValues.contentDisposition, fileSASSignatureValues.contentEncoding, fileSASSignatureValues.contentLanguage, fileSASSignatureValues.contentType);
}
function getCanonicalName(accountName, shareName, filePath) {
    // Share: "/file/account/sharename"
    // File:  "/file/account/sharename/filename"
    // File:  "/file/account/sharename/directoryname/filename"
    const elements = [`/file/${accountName}/${shareName}`];
    if (filePath) {
        elements.push(`/${filePath}`);
    }
    return elements.join("");
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const FileServiceProperties = {
    serializedName: "FileServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
        name: "Composite",
        className: "FileServiceProperties",
        modelProperties: {
            hourMetrics: {
                serializedName: "HourMetrics",
                xmlName: "HourMetrics",
                type: {
                    name: "Composite",
                    className: "Metrics"
                }
            },
            minuteMetrics: {
                serializedName: "MinuteMetrics",
                xmlName: "MinuteMetrics",
                type: {
                    name: "Composite",
                    className: "Metrics"
                }
            },
            cors: {
                serializedName: "Cors",
                xmlName: "Cors",
                xmlIsWrapped: true,
                xmlElementName: "CorsRule",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CorsRule"
                        }
                    }
                }
            },
            protocol: {
                serializedName: "Protocol",
                xmlName: "ProtocolSettings",
                type: {
                    name: "Composite",
                    className: "ShareProtocolSettings"
                }
            }
        }
    }
};
const Metrics = {
    serializedName: "Metrics",
    type: {
        name: "Composite",
        className: "Metrics",
        modelProperties: {
            version: {
                serializedName: "Version",
                required: true,
                xmlName: "Version",
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "Enabled",
                required: true,
                xmlName: "Enabled",
                type: {
                    name: "Boolean"
                }
            },
            includeAPIs: {
                serializedName: "IncludeAPIs",
                xmlName: "IncludeAPIs",
                type: {
                    name: "Boolean"
                }
            },
            retentionPolicy: {
                serializedName: "RetentionPolicy",
                xmlName: "RetentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicy"
                }
            }
        }
    }
};
const RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
        name: "Composite",
        className: "RetentionPolicy",
        modelProperties: {
            enabled: {
                serializedName: "Enabled",
                required: true,
                xmlName: "Enabled",
                type: {
                    name: "Boolean"
                }
            },
            days: {
                constraints: {
                    InclusiveMaximum: 365,
                    InclusiveMinimum: 1
                },
                serializedName: "Days",
                xmlName: "Days",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CorsRule = {
    serializedName: "CorsRule",
    type: {
        name: "Composite",
        className: "CorsRule",
        modelProperties: {
            allowedOrigins: {
                serializedName: "AllowedOrigins",
                required: true,
                xmlName: "AllowedOrigins",
                type: {
                    name: "String"
                }
            },
            allowedMethods: {
                serializedName: "AllowedMethods",
                required: true,
                xmlName: "AllowedMethods",
                type: {
                    name: "String"
                }
            },
            allowedHeaders: {
                serializedName: "AllowedHeaders",
                required: true,
                xmlName: "AllowedHeaders",
                type: {
                    name: "String"
                }
            },
            exposedHeaders: {
                serializedName: "ExposedHeaders",
                required: true,
                xmlName: "ExposedHeaders",
                type: {
                    name: "String"
                }
            },
            maxAgeInSeconds: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "MaxAgeInSeconds",
                required: true,
                xmlName: "MaxAgeInSeconds",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ShareProtocolSettings = {
    serializedName: "ShareProtocolSettings",
    xmlName: "ProtocolSettings",
    type: {
        name: "Composite",
        className: "ShareProtocolSettings",
        modelProperties: {
            smb: {
                serializedName: "Smb",
                xmlName: "SMB",
                type: {
                    name: "Composite",
                    className: "ShareSmbSettings"
                }
            }
        }
    }
};
const ShareSmbSettings = {
    serializedName: "ShareSmbSettings",
    xmlName: "SMB",
    type: {
        name: "Composite",
        className: "ShareSmbSettings",
        modelProperties: {
            multichannel: {
                serializedName: "Multichannel",
                xmlName: "Multichannel",
                type: {
                    name: "Composite",
                    className: "SmbMultichannel"
                }
            }
        }
    }
};
const SmbMultichannel = {
    serializedName: "SmbMultichannel",
    xmlName: "Multichannel",
    type: {
        name: "Composite",
        className: "SmbMultichannel",
        modelProperties: {
            enabled: {
                serializedName: "Enabled",
                xmlName: "Enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const StorageError = {
    serializedName: "StorageError",
    type: {
        name: "Composite",
        className: "StorageError",
        modelProperties: {
            message: {
                serializedName: "Message",
                xmlName: "Message",
                type: {
                    name: "String"
                }
            },
            code: {
                serializedName: "Code",
                xmlName: "Code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListSharesResponse = {
    serializedName: "ListSharesResponse",
    xmlName: "EnumerationResults",
    type: {
        name: "Composite",
        className: "ListSharesResponse",
        modelProperties: {
            serviceEndpoint: {
                serializedName: "ServiceEndpoint",
                required: true,
                xmlName: "ServiceEndpoint",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            prefix: {
                serializedName: "Prefix",
                xmlName: "Prefix",
                type: {
                    name: "String"
                }
            },
            marker: {
                serializedName: "Marker",
                xmlName: "Marker",
                type: {
                    name: "String"
                }
            },
            maxResults: {
                serializedName: "MaxResults",
                xmlName: "MaxResults",
                type: {
                    name: "Number"
                }
            },
            shareItems: {
                serializedName: "ShareItems",
                xmlName: "Shares",
                xmlIsWrapped: true,
                xmlElementName: "Share",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ShareItemInternal"
                        }
                    }
                }
            },
            continuationToken: {
                serializedName: "NextMarker",
                required: true,
                xmlName: "NextMarker",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareItemInternal = {
    serializedName: "ShareItemInternal",
    xmlName: "Share",
    type: {
        name: "Composite",
        className: "ShareItemInternal",
        modelProperties: {
            name: {
                serializedName: "Name",
                required: true,
                xmlName: "Name",
                type: {
                    name: "String"
                }
            },
            snapshot: {
                serializedName: "Snapshot",
                xmlName: "Snapshot",
                type: {
                    name: "String"
                }
            },
            deleted: {
                serializedName: "Deleted",
                xmlName: "Deleted",
                type: {
                    name: "Boolean"
                }
            },
            version: {
                serializedName: "Version",
                xmlName: "Version",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "Properties",
                xmlName: "Properties",
                type: {
                    name: "Composite",
                    className: "SharePropertiesInternal"
                }
            },
            metadata: {
                serializedName: "Metadata",
                xmlName: "Metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const SharePropertiesInternal = {
    serializedName: "SharePropertiesInternal",
    type: {
        name: "Composite",
        className: "SharePropertiesInternal",
        modelProperties: {
            lastModified: {
                serializedName: "Last-Modified",
                required: true,
                xmlName: "Last-Modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "Etag",
                required: true,
                xmlName: "Etag",
                type: {
                    name: "String"
                }
            },
            quota: {
                serializedName: "Quota",
                required: true,
                xmlName: "Quota",
                type: {
                    name: "Number"
                }
            },
            provisionedIops: {
                serializedName: "ProvisionedIops",
                xmlName: "ProvisionedIops",
                type: {
                    name: "Number"
                }
            },
            provisionedIngressMBps: {
                serializedName: "ProvisionedIngressMBps",
                xmlName: "ProvisionedIngressMBps",
                type: {
                    name: "Number"
                }
            },
            provisionedEgressMBps: {
                serializedName: "ProvisionedEgressMBps",
                xmlName: "ProvisionedEgressMBps",
                type: {
                    name: "Number"
                }
            },
            nextAllowedQuotaDowngradeTime: {
                serializedName: "NextAllowedQuotaDowngradeTime",
                xmlName: "NextAllowedQuotaDowngradeTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            deletedTime: {
                serializedName: "DeletedTime",
                xmlName: "DeletedTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            remainingRetentionDays: {
                serializedName: "RemainingRetentionDays",
                xmlName: "RemainingRetentionDays",
                type: {
                    name: "Number"
                }
            },
            accessTier: {
                serializedName: "AccessTier",
                xmlName: "AccessTier",
                type: {
                    name: "String"
                }
            },
            accessTierChangeTime: {
                serializedName: "AccessTierChangeTime",
                xmlName: "AccessTierChangeTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            accessTierTransitionState: {
                serializedName: "AccessTierTransitionState",
                xmlName: "AccessTierTransitionState",
                type: {
                    name: "String"
                }
            },
            leaseStatus: {
                serializedName: "LeaseStatus",
                xmlName: "LeaseStatus",
                type: {
                    name: "Enum",
                    allowedValues: ["locked", "unlocked"]
                }
            },
            leaseState: {
                serializedName: "LeaseState",
                xmlName: "LeaseState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "available",
                        "leased",
                        "expired",
                        "breaking",
                        "broken"
                    ]
                }
            },
            leaseDuration: {
                serializedName: "LeaseDuration",
                xmlName: "LeaseDuration",
                type: {
                    name: "Enum",
                    allowedValues: ["infinite", "fixed"]
                }
            },
            enabledProtocols: {
                serializedName: "EnabledProtocols",
                xmlName: "EnabledProtocols",
                type: {
                    name: "String"
                }
            },
            rootSquash: {
                serializedName: "RootSquash",
                xmlName: "RootSquash",
                type: {
                    name: "Enum",
                    allowedValues: ["NoRootSquash", "RootSquash", "AllSquash"]
                }
            }
        }
    }
};
const SharePermission = {
    serializedName: "SharePermission",
    type: {
        name: "Composite",
        className: "SharePermission",
        modelProperties: {
            permission: {
                serializedName: "permission",
                required: true,
                xmlName: "permission",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SignedIdentifier = {
    serializedName: "SignedIdentifier",
    type: {
        name: "Composite",
        className: "SignedIdentifier",
        modelProperties: {
            id: {
                serializedName: "Id",
                required: true,
                xmlName: "Id",
                type: {
                    name: "String"
                }
            },
            accessPolicy: {
                serializedName: "AccessPolicy",
                xmlName: "AccessPolicy",
                type: {
                    name: "Composite",
                    className: "AccessPolicy"
                }
            }
        }
    }
};
const AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
        name: "Composite",
        className: "AccessPolicy",
        modelProperties: {
            startsOn: {
                serializedName: "Start",
                xmlName: "Start",
                type: {
                    name: "String"
                }
            },
            expiresOn: {
                serializedName: "Expiry",
                xmlName: "Expiry",
                type: {
                    name: "String"
                }
            },
            permissions: {
                serializedName: "Permission",
                xmlName: "Permission",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareStats = {
    serializedName: "ShareStats",
    type: {
        name: "Composite",
        className: "ShareStats",
        modelProperties: {
            shareUsageBytes: {
                serializedName: "ShareUsageBytes",
                required: true,
                xmlName: "ShareUsageBytes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ListFilesAndDirectoriesSegmentResponse = {
    serializedName: "ListFilesAndDirectoriesSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
        name: "Composite",
        className: "ListFilesAndDirectoriesSegmentResponse",
        modelProperties: {
            serviceEndpoint: {
                serializedName: "ServiceEndpoint",
                required: true,
                xmlName: "ServiceEndpoint",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            shareName: {
                serializedName: "ShareName",
                required: true,
                xmlName: "ShareName",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            shareSnapshot: {
                serializedName: "ShareSnapshot",
                xmlName: "ShareSnapshot",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            directoryPath: {
                serializedName: "DirectoryPath",
                required: true,
                xmlName: "DirectoryPath",
                xmlIsAttribute: true,
                type: {
                    name: "String"
                }
            },
            prefix: {
                serializedName: "Prefix",
                required: true,
                xmlName: "Prefix",
                type: {
                    name: "String"
                }
            },
            marker: {
                serializedName: "Marker",
                xmlName: "Marker",
                type: {
                    name: "String"
                }
            },
            maxResults: {
                serializedName: "MaxResults",
                xmlName: "MaxResults",
                type: {
                    name: "Number"
                }
            },
            segment: {
                serializedName: "Segment",
                xmlName: "Entries",
                type: {
                    name: "Composite",
                    className: "FilesAndDirectoriesListSegment"
                }
            },
            continuationToken: {
                serializedName: "NextMarker",
                required: true,
                xmlName: "NextMarker",
                type: {
                    name: "String"
                }
            },
            directoryId: {
                serializedName: "DirectoryId",
                xmlName: "DirectoryId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FilesAndDirectoriesListSegment = {
    serializedName: "FilesAndDirectoriesListSegment",
    xmlName: "Entries",
    type: {
        name: "Composite",
        className: "FilesAndDirectoriesListSegment",
        modelProperties: {
            directoryItems: {
                serializedName: "DirectoryItems",
                required: true,
                xmlName: "DirectoryItems",
                xmlElementName: "Directory",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DirectoryItem"
                        }
                    }
                }
            },
            fileItems: {
                serializedName: "FileItems",
                required: true,
                xmlName: "FileItems",
                xmlElementName: "File",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FileItem"
                        }
                    }
                }
            }
        }
    }
};
const DirectoryItem = {
    serializedName: "DirectoryItem",
    xmlName: "Directory",
    type: {
        name: "Composite",
        className: "DirectoryItem",
        modelProperties: {
            name: {
                serializedName: "Name",
                required: true,
                xmlName: "Name",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "FileId",
                xmlName: "FileId",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "Properties",
                xmlName: "Properties",
                type: {
                    name: "Composite",
                    className: "FileProperty"
                }
            },
            attributes: {
                serializedName: "Attributes",
                xmlName: "Attributes",
                type: {
                    name: "String"
                }
            },
            permissionKey: {
                serializedName: "PermissionKey",
                xmlName: "PermissionKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileProperty = {
    serializedName: "FileProperty",
    type: {
        name: "Composite",
        className: "FileProperty",
        modelProperties: {
            contentLength: {
                serializedName: "Content-Length",
                required: true,
                xmlName: "Content-Length",
                type: {
                    name: "Number"
                }
            },
            creationTime: {
                serializedName: "CreationTime",
                xmlName: "CreationTime",
                type: {
                    name: "DateTime"
                }
            },
            lastAccessTime: {
                serializedName: "LastAccessTime",
                xmlName: "LastAccessTime",
                type: {
                    name: "DateTime"
                }
            },
            lastWriteTime: {
                serializedName: "LastWriteTime",
                xmlName: "LastWriteTime",
                type: {
                    name: "DateTime"
                }
            },
            changeTime: {
                serializedName: "ChangeTime",
                xmlName: "ChangeTime",
                type: {
                    name: "DateTime"
                }
            },
            lastModified: {
                serializedName: "Last-Modified",
                xmlName: "Last-Modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "Etag",
                xmlName: "Etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileItem = {
    serializedName: "FileItem",
    xmlName: "File",
    type: {
        name: "Composite",
        className: "FileItem",
        modelProperties: {
            name: {
                serializedName: "Name",
                required: true,
                xmlName: "Name",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "FileId",
                xmlName: "FileId",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "Properties",
                xmlName: "Properties",
                type: {
                    name: "Composite",
                    className: "FileProperty"
                }
            },
            attributes: {
                serializedName: "Attributes",
                xmlName: "Attributes",
                type: {
                    name: "String"
                }
            },
            permissionKey: {
                serializedName: "PermissionKey",
                xmlName: "PermissionKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListHandlesResponse = {
    serializedName: "ListHandlesResponse",
    xmlName: "EnumerationResults",
    type: {
        name: "Composite",
        className: "ListHandlesResponse",
        modelProperties: {
            handleList: {
                serializedName: "HandleList",
                xmlName: "Entries",
                xmlIsWrapped: true,
                xmlElementName: "Handle",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HandleItem"
                        }
                    }
                }
            },
            continuationToken: {
                serializedName: "NextMarker",
                required: true,
                xmlName: "NextMarker",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HandleItem = {
    serializedName: "HandleItem",
    xmlName: "Handle",
    type: {
        name: "Composite",
        className: "HandleItem",
        modelProperties: {
            handleId: {
                serializedName: "HandleId",
                required: true,
                xmlName: "HandleId",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "Path",
                required: true,
                xmlName: "Path",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "FileId",
                required: true,
                xmlName: "FileId",
                type: {
                    name: "String"
                }
            },
            parentId: {
                serializedName: "ParentId",
                xmlName: "ParentId",
                type: {
                    name: "String"
                }
            },
            sessionId: {
                serializedName: "SessionId",
                required: true,
                xmlName: "SessionId",
                type: {
                    name: "String"
                }
            },
            clientIp: {
                serializedName: "ClientIp",
                required: true,
                xmlName: "ClientIp",
                type: {
                    name: "String"
                }
            },
            openTime: {
                serializedName: "OpenTime",
                required: true,
                xmlName: "OpenTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            lastReconnectTime: {
                serializedName: "LastReconnectTime",
                xmlName: "LastReconnectTime",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const ShareFileRangeList = {
    serializedName: "ShareFileRangeList",
    type: {
        name: "Composite",
        className: "ShareFileRangeList",
        modelProperties: {
            ranges: {
                serializedName: "Ranges",
                xmlName: "Ranges",
                xmlElementName: "Range",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FileRange"
                        }
                    }
                }
            },
            clearRanges: {
                serializedName: "ClearRanges",
                xmlName: "ClearRanges",
                xmlElementName: "ClearRange",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClearRange"
                        }
                    }
                }
            }
        }
    }
};
const FileRange = {
    serializedName: "FileRange",
    xmlName: "Range",
    type: {
        name: "Composite",
        className: "FileRange",
        modelProperties: {
            start: {
                serializedName: "Start",
                required: true,
                xmlName: "Start",
                type: {
                    name: "Number"
                }
            },
            end: {
                serializedName: "End",
                required: true,
                xmlName: "End",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ClearRange = {
    serializedName: "ClearRange",
    xmlName: "ClearRange",
    type: {
        name: "Composite",
        className: "ClearRange",
        modelProperties: {
            start: {
                serializedName: "Start",
                required: true,
                xmlName: "Start",
                type: {
                    name: "Number"
                }
            },
            end: {
                serializedName: "End",
                required: true,
                xmlName: "End",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ServiceSetPropertiesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ServiceSetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ServiceGetPropertiesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ServiceGetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceListSharesSegmentHeaders = {
    serializedName: "Service_listSharesSegmentHeaders",
    type: {
        name: "Composite",
        className: "ServiceListSharesSegmentHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceListSharesSegmentExceptionHeaders = {
    serializedName: "Service_listSharesSegmentExceptionHeaders",
    type: {
        name: "Composite",
        className: "ServiceListSharesSegmentExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareCreateHeaders = {
    serializedName: "Share_createHeaders",
    type: {
        name: "Composite",
        className: "ShareCreateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareCreateExceptionHeaders = {
    serializedName: "Share_createExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareCreateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareGetPropertiesHeaders = {
    serializedName: "Share_getPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ShareGetPropertiesHeaders",
        modelProperties: {
            metadata: {
                serializedName: "x-ms-meta",
                xmlName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            quota: {
                serializedName: "x-ms-share-quota",
                xmlName: "x-ms-share-quota",
                type: {
                    name: "Number"
                }
            },
            provisionedIops: {
                serializedName: "x-ms-share-provisioned-iops",
                xmlName: "x-ms-share-provisioned-iops",
                type: {
                    name: "Number"
                }
            },
            provisionedIngressMBps: {
                serializedName: "x-ms-share-provisioned-ingress-mbps",
                xmlName: "x-ms-share-provisioned-ingress-mbps",
                type: {
                    name: "Number"
                }
            },
            provisionedEgressMBps: {
                serializedName: "x-ms-share-provisioned-egress-mbps",
                xmlName: "x-ms-share-provisioned-egress-mbps",
                type: {
                    name: "Number"
                }
            },
            nextAllowedQuotaDowngradeTime: {
                serializedName: "x-ms-share-next-allowed-quota-downgrade-time",
                xmlName: "x-ms-share-next-allowed-quota-downgrade-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseDuration: {
                serializedName: "x-ms-lease-duration",
                xmlName: "x-ms-lease-duration",
                type: {
                    name: "Enum",
                    allowedValues: ["infinite", "fixed"]
                }
            },
            leaseState: {
                serializedName: "x-ms-lease-state",
                xmlName: "x-ms-lease-state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "available",
                        "leased",
                        "expired",
                        "breaking",
                        "broken"
                    ]
                }
            },
            leaseStatus: {
                serializedName: "x-ms-lease-status",
                xmlName: "x-ms-lease-status",
                type: {
                    name: "Enum",
                    allowedValues: ["locked", "unlocked"]
                }
            },
            accessTier: {
                serializedName: "x-ms-access-tier",
                xmlName: "x-ms-access-tier",
                type: {
                    name: "String"
                }
            },
            accessTierChangeTime: {
                serializedName: "x-ms-access-tier-change-time",
                xmlName: "x-ms-access-tier-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            accessTierTransitionState: {
                serializedName: "x-ms-access-tier-transition-state",
                xmlName: "x-ms-access-tier-transition-state",
                type: {
                    name: "String"
                }
            },
            enabledProtocols: {
                serializedName: "x-ms-enabled-protocols",
                xmlName: "x-ms-enabled-protocols",
                type: {
                    name: "String"
                }
            },
            rootSquash: {
                serializedName: "x-ms-root-squash",
                xmlName: "x-ms-root-squash",
                type: {
                    name: "Enum",
                    allowedValues: ["NoRootSquash", "RootSquash", "AllSquash"]
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareGetPropertiesExceptionHeaders = {
    serializedName: "Share_getPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareDeleteHeaders = {
    serializedName: "Share_deleteHeaders",
    type: {
        name: "Composite",
        className: "ShareDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareDeleteExceptionHeaders = {
    serializedName: "Share_deleteExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareDeleteExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareAcquireLeaseHeaders = {
    serializedName: "Share_acquireLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareAcquireLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const ShareAcquireLeaseExceptionHeaders = {
    serializedName: "Share_acquireLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareAcquireLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareReleaseLeaseHeaders = {
    serializedName: "Share_releaseLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareReleaseLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const ShareReleaseLeaseExceptionHeaders = {
    serializedName: "Share_releaseLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareReleaseLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareChangeLeaseHeaders = {
    serializedName: "Share_changeLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareChangeLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const ShareChangeLeaseExceptionHeaders = {
    serializedName: "Share_changeLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareChangeLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareRenewLeaseHeaders = {
    serializedName: "Share_renewLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareRenewLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const ShareRenewLeaseExceptionHeaders = {
    serializedName: "Share_renewLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareRenewLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareBreakLeaseHeaders = {
    serializedName: "Share_breakLeaseHeaders",
    type: {
        name: "Composite",
        className: "ShareBreakLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseTimeInSeconds: {
                serializedName: "x-ms-lease-time",
                xmlName: "x-ms-lease-time",
                type: {
                    name: "Number"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const ShareBreakLeaseExceptionHeaders = {
    serializedName: "Share_breakLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareBreakLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareCreateSnapshotHeaders = {
    serializedName: "Share_createSnapshotHeaders",
    type: {
        name: "Composite",
        className: "ShareCreateSnapshotHeaders",
        modelProperties: {
            snapshot: {
                serializedName: "x-ms-snapshot",
                xmlName: "x-ms-snapshot",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareCreateSnapshotExceptionHeaders = {
    serializedName: "Share_createSnapshotExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareCreateSnapshotExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareCreatePermissionHeaders = {
    serializedName: "Share_createPermissionHeaders",
    type: {
        name: "Composite",
        className: "ShareCreatePermissionHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareCreatePermissionExceptionHeaders = {
    serializedName: "Share_createPermissionExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareCreatePermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareGetPermissionHeaders = {
    serializedName: "Share_getPermissionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetPermissionHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareGetPermissionExceptionHeaders = {
    serializedName: "Share_getPermissionExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetPermissionExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareSetPropertiesHeaders = {
    serializedName: "Share_setPropertiesHeaders",
    type: {
        name: "Composite",
        className: "ShareSetPropertiesHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareSetPropertiesExceptionHeaders = {
    serializedName: "Share_setPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareSetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareSetMetadataHeaders = {
    serializedName: "Share_setMetadataHeaders",
    type: {
        name: "Composite",
        className: "ShareSetMetadataHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareSetMetadataExceptionHeaders = {
    serializedName: "Share_setMetadataExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareSetMetadataExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareGetAccessPolicyHeaders = {
    serializedName: "Share_getAccessPolicyHeaders",
    type: {
        name: "Composite",
        className: "ShareGetAccessPolicyHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareGetAccessPolicyExceptionHeaders = {
    serializedName: "Share_getAccessPolicyExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetAccessPolicyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareSetAccessPolicyHeaders = {
    serializedName: "Share_setAccessPolicyHeaders",
    type: {
        name: "Composite",
        className: "ShareSetAccessPolicyHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareSetAccessPolicyExceptionHeaders = {
    serializedName: "Share_setAccessPolicyExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareSetAccessPolicyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareGetStatisticsHeaders = {
    serializedName: "Share_getStatisticsHeaders",
    type: {
        name: "Composite",
        className: "ShareGetStatisticsHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareGetStatisticsExceptionHeaders = {
    serializedName: "Share_getStatisticsExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareGetStatisticsExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareRestoreHeaders = {
    serializedName: "Share_restoreHeaders",
    type: {
        name: "Composite",
        className: "ShareRestoreHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const ShareRestoreExceptionHeaders = {
    serializedName: "Share_restoreExceptionHeaders",
    type: {
        name: "Composite",
        className: "ShareRestoreExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryCreateHeaders = {
    serializedName: "Directory_createHeaders",
    type: {
        name: "Composite",
        className: "DirectoryCreateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryCreateExceptionHeaders = {
    serializedName: "Directory_createExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryCreateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryGetPropertiesHeaders = {
    serializedName: "Directory_getPropertiesHeaders",
    type: {
        name: "Composite",
        className: "DirectoryGetPropertiesHeaders",
        modelProperties: {
            metadata: {
                serializedName: "x-ms-meta",
                xmlName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-server-encrypted",
                xmlName: "x-ms-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryGetPropertiesExceptionHeaders = {
    serializedName: "Directory_getPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryGetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryDeleteHeaders = {
    serializedName: "Directory_deleteHeaders",
    type: {
        name: "Composite",
        className: "DirectoryDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryDeleteExceptionHeaders = {
    serializedName: "Directory_deleteExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryDeleteExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectorySetPropertiesHeaders = {
    serializedName: "Directory_setPropertiesHeaders",
    type: {
        name: "Composite",
        className: "DirectorySetPropertiesHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectorySetPropertiesExceptionHeaders = {
    serializedName: "Directory_setPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectorySetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectorySetMetadataHeaders = {
    serializedName: "Directory_setMetadataHeaders",
    type: {
        name: "Composite",
        className: "DirectorySetMetadataHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectorySetMetadataExceptionHeaders = {
    serializedName: "Directory_setMetadataExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectorySetMetadataExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryListFilesAndDirectoriesSegmentHeaders = {
    serializedName: "Directory_listFilesAndDirectoriesSegmentHeaders",
    type: {
        name: "Composite",
        className: "DirectoryListFilesAndDirectoriesSegmentHeaders",
        modelProperties: {
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryListFilesAndDirectoriesSegmentExceptionHeaders = {
    serializedName: "Directory_listFilesAndDirectoriesSegmentExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryListFilesAndDirectoriesSegmentExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryListHandlesHeaders = {
    serializedName: "Directory_listHandlesHeaders",
    type: {
        name: "Composite",
        className: "DirectoryListHandlesHeaders",
        modelProperties: {
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryListHandlesExceptionHeaders = {
    serializedName: "Directory_listHandlesExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryListHandlesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryForceCloseHandlesHeaders = {
    serializedName: "Directory_forceCloseHandlesHeaders",
    type: {
        name: "Composite",
        className: "DirectoryForceCloseHandlesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            marker: {
                serializedName: "x-ms-marker",
                xmlName: "x-ms-marker",
                type: {
                    name: "String"
                }
            },
            numberOfHandlesClosed: {
                serializedName: "x-ms-number-of-handles-closed",
                xmlName: "x-ms-number-of-handles-closed",
                type: {
                    name: "Number"
                }
            },
            numberOfHandlesFailedToClose: {
                serializedName: "x-ms-number-of-handles-failed",
                xmlName: "x-ms-number-of-handles-failed",
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectoryForceCloseHandlesExceptionHeaders = {
    serializedName: "Directory_forceCloseHandlesExceptionHeaders",
    type: {
        name: "Composite",
        className: "DirectoryForceCloseHandlesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileCreateHeaders = {
    serializedName: "File_createHeaders",
    type: {
        name: "Composite",
        className: "FileCreateHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileCreateExceptionHeaders = {
    serializedName: "File_createExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileCreateExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileDownloadHeaders = {
    serializedName: "File_downloadHeaders",
    type: {
        name: "Composite",
        className: "FileDownloadHeaders",
        modelProperties: {
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            metadata: {
                serializedName: "x-ms-meta",
                xmlName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            contentLength: {
                serializedName: "content-length",
                xmlName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            contentRange: {
                serializedName: "content-range",
                xmlName: "content-range",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                xmlName: "content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            contentEncoding: {
                serializedName: "content-encoding",
                xmlName: "content-encoding",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "cache-control",
                xmlName: "cache-control",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "content-disposition",
                xmlName: "content-disposition",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "content-language",
                xmlName: "content-language",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            acceptRanges: {
                serializedName: "accept-ranges",
                xmlName: "accept-ranges",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyCompletedOn: {
                serializedName: "x-ms-copy-completion-time",
                xmlName: "x-ms-copy-completion-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyStatusDescription: {
                serializedName: "x-ms-copy-status-description",
                xmlName: "x-ms-copy-status-description",
                type: {
                    name: "String"
                }
            },
            copyId: {
                serializedName: "x-ms-copy-id",
                xmlName: "x-ms-copy-id",
                type: {
                    name: "String"
                }
            },
            copyProgress: {
                serializedName: "x-ms-copy-progress",
                xmlName: "x-ms-copy-progress",
                type: {
                    name: "String"
                }
            },
            copySource: {
                serializedName: "x-ms-copy-source",
                xmlName: "x-ms-copy-source",
                type: {
                    name: "String"
                }
            },
            copyStatus: {
                serializedName: "x-ms-copy-status",
                xmlName: "x-ms-copy-status",
                type: {
                    name: "Enum",
                    allowedValues: ["pending", "success", "aborted", "failed"]
                }
            },
            fileContentMD5: {
                serializedName: "x-ms-content-md5",
                xmlName: "x-ms-content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-server-encrypted",
                xmlName: "x-ms-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            leaseDuration: {
                serializedName: "x-ms-lease-duration",
                xmlName: "x-ms-lease-duration",
                type: {
                    name: "Enum",
                    allowedValues: ["infinite", "fixed"]
                }
            },
            leaseState: {
                serializedName: "x-ms-lease-state",
                xmlName: "x-ms-lease-state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "available",
                        "leased",
                        "expired",
                        "breaking",
                        "broken"
                    ]
                }
            },
            leaseStatus: {
                serializedName: "x-ms-lease-status",
                xmlName: "x-ms-lease-status",
                type: {
                    name: "Enum",
                    allowedValues: ["locked", "unlocked"]
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileDownloadExceptionHeaders = {
    serializedName: "File_downloadExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileDownloadExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileGetPropertiesHeaders = {
    serializedName: "File_getPropertiesHeaders",
    type: {
        name: "Composite",
        className: "FileGetPropertiesHeaders",
        modelProperties: {
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            metadata: {
                serializedName: "x-ms-meta",
                xmlName: "x-ms-meta",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                },
                headerCollectionPrefix: "x-ms-meta-"
            },
            fileType: {
                serializedName: "x-ms-type",
                xmlName: "x-ms-type",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                xmlName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                xmlName: "content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            contentEncoding: {
                serializedName: "content-encoding",
                xmlName: "content-encoding",
                type: {
                    name: "String"
                }
            },
            cacheControl: {
                serializedName: "cache-control",
                xmlName: "cache-control",
                type: {
                    name: "String"
                }
            },
            contentDisposition: {
                serializedName: "content-disposition",
                xmlName: "content-disposition",
                type: {
                    name: "String"
                }
            },
            contentLanguage: {
                serializedName: "content-language",
                xmlName: "content-language",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyCompletedOn: {
                serializedName: "x-ms-copy-completion-time",
                xmlName: "x-ms-copy-completion-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyStatusDescription: {
                serializedName: "x-ms-copy-status-description",
                xmlName: "x-ms-copy-status-description",
                type: {
                    name: "String"
                }
            },
            copyId: {
                serializedName: "x-ms-copy-id",
                xmlName: "x-ms-copy-id",
                type: {
                    name: "String"
                }
            },
            copyProgress: {
                serializedName: "x-ms-copy-progress",
                xmlName: "x-ms-copy-progress",
                type: {
                    name: "String"
                }
            },
            copySource: {
                serializedName: "x-ms-copy-source",
                xmlName: "x-ms-copy-source",
                type: {
                    name: "String"
                }
            },
            copyStatus: {
                serializedName: "x-ms-copy-status",
                xmlName: "x-ms-copy-status",
                type: {
                    name: "Enum",
                    allowedValues: ["pending", "success", "aborted", "failed"]
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-server-encrypted",
                xmlName: "x-ms-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            leaseDuration: {
                serializedName: "x-ms-lease-duration",
                xmlName: "x-ms-lease-duration",
                type: {
                    name: "Enum",
                    allowedValues: ["infinite", "fixed"]
                }
            },
            leaseState: {
                serializedName: "x-ms-lease-state",
                xmlName: "x-ms-lease-state",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "available",
                        "leased",
                        "expired",
                        "breaking",
                        "broken"
                    ]
                }
            },
            leaseStatus: {
                serializedName: "x-ms-lease-status",
                xmlName: "x-ms-lease-status",
                type: {
                    name: "Enum",
                    allowedValues: ["locked", "unlocked"]
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileGetPropertiesExceptionHeaders = {
    serializedName: "File_getPropertiesExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileGetPropertiesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileDeleteHeaders = {
    serializedName: "File_deleteHeaders",
    type: {
        name: "Composite",
        className: "FileDeleteHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileDeleteExceptionHeaders = {
    serializedName: "File_deleteExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileDeleteExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileSetHttpHeadersHeaders = {
    serializedName: "File_setHttpHeadersHeaders",
    type: {
        name: "Composite",
        className: "FileSetHttpHeadersHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            filePermissionKey: {
                serializedName: "x-ms-file-permission-key",
                xmlName: "x-ms-file-permission-key",
                type: {
                    name: "String"
                }
            },
            fileAttributes: {
                serializedName: "x-ms-file-attributes",
                xmlName: "x-ms-file-attributes",
                type: {
                    name: "String"
                }
            },
            fileCreatedOn: {
                serializedName: "x-ms-file-creation-time",
                xmlName: "x-ms-file-creation-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileLastWriteOn: {
                serializedName: "x-ms-file-last-write-time",
                xmlName: "x-ms-file-last-write-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileChangeOn: {
                serializedName: "x-ms-file-change-time",
                xmlName: "x-ms-file-change-time",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            fileId: {
                serializedName: "x-ms-file-id",
                xmlName: "x-ms-file-id",
                type: {
                    name: "String"
                }
            },
            fileParentId: {
                serializedName: "x-ms-file-parent-id",
                xmlName: "x-ms-file-parent-id",
                type: {
                    name: "String"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileSetHttpHeadersExceptionHeaders = {
    serializedName: "File_setHttpHeadersExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileSetHttpHeadersExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileSetMetadataHeaders = {
    serializedName: "File_setMetadataHeaders",
    type: {
        name: "Composite",
        className: "FileSetMetadataHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileSetMetadataExceptionHeaders = {
    serializedName: "File_setMetadataExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileSetMetadataExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileAcquireLeaseHeaders = {
    serializedName: "File_acquireLeaseHeaders",
    type: {
        name: "Composite",
        className: "FileAcquireLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const FileAcquireLeaseExceptionHeaders = {
    serializedName: "File_acquireLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileAcquireLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileReleaseLeaseHeaders = {
    serializedName: "File_releaseLeaseHeaders",
    type: {
        name: "Composite",
        className: "FileReleaseLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const FileReleaseLeaseExceptionHeaders = {
    serializedName: "File_releaseLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileReleaseLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileChangeLeaseHeaders = {
    serializedName: "File_changeLeaseHeaders",
    type: {
        name: "Composite",
        className: "FileChangeLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const FileChangeLeaseExceptionHeaders = {
    serializedName: "File_changeLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileChangeLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileBreakLeaseHeaders = {
    serializedName: "File_breakLeaseHeaders",
    type: {
        name: "Composite",
        className: "FileBreakLeaseHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            leaseId: {
                serializedName: "x-ms-lease-id",
                xmlName: "x-ms-lease-id",
                type: {
                    name: "String"
                }
            },
            clientRequestId: {
                serializedName: "x-ms-client-request-id",
                xmlName: "x-ms-client-request-id",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            }
        }
    }
};
const FileBreakLeaseExceptionHeaders = {
    serializedName: "File_breakLeaseExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileBreakLeaseExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileUploadRangeHeaders = {
    serializedName: "File_uploadRangeHeaders",
    type: {
        name: "Composite",
        className: "FileUploadRangeHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            contentMD5: {
                serializedName: "content-md5",
                xmlName: "content-md5",
                type: {
                    name: "ByteArray"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileUploadRangeExceptionHeaders = {
    serializedName: "File_uploadRangeExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileUploadRangeExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileUploadRangeFromURLHeaders = {
    serializedName: "File_uploadRangeFromURLHeaders",
    type: {
        name: "Composite",
        className: "FileUploadRangeFromURLHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            xMsContentCrc64: {
                serializedName: "x-ms-content-crc64",
                xmlName: "x-ms-content-crc64",
                type: {
                    name: "ByteArray"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            isServerEncrypted: {
                serializedName: "x-ms-request-server-encrypted",
                xmlName: "x-ms-request-server-encrypted",
                type: {
                    name: "Boolean"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileUploadRangeFromURLExceptionHeaders = {
    serializedName: "File_uploadRangeFromURLExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileUploadRangeFromURLExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileGetRangeListHeaders = {
    serializedName: "File_getRangeListHeaders",
    type: {
        name: "Composite",
        className: "FileGetRangeListHeaders",
        modelProperties: {
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            fileContentLength: {
                serializedName: "x-ms-content-length",
                xmlName: "x-ms-content-length",
                type: {
                    name: "Number"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileGetRangeListExceptionHeaders = {
    serializedName: "File_getRangeListExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileGetRangeListExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileStartCopyHeaders = {
    serializedName: "File_startCopyHeaders",
    type: {
        name: "Composite",
        className: "FileStartCopyHeaders",
        modelProperties: {
            etag: {
                serializedName: "etag",
                xmlName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                xmlName: "last-modified",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            copyId: {
                serializedName: "x-ms-copy-id",
                xmlName: "x-ms-copy-id",
                type: {
                    name: "String"
                }
            },
            copyStatus: {
                serializedName: "x-ms-copy-status",
                xmlName: "x-ms-copy-status",
                type: {
                    name: "Enum",
                    allowedValues: ["pending", "success", "aborted", "failed"]
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileStartCopyExceptionHeaders = {
    serializedName: "File_startCopyExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileStartCopyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileAbortCopyHeaders = {
    serializedName: "File_abortCopyHeaders",
    type: {
        name: "Composite",
        className: "FileAbortCopyHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileAbortCopyExceptionHeaders = {
    serializedName: "File_abortCopyExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileAbortCopyExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileListHandlesHeaders = {
    serializedName: "File_listHandlesHeaders",
    type: {
        name: "Composite",
        className: "FileListHandlesHeaders",
        modelProperties: {
            contentType: {
                serializedName: "content-type",
                xmlName: "content-type",
                type: {
                    name: "String"
                }
            },
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileListHandlesExceptionHeaders = {
    serializedName: "File_listHandlesExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileListHandlesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileForceCloseHandlesHeaders = {
    serializedName: "File_forceCloseHandlesHeaders",
    type: {
        name: "Composite",
        className: "FileForceCloseHandlesHeaders",
        modelProperties: {
            requestId: {
                serializedName: "x-ms-request-id",
                xmlName: "x-ms-request-id",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "x-ms-version",
                xmlName: "x-ms-version",
                type: {
                    name: "String"
                }
            },
            date: {
                serializedName: "date",
                xmlName: "date",
                type: {
                    name: "DateTimeRfc1123"
                }
            },
            marker: {
                serializedName: "x-ms-marker",
                xmlName: "x-ms-marker",
                type: {
                    name: "String"
                }
            },
            numberOfHandlesClosed: {
                serializedName: "x-ms-number-of-handles-closed",
                xmlName: "x-ms-number-of-handles-closed",
                type: {
                    name: "Number"
                }
            },
            numberOfHandlesFailedToClose: {
                serializedName: "x-ms-number-of-handles-failed",
                xmlName: "x-ms-number-of-handles-failed",
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileForceCloseHandlesExceptionHeaders = {
    serializedName: "File_forceCloseHandlesExceptionHeaders",
    type: {
        name: "Composite",
        className: "FileForceCloseHandlesExceptionHeaders",
        modelProperties: {
            errorCode: {
                serializedName: "x-ms-error-code",
                xmlName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    FileServiceProperties: FileServiceProperties,
    Metrics: Metrics,
    RetentionPolicy: RetentionPolicy,
    CorsRule: CorsRule,
    ShareProtocolSettings: ShareProtocolSettings,
    ShareSmbSettings: ShareSmbSettings,
    SmbMultichannel: SmbMultichannel,
    StorageError: StorageError,
    ListSharesResponse: ListSharesResponse,
    ShareItemInternal: ShareItemInternal,
    SharePropertiesInternal: SharePropertiesInternal,
    SharePermission: SharePermission,
    SignedIdentifier: SignedIdentifier,
    AccessPolicy: AccessPolicy,
    ShareStats: ShareStats,
    ListFilesAndDirectoriesSegmentResponse: ListFilesAndDirectoriesSegmentResponse,
    FilesAndDirectoriesListSegment: FilesAndDirectoriesListSegment,
    DirectoryItem: DirectoryItem,
    FileProperty: FileProperty,
    FileItem: FileItem,
    ListHandlesResponse: ListHandlesResponse,
    HandleItem: HandleItem,
    ShareFileRangeList: ShareFileRangeList,
    FileRange: FileRange,
    ClearRange: ClearRange,
    ServiceSetPropertiesHeaders: ServiceSetPropertiesHeaders,
    ServiceSetPropertiesExceptionHeaders: ServiceSetPropertiesExceptionHeaders,
    ServiceGetPropertiesHeaders: ServiceGetPropertiesHeaders,
    ServiceGetPropertiesExceptionHeaders: ServiceGetPropertiesExceptionHeaders,
    ServiceListSharesSegmentHeaders: ServiceListSharesSegmentHeaders,
    ServiceListSharesSegmentExceptionHeaders: ServiceListSharesSegmentExceptionHeaders,
    ShareCreateHeaders: ShareCreateHeaders,
    ShareCreateExceptionHeaders: ShareCreateExceptionHeaders,
    ShareGetPropertiesHeaders: ShareGetPropertiesHeaders,
    ShareGetPropertiesExceptionHeaders: ShareGetPropertiesExceptionHeaders,
    ShareDeleteHeaders: ShareDeleteHeaders,
    ShareDeleteExceptionHeaders: ShareDeleteExceptionHeaders,
    ShareAcquireLeaseHeaders: ShareAcquireLeaseHeaders,
    ShareAcquireLeaseExceptionHeaders: ShareAcquireLeaseExceptionHeaders,
    ShareReleaseLeaseHeaders: ShareReleaseLeaseHeaders,
    ShareReleaseLeaseExceptionHeaders: ShareReleaseLeaseExceptionHeaders,
    ShareChangeLeaseHeaders: ShareChangeLeaseHeaders,
    ShareChangeLeaseExceptionHeaders: ShareChangeLeaseExceptionHeaders,
    ShareRenewLeaseHeaders: ShareRenewLeaseHeaders,
    ShareRenewLeaseExceptionHeaders: ShareRenewLeaseExceptionHeaders,
    ShareBreakLeaseHeaders: ShareBreakLeaseHeaders,
    ShareBreakLeaseExceptionHeaders: ShareBreakLeaseExceptionHeaders,
    ShareCreateSnapshotHeaders: ShareCreateSnapshotHeaders,
    ShareCreateSnapshotExceptionHeaders: ShareCreateSnapshotExceptionHeaders,
    ShareCreatePermissionHeaders: ShareCreatePermissionHeaders,
    ShareCreatePermissionExceptionHeaders: ShareCreatePermissionExceptionHeaders,
    ShareGetPermissionHeaders: ShareGetPermissionHeaders,
    ShareGetPermissionExceptionHeaders: ShareGetPermissionExceptionHeaders,
    ShareSetPropertiesHeaders: ShareSetPropertiesHeaders,
    ShareSetPropertiesExceptionHeaders: ShareSetPropertiesExceptionHeaders,
    ShareSetMetadataHeaders: ShareSetMetadataHeaders,
    ShareSetMetadataExceptionHeaders: ShareSetMetadataExceptionHeaders,
    ShareGetAccessPolicyHeaders: ShareGetAccessPolicyHeaders,
    ShareGetAccessPolicyExceptionHeaders: ShareGetAccessPolicyExceptionHeaders,
    ShareSetAccessPolicyHeaders: ShareSetAccessPolicyHeaders,
    ShareSetAccessPolicyExceptionHeaders: ShareSetAccessPolicyExceptionHeaders,
    ShareGetStatisticsHeaders: ShareGetStatisticsHeaders,
    ShareGetStatisticsExceptionHeaders: ShareGetStatisticsExceptionHeaders,
    ShareRestoreHeaders: ShareRestoreHeaders,
    ShareRestoreExceptionHeaders: ShareRestoreExceptionHeaders,
    DirectoryCreateHeaders: DirectoryCreateHeaders,
    DirectoryCreateExceptionHeaders: DirectoryCreateExceptionHeaders,
    DirectoryGetPropertiesHeaders: DirectoryGetPropertiesHeaders,
    DirectoryGetPropertiesExceptionHeaders: DirectoryGetPropertiesExceptionHeaders,
    DirectoryDeleteHeaders: DirectoryDeleteHeaders,
    DirectoryDeleteExceptionHeaders: DirectoryDeleteExceptionHeaders,
    DirectorySetPropertiesHeaders: DirectorySetPropertiesHeaders,
    DirectorySetPropertiesExceptionHeaders: DirectorySetPropertiesExceptionHeaders,
    DirectorySetMetadataHeaders: DirectorySetMetadataHeaders,
    DirectorySetMetadataExceptionHeaders: DirectorySetMetadataExceptionHeaders,
    DirectoryListFilesAndDirectoriesSegmentHeaders: DirectoryListFilesAndDirectoriesSegmentHeaders,
    DirectoryListFilesAndDirectoriesSegmentExceptionHeaders: DirectoryListFilesAndDirectoriesSegmentExceptionHeaders,
    DirectoryListHandlesHeaders: DirectoryListHandlesHeaders,
    DirectoryListHandlesExceptionHeaders: DirectoryListHandlesExceptionHeaders,
    DirectoryForceCloseHandlesHeaders: DirectoryForceCloseHandlesHeaders,
    DirectoryForceCloseHandlesExceptionHeaders: DirectoryForceCloseHandlesExceptionHeaders,
    FileCreateHeaders: FileCreateHeaders,
    FileCreateExceptionHeaders: FileCreateExceptionHeaders,
    FileDownloadHeaders: FileDownloadHeaders,
    FileDownloadExceptionHeaders: FileDownloadExceptionHeaders,
    FileGetPropertiesHeaders: FileGetPropertiesHeaders,
    FileGetPropertiesExceptionHeaders: FileGetPropertiesExceptionHeaders,
    FileDeleteHeaders: FileDeleteHeaders,
    FileDeleteExceptionHeaders: FileDeleteExceptionHeaders,
    FileSetHttpHeadersHeaders: FileSetHttpHeadersHeaders,
    FileSetHttpHeadersExceptionHeaders: FileSetHttpHeadersExceptionHeaders,
    FileSetMetadataHeaders: FileSetMetadataHeaders,
    FileSetMetadataExceptionHeaders: FileSetMetadataExceptionHeaders,
    FileAcquireLeaseHeaders: FileAcquireLeaseHeaders,
    FileAcquireLeaseExceptionHeaders: FileAcquireLeaseExceptionHeaders,
    FileReleaseLeaseHeaders: FileReleaseLeaseHeaders,
    FileReleaseLeaseExceptionHeaders: FileReleaseLeaseExceptionHeaders,
    FileChangeLeaseHeaders: FileChangeLeaseHeaders,
    FileChangeLeaseExceptionHeaders: FileChangeLeaseExceptionHeaders,
    FileBreakLeaseHeaders: FileBreakLeaseHeaders,
    FileBreakLeaseExceptionHeaders: FileBreakLeaseExceptionHeaders,
    FileUploadRangeHeaders: FileUploadRangeHeaders,
    FileUploadRangeExceptionHeaders: FileUploadRangeExceptionHeaders,
    FileUploadRangeFromURLHeaders: FileUploadRangeFromURLHeaders,
    FileUploadRangeFromURLExceptionHeaders: FileUploadRangeFromURLExceptionHeaders,
    FileGetRangeListHeaders: FileGetRangeListHeaders,
    FileGetRangeListExceptionHeaders: FileGetRangeListExceptionHeaders,
    FileStartCopyHeaders: FileStartCopyHeaders,
    FileStartCopyExceptionHeaders: FileStartCopyExceptionHeaders,
    FileAbortCopyHeaders: FileAbortCopyHeaders,
    FileAbortCopyExceptionHeaders: FileAbortCopyExceptionHeaders,
    FileListHandlesHeaders: FileListHandlesHeaders,
    FileListHandlesExceptionHeaders: FileListHandlesExceptionHeaders,
    FileForceCloseHandlesHeaders: FileForceCloseHandlesHeaders,
    FileForceCloseHandlesExceptionHeaders: FileForceCloseHandlesExceptionHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const properties = {
    parameterPath: "properties",
    mapper: FileServiceProperties
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const url = {
    parameterPath: "url",
    mapper: {
        serializedName: "url",
        required: true,
        xmlName: "url",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const restype = {
    parameterPath: "restype",
    mapper: {
        defaultValue: "service",
        isConstant: true,
        serializedName: "restype",
        type: {
            name: "String"
        }
    }
};
const comp = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "properties",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const timeoutInSeconds = {
    parameterPath: ["options", "timeoutInSeconds"],
    mapper: {
        constraints: {
            InclusiveMinimum: 0
        },
        serializedName: "timeout",
        xmlName: "timeout",
        type: {
            name: "Number"
        }
    }
};
const version = {
    parameterPath: "version",
    mapper: {
        defaultValue: "2020-10-02",
        isConstant: true,
        serializedName: "x-ms-version",
        type: {
            name: "String"
        }
    }
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const comp1 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "list",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
        serializedName: "prefix",
        xmlName: "prefix",
        type: {
            name: "String"
        }
    }
};
const marker = {
    parameterPath: ["options", "marker"],
    mapper: {
        serializedName: "marker",
        xmlName: "marker",
        type: {
            name: "String"
        }
    }
};
const maxResults = {
    parameterPath: ["options", "maxResults"],
    mapper: {
        constraints: {
            InclusiveMinimum: 1
        },
        serializedName: "maxresults",
        xmlName: "maxresults",
        type: {
            name: "Number"
        }
    }
};
const include = {
    parameterPath: ["options", "include"],
    mapper: {
        serializedName: "include",
        xmlName: "include",
        xmlElementName: "ListSharesIncludeType",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Enum",
                    allowedValues: ["snapshots", "metadata", "deleted"]
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const restype1 = {
    parameterPath: "restype",
    mapper: {
        defaultValue: "share",
        isConstant: true,
        serializedName: "restype",
        type: {
            name: "String"
        }
    }
};
const metadata = {
    parameterPath: ["options", "metadata"],
    mapper: {
        serializedName: "x-ms-meta",
        xmlName: "x-ms-meta",
        type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
        },
        headerCollectionPrefix: "x-ms-meta-"
    }
};
const quota = {
    parameterPath: ["options", "quota"],
    mapper: {
        constraints: {
            InclusiveMinimum: 1
        },
        serializedName: "x-ms-share-quota",
        xmlName: "x-ms-share-quota",
        type: {
            name: "Number"
        }
    }
};
const accessTier = {
    parameterPath: ["options", "accessTier"],
    mapper: {
        serializedName: "x-ms-access-tier",
        xmlName: "x-ms-access-tier",
        type: {
            name: "Enum",
            allowedValues: ["TransactionOptimized", "Hot", "Cool"]
        }
    }
};
const enabledProtocols = {
    parameterPath: ["options", "enabledProtocols"],
    mapper: {
        serializedName: "x-ms-enabled-protocols",
        xmlName: "x-ms-enabled-protocols",
        type: {
            name: "String"
        }
    }
};
const rootSquash = {
    parameterPath: ["options", "rootSquash"],
    mapper: {
        serializedName: "x-ms-root-squash",
        xmlName: "x-ms-root-squash",
        type: {
            name: "Enum",
            allowedValues: ["NoRootSquash", "RootSquash", "AllSquash"]
        }
    }
};
const shareSnapshot = {
    parameterPath: ["options", "shareSnapshot"],
    mapper: {
        serializedName: "sharesnapshot",
        xmlName: "sharesnapshot",
        type: {
            name: "String"
        }
    }
};
const leaseId = {
    parameterPath: ["options", "leaseAccessConditions", "leaseId"],
    mapper: {
        serializedName: "x-ms-lease-id",
        xmlName: "x-ms-lease-id",
        type: {
            name: "String"
        }
    }
};
const deleteSnapshots = {
    parameterPath: ["options", "deleteSnapshots"],
    mapper: {
        serializedName: "x-ms-delete-snapshots",
        xmlName: "x-ms-delete-snapshots",
        type: {
            name: "Enum",
            allowedValues: ["include", "include-leased"]
        }
    }
};
const comp2 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "lease",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const action = {
    parameterPath: "action",
    mapper: {
        defaultValue: "acquire",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
const duration = {
    parameterPath: ["options", "duration"],
    mapper: {
        serializedName: "x-ms-lease-duration",
        xmlName: "x-ms-lease-duration",
        type: {
            name: "Number"
        }
    }
};
const proposedLeaseId = {
    parameterPath: ["options", "proposedLeaseId"],
    mapper: {
        serializedName: "x-ms-proposed-lease-id",
        xmlName: "x-ms-proposed-lease-id",
        type: {
            name: "String"
        }
    }
};
const requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
        serializedName: "x-ms-client-request-id",
        xmlName: "x-ms-client-request-id",
        type: {
            name: "String"
        }
    }
};
const action1 = {
    parameterPath: "action",
    mapper: {
        defaultValue: "release",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
const leaseId1 = {
    parameterPath: "leaseId",
    mapper: {
        serializedName: "x-ms-lease-id",
        required: true,
        xmlName: "x-ms-lease-id",
        type: {
            name: "String"
        }
    }
};
const action2 = {
    parameterPath: "action",
    mapper: {
        defaultValue: "change",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
const action3 = {
    parameterPath: "action",
    mapper: {
        defaultValue: "renew",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
const action4 = {
    parameterPath: "action",
    mapper: {
        defaultValue: "break",
        isConstant: true,
        serializedName: "x-ms-lease-action",
        type: {
            name: "String"
        }
    }
};
const breakPeriod = {
    parameterPath: ["options", "breakPeriod"],
    mapper: {
        serializedName: "x-ms-lease-break-period",
        xmlName: "x-ms-lease-break-period",
        type: {
            name: "Number"
        }
    }
};
const comp3 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "snapshot",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const sharePermission = {
    parameterPath: "sharePermission",
    mapper: SharePermission
};
const comp4 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "filepermission",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const filePermissionKey = {
    parameterPath: "filePermissionKey",
    mapper: {
        serializedName: "x-ms-file-permission-key",
        required: true,
        xmlName: "x-ms-file-permission-key",
        type: {
            name: "String"
        }
    }
};
const comp5 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "metadata",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const comp6 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "acl",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const shareAcl = {
    parameterPath: ["options", "shareAcl"],
    mapper: {
        serializedName: "shareAcl",
        xmlName: "SignedIdentifiers",
        xmlIsWrapped: true,
        xmlElementName: "SignedIdentifier",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Composite",
                    className: "SignedIdentifier"
                }
            }
        }
    }
};
const comp7 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "stats",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const comp8 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "undelete",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const deletedShareName = {
    parameterPath: ["options", "deletedShareName"],
    mapper: {
        serializedName: "x-ms-deleted-share-name",
        xmlName: "x-ms-deleted-share-name",
        type: {
            name: "String"
        }
    }
};
const deletedShareVersion = {
    parameterPath: ["options", "deletedShareVersion"],
    mapper: {
        serializedName: "x-ms-deleted-share-version",
        xmlName: "x-ms-deleted-share-version",
        type: {
            name: "String"
        }
    }
};
const restype2 = {
    parameterPath: "restype",
    mapper: {
        defaultValue: "directory",
        isConstant: true,
        serializedName: "restype",
        type: {
            name: "String"
        }
    }
};
const filePermission = {
    parameterPath: ["options", "filePermission"],
    mapper: {
        serializedName: "x-ms-file-permission",
        xmlName: "x-ms-file-permission",
        type: {
            name: "String"
        }
    }
};
const filePermissionKey1 = {
    parameterPath: ["options", "filePermissionKey"],
    mapper: {
        serializedName: "x-ms-file-permission-key",
        xmlName: "x-ms-file-permission-key",
        type: {
            name: "String"
        }
    }
};
const fileAttributes = {
    parameterPath: "fileAttributes",
    mapper: {
        serializedName: "x-ms-file-attributes",
        required: true,
        xmlName: "x-ms-file-attributes",
        type: {
            name: "String"
        }
    }
};
const fileCreatedOn = {
    parameterPath: "fileCreatedOn",
    mapper: {
        serializedName: "x-ms-file-creation-time",
        required: true,
        xmlName: "x-ms-file-creation-time",
        type: {
            name: "String"
        }
    }
};
const fileLastWriteOn = {
    parameterPath: "fileLastWriteOn",
    mapper: {
        serializedName: "x-ms-file-last-write-time",
        required: true,
        xmlName: "x-ms-file-last-write-time",
        type: {
            name: "String"
        }
    }
};
const include1 = {
    parameterPath: ["options", "include"],
    mapper: {
        serializedName: "include",
        xmlName: "include",
        xmlElementName: "ListFilesIncludeType",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Enum",
                    allowedValues: ["Timestamps", "Etag", "Attributes", "PermissionKey"]
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const includeExtendedInfo = {
    parameterPath: ["options", "includeExtendedInfo"],
    mapper: {
        serializedName: "x-ms-file-extended-info",
        xmlName: "x-ms-file-extended-info",
        type: {
            name: "Boolean"
        }
    }
};
const comp9 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "listhandles",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const recursive = {
    parameterPath: ["options", "recursive"],
    mapper: {
        serializedName: "x-ms-recursive",
        xmlName: "x-ms-recursive",
        type: {
            name: "Boolean"
        }
    }
};
const comp10 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "forceclosehandles",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const handleId = {
    parameterPath: "handleId",
    mapper: {
        serializedName: "x-ms-handle-id",
        required: true,
        xmlName: "x-ms-handle-id",
        type: {
            name: "String"
        }
    }
};
const fileContentLength = {
    parameterPath: "fileContentLength",
    mapper: {
        serializedName: "x-ms-content-length",
        required: true,
        xmlName: "x-ms-content-length",
        type: {
            name: "Number"
        }
    }
};
const fileTypeConstant = {
    parameterPath: "fileTypeConstant",
    mapper: {
        defaultValue: "file",
        isConstant: true,
        serializedName: "x-ms-type",
        type: {
            name: "String"
        }
    }
};
const fileContentType = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentType"],
    mapper: {
        serializedName: "x-ms-content-type",
        xmlName: "x-ms-content-type",
        type: {
            name: "String"
        }
    }
};
const fileContentEncoding = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentEncoding"],
    mapper: {
        serializedName: "x-ms-content-encoding",
        xmlName: "x-ms-content-encoding",
        type: {
            name: "String"
        }
    }
};
const fileContentLanguage = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentLanguage"],
    mapper: {
        serializedName: "x-ms-content-language",
        xmlName: "x-ms-content-language",
        type: {
            name: "String"
        }
    }
};
const fileCacheControl = {
    parameterPath: ["options", "fileHttpHeaders", "fileCacheControl"],
    mapper: {
        serializedName: "x-ms-cache-control",
        xmlName: "x-ms-cache-control",
        type: {
            name: "String"
        }
    }
};
const fileContentMD5 = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentMD5"],
    mapper: {
        serializedName: "x-ms-content-md5",
        xmlName: "x-ms-content-md5",
        type: {
            name: "ByteArray"
        }
    }
};
const fileContentDisposition = {
    parameterPath: ["options", "fileHttpHeaders", "fileContentDisposition"],
    mapper: {
        serializedName: "x-ms-content-disposition",
        xmlName: "x-ms-content-disposition",
        type: {
            name: "String"
        }
    }
};
const range = {
    parameterPath: ["options", "range"],
    mapper: {
        serializedName: "x-ms-range",
        xmlName: "x-ms-range",
        type: {
            name: "String"
        }
    }
};
const rangeGetContentMD5 = {
    parameterPath: ["options", "rangeGetContentMD5"],
    mapper: {
        serializedName: "x-ms-range-get-content-md5",
        xmlName: "x-ms-range-get-content-md5",
        type: {
            name: "Boolean"
        }
    }
};
const fileContentLength1 = {
    parameterPath: ["options", "fileContentLength"],
    mapper: {
        serializedName: "x-ms-content-length",
        xmlName: "x-ms-content-length",
        type: {
            name: "Number"
        }
    }
};
const contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: ["options", "body"],
    mapper: {
        serializedName: "body",
        xmlName: "body",
        type: {
            name: "Stream"
        }
    }
};
const accept3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/xml",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const comp11 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "range",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const range1 = {
    parameterPath: "range",
    mapper: {
        serializedName: "x-ms-range",
        required: true,
        xmlName: "x-ms-range",
        type: {
            name: "String"
        }
    }
};
const fileRangeWrite = {
    parameterPath: "fileRangeWrite",
    mapper: {
        defaultValue: "update",
        serializedName: "x-ms-write",
        required: true,
        xmlName: "x-ms-write",
        type: {
            name: "Enum",
            allowedValues: ["update", "clear"]
        }
    }
};
const contentLength = {
    parameterPath: "contentLength",
    mapper: {
        serializedName: "Content-Length",
        required: true,
        xmlName: "Content-Length",
        type: {
            name: "Number"
        }
    }
};
const contentMD5 = {
    parameterPath: ["options", "contentMD5"],
    mapper: {
        serializedName: "Content-MD5",
        xmlName: "Content-MD5",
        type: {
            name: "ByteArray"
        }
    }
};
const copySource = {
    parameterPath: "copySource",
    mapper: {
        serializedName: "x-ms-copy-source",
        required: true,
        xmlName: "x-ms-copy-source",
        type: {
            name: "String"
        }
    }
};
const sourceRange = {
    parameterPath: ["options", "sourceRange"],
    mapper: {
        serializedName: "x-ms-source-range",
        xmlName: "x-ms-source-range",
        type: {
            name: "String"
        }
    }
};
const fileRangeWriteFromUrl = {
    parameterPath: "fileRangeWriteFromUrl",
    mapper: {
        defaultValue: "update",
        isConstant: true,
        serializedName: "x-ms-write",
        type: {
            name: "String"
        }
    }
};
const sourceContentCrc64 = {
    parameterPath: ["options", "sourceContentCrc64"],
    mapper: {
        serializedName: "x-ms-source-content-crc64",
        xmlName: "x-ms-source-content-crc64",
        type: {
            name: "ByteArray"
        }
    }
};
const sourceIfMatchCrc64 = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfMatchCrc64"
    ],
    mapper: {
        serializedName: "x-ms-source-if-match-crc64",
        xmlName: "x-ms-source-if-match-crc64",
        type: {
            name: "ByteArray"
        }
    }
};
const sourceIfNoneMatchCrc64 = {
    parameterPath: [
        "options",
        "sourceModifiedAccessConditions",
        "sourceIfNoneMatchCrc64"
    ],
    mapper: {
        serializedName: "x-ms-source-if-none-match-crc64",
        xmlName: "x-ms-source-if-none-match-crc64",
        type: {
            name: "ByteArray"
        }
    }
};
const copySourceAuthorization = {
    parameterPath: ["options", "copySourceAuthorization"],
    mapper: {
        serializedName: "x-ms-copy-source-authorization",
        xmlName: "x-ms-copy-source-authorization",
        type: {
            name: "String"
        }
    }
};
const comp12 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "rangelist",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const prevsharesnapshot = {
    parameterPath: ["options", "prevsharesnapshot"],
    mapper: {
        serializedName: "prevsharesnapshot",
        xmlName: "prevsharesnapshot",
        type: {
            name: "String"
        }
    }
};
const filePermissionCopyMode = {
    parameterPath: ["options", "copyFileSmbInfo", "filePermissionCopyMode"],
    mapper: {
        serializedName: "x-ms-file-permission-copy-mode",
        xmlName: "x-ms-file-permission-copy-mode",
        type: {
            name: "Enum",
            allowedValues: ["source", "override"]
        }
    }
};
const ignoreReadOnly = {
    parameterPath: ["options", "copyFileSmbInfo", "ignoreReadOnly"],
    mapper: {
        serializedName: "x-ms-file-copy-ignore-read-only",
        xmlName: "x-ms-file-copy-ignore-read-only",
        type: {
            name: "Boolean"
        }
    }
};
const fileAttributes1 = {
    parameterPath: ["options", "copyFileSmbInfo", "fileAttributes"],
    mapper: {
        serializedName: "x-ms-file-attributes",
        xmlName: "x-ms-file-attributes",
        type: {
            name: "String"
        }
    }
};
const fileCreationTime = {
    parameterPath: ["options", "copyFileSmbInfo", "fileCreationTime"],
    mapper: {
        serializedName: "x-ms-file-creation-time",
        xmlName: "x-ms-file-creation-time",
        type: {
            name: "String"
        }
    }
};
const fileLastWriteTime = {
    parameterPath: ["options", "copyFileSmbInfo", "fileLastWriteTime"],
    mapper: {
        serializedName: "x-ms-file-last-write-time",
        xmlName: "x-ms-file-last-write-time",
        type: {
            name: "String"
        }
    }
};
const setArchiveAttribute = {
    parameterPath: ["options", "copyFileSmbInfo", "setArchiveAttribute"],
    mapper: {
        serializedName: "x-ms-file-copy-set-archive",
        xmlName: "x-ms-file-copy-set-archive",
        type: {
            name: "Boolean"
        }
    }
};
const comp13 = {
    parameterPath: "comp",
    mapper: {
        defaultValue: "copy",
        isConstant: true,
        serializedName: "comp",
        type: {
            name: "String"
        }
    }
};
const copyId = {
    parameterPath: "copyId",
    mapper: {
        serializedName: "copyid",
        required: true,
        xmlName: "copyid",
        type: {
            name: "String"
        }
    }
};
const copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
        defaultValue: "abort",
        isConstant: true,
        serializedName: "x-ms-copy-action",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Service. */
class Service {
    /**
     * Initialize a new instance of the class Service class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Sets properties for a storage account's File service endpoint, including properties for Storage
     * Analytics metrics and CORS (Cross-Origin Resource Sharing) rules.
     * @param properties The StorageService properties.
     * @param options The options parameters.
     */
    setProperties(properties, options) {
        const operationArguments = {
            properties,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setPropertiesOperationSpec);
    }
    /**
     * Gets the properties of a storage account's File service, including properties for Storage Analytics
     * metrics and CORS (Cross-Origin Resource Sharing) rules.
     * @param options The options parameters.
     */
    getProperties(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec);
    }
    /**
     * The List Shares Segment operation returns a list of the shares and share snapshots under the
     * specified account.
     * @param options The options parameters.
     */
    listSharesSegment(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listSharesSegmentOperationSpec);
    }
}
// Operation Specifications
const xmlSerializer = new coreHttp.Serializer(Mappers, /* isXml */ true);
const setPropertiesOperationSpec = {
    path: "/",
    httpMethod: "PUT",
    responses: {
        202: {
            headersMapper: ServiceSetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ServiceSetPropertiesExceptionHeaders
        }
    },
    requestBody: properties,
    queryParameters: [
        restype,
        comp,
        timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [
        contentType,
        accept,
        version
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
};
const getPropertiesOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FileServiceProperties,
            headersMapper: ServiceGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ServiceGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        restype,
        comp,
        timeoutInSeconds
    ],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer
};
const listSharesSegmentOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListSharesResponse,
            headersMapper: ServiceListSharesSegmentHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ServiceListSharesSegmentExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        comp1,
        prefix,
        marker,
        maxResults,
        include
    ],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Share. */
class Share {
    /**
     * Initialize a new instance of the class Share class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new share under the specified account. If the share with the same name already exists, the
     * operation fails.
     * @param options The options parameters.
     */
    create(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec);
    }
    /**
     * Returns all user-defined metadata and system properties for the specified share or share snapshot.
     * The data returned does not include the share's list of files.
     * @param options The options parameters.
     */
    getProperties(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec$1);
    }
    /**
     * Operation marks the specified share or share snapshot for deletion. The share or share snapshot and
     * any files contained within it are later deleted during garbage collection.
     * @param options The options parameters.
     */
    delete(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec);
    }
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param options The options parameters.
     */
    acquireLease(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, acquireLeaseOperationSpec);
    }
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    releaseLease(leaseId, options) {
        const operationArguments = {
            leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, releaseLeaseOperationSpec);
    }
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    changeLease(leaseId, options) {
        const operationArguments = {
            leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, changeLeaseOperationSpec);
    }
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    renewLease(leaseId, options) {
        const operationArguments = {
            leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, renewLeaseOperationSpec);
    }
    /**
     * The Lease Share operation establishes and manages a lock on a share, or the specified snapshot for
     * set and delete share operations.
     * @param options The options parameters.
     */
    breakLease(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, breakLeaseOperationSpec);
    }
    /**
     * Creates a read-only snapshot of a share.
     * @param options The options parameters.
     */
    createSnapshot(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createSnapshotOperationSpec);
    }
    /**
     * Create a permission (a security descriptor).
     * @param sharePermission A permission (a security descriptor) at the share level.
     * @param options The options parameters.
     */
    createPermission(sharePermission, options) {
        const operationArguments = {
            sharePermission,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createPermissionOperationSpec);
    }
    /**
     * Returns the permission (security descriptor) for a given key
     * @param filePermissionKey Key of the permission to be set for the directory/file.
     * @param options The options parameters.
     */
    getPermission(filePermissionKey, options) {
        const operationArguments = {
            filePermissionKey,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPermissionOperationSpec);
    }
    /**
     * Sets properties for the specified share.
     * @param options The options parameters.
     */
    setProperties(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setPropertiesOperationSpec$1);
    }
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     * @param options The options parameters.
     */
    setMetadata(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setMetadataOperationSpec);
    }
    /**
     * Returns information about stored access policies specified on the share.
     * @param options The options parameters.
     */
    getAccessPolicy(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getAccessPolicyOperationSpec);
    }
    /**
     * Sets a stored access policy for use with shared access signatures.
     * @param options The options parameters.
     */
    setAccessPolicy(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setAccessPolicyOperationSpec);
    }
    /**
     * Retrieves statistics related to the share.
     * @param options The options parameters.
     */
    getStatistics(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getStatisticsOperationSpec);
    }
    /**
     * Restores a previously deleted Share.
     * @param options The options parameters.
     */
    restore(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, restoreOperationSpec);
    }
}
// Operation Specifications
const xmlSerializer$1 = new coreHttp.Serializer(Mappers, /* isXml */ true);
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareCreateExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, restype1],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        quota,
        accessTier,
        enabledProtocols,
        rootSquash
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const getPropertiesOperationSpec$1 = {
    path: "/{shareName}",
    httpMethod: "GET",
    responses: {
        200: {
            headersMapper: ShareGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const deleteOperationSpec = {
    path: "/{shareName}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: ShareDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareDeleteExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        deleteSnapshots
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const acquireLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareAcquireLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareAcquireLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        action,
        duration,
        proposedLeaseId,
        requestId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const releaseLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareReleaseLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareReleaseLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        requestId,
        action1,
        leaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const changeLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareChangeLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareChangeLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        proposedLeaseId,
        requestId,
        leaseId1,
        action2
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const renewLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareRenewLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareRenewLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        requestId,
        leaseId1,
        action3
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const breakLeaseOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        202: {
            headersMapper: ShareBreakLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareBreakLeaseExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        shareSnapshot,
        comp2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        requestId,
        action4,
        breakPeriod
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const createSnapshotOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareCreateSnapshotHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareCreateSnapshotExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp3
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const createPermissionOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareCreatePermissionHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareCreatePermissionExceptionHeaders
        }
    },
    requestBody: sharePermission,
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp4
    ],
    urlParameters: [url],
    headerParameters: [
        contentType,
        accept,
        version
    ],
    isXML: false,
    contentType: "application/xml; charset=utf-8",
    serializer: xmlSerializer$1
};
const getPermissionOperationSpec = {
    path: "/{shareName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharePermission,
            headersMapper: ShareGetPermissionHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetPermissionExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp4
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept2,
        filePermissionKey
    ],
    serializer
};
const setPropertiesOperationSpec$1 = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareSetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareSetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        comp,
        timeoutInSeconds,
        restype1
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        quota,
        accessTier,
        rootSquash,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const setMetadataOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareSetMetadataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareSetMetadataExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp5
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const getAccessPolicyOperationSpec = {
    path: "/{shareName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: { name: "Composite", className: "SignedIdentifier" }
                    }
                },
                serializedName: "SignedIdentifiers",
                xmlName: "SignedIdentifiers",
                xmlIsWrapped: true,
                xmlElementName: "SignedIdentifier"
            },
            headersMapper: ShareGetAccessPolicyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetAccessPolicyExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp6
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const setAccessPolicyOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: ShareSetAccessPolicyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareSetAccessPolicyExceptionHeaders
        }
    },
    requestBody: shareAcl,
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp6
    ],
    urlParameters: [url],
    headerParameters: [
        contentType,
        accept,
        version,
        leaseId
    ],
    isXML: true,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer$1
};
const getStatisticsOperationSpec = {
    path: "/{shareName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ShareStats,
            headersMapper: ShareGetStatisticsHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareGetStatisticsExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp7
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$1
};
const restoreOperationSpec = {
    path: "/{shareName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ShareRestoreHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: ShareRestoreExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        restype1,
        comp8
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        requestId,
        deletedShareName,
        deletedShareVersion
    ],
    isXML: true,
    serializer: xmlSerializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Directory. */
class Directory {
    /**
     * Initialize a new instance of the class Directory class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new directory under the specified share or parent directory.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    create(fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        const operationArguments = {
            fileAttributes,
            fileCreatedOn,
            fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec$1);
    }
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @param options The options parameters.
     */
    getProperties(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec$2);
    }
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @param options The options parameters.
     */
    delete(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec$1);
    }
    /**
     * Sets properties on the directory.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    setProperties(fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        const operationArguments = {
            fileAttributes,
            fileCreatedOn,
            fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setPropertiesOperationSpec$2);
    }
    /**
     * Updates user defined metadata for the specified directory.
     * @param options The options parameters.
     */
    setMetadata(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setMetadataOperationSpec$1);
    }
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the contents
     * only for a single level of the directory hierarchy.
     * @param options The options parameters.
     */
    listFilesAndDirectoriesSegment(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listFilesAndDirectoriesSegmentOperationSpec);
    }
    /**
     * Lists handles for directory.
     * @param options The options parameters.
     */
    listHandles(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listHandlesOperationSpec);
    }
    /**
     * Closes all handles open for given directory.
     * @param handleId Specifies handle ID opened on the file or directory to be closed. Asterisk (‘*’) is
     *                 a wildcard that specifies all handles.
     * @param options The options parameters.
     */
    forceCloseHandles(handleId, options) {
        const operationArguments = {
            handleId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, forceCloseHandlesOperationSpec);
    }
}
// Operation Specifications
const xmlSerializer$2 = new coreHttp.Serializer(Mappers, /* isXml */ true);
const createOperationSpec$1 = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: DirectoryCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryCreateExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn
    ],
    isXML: true,
    serializer: xmlSerializer$2
};
const getPropertiesOperationSpec$2 = {
    path: "/{shareName}/{directory}",
    httpMethod: "GET",
    responses: {
        200: {
            headersMapper: DirectoryGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        shareSnapshot,
        restype2
    ],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer$2
};
const deleteOperationSpec$1 = {
    path: "/{shareName}/{directory}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: DirectoryDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryDeleteExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, restype2],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer$2
};
const setPropertiesOperationSpec$2 = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: DirectorySetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectorySetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        comp,
        timeoutInSeconds,
        restype2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn
    ],
    isXML: true,
    serializer: xmlSerializer$2
};
const setMetadataOperationSpec$1 = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: DirectorySetMetadataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectorySetMetadataExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        comp5,
        restype2
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata
    ],
    isXML: true,
    serializer: xmlSerializer$2
};
const listFilesAndDirectoriesSegmentOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListFilesAndDirectoriesSegmentResponse,
            headersMapper: DirectoryListFilesAndDirectoriesSegmentHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryListFilesAndDirectoriesSegmentExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        comp1,
        prefix,
        marker,
        maxResults,
        shareSnapshot,
        restype2,
        include1
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        includeExtendedInfo
    ],
    isXML: true,
    serializer: xmlSerializer$2
};
const listHandlesOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHandlesResponse,
            headersMapper: DirectoryListHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryListHandlesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        marker,
        maxResults,
        shareSnapshot,
        comp9
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        recursive
    ],
    isXML: true,
    serializer: xmlSerializer$2
};
const forceCloseHandlesOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: DirectoryForceCloseHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: DirectoryForceCloseHandlesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        marker,
        shareSnapshot,
        comp10
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        recursive,
        handleId
    ],
    isXML: true,
    serializer: xmlSerializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a File. */
class File {
    /**
     * Initialize a new instance of the class File class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @param fileContentLength Specifies the maximum size for the file, up to 4 TB.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    create(fileContentLength, fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        const operationArguments = {
            fileContentLength,
            fileAttributes,
            fileCreatedOn,
            fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec$2);
    }
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     * @param options The options parameters.
     */
    download(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, downloadOperationSpec);
    }
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties for the file. It
     * does not return the content of the file.
     * @param options The options parameters.
     */
    getProperties(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec$3);
    }
    /**
     * removes the file from the storage account.
     * @param options The options parameters.
     */
    delete(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec$2);
    }
    /**
     * Sets HTTP headers on the file.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    setHttpHeaders(fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        const operationArguments = {
            fileAttributes,
            fileCreatedOn,
            fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setHttpHeadersOperationSpec);
    }
    /**
     * Updates user-defined metadata for the specified file.
     * @param options The options parameters.
     */
    setMetadata(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setMetadataOperationSpec$2);
    }
    /**
     * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
     * operations
     * @param options The options parameters.
     */
    acquireLease(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, acquireLeaseOperationSpec$1);
    }
    /**
     * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
     * operations
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    releaseLease(leaseId, options) {
        const operationArguments = {
            leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, releaseLeaseOperationSpec$1);
    }
    /**
     * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
     * operations
     * @param leaseId Specifies the current lease ID on the resource.
     * @param options The options parameters.
     */
    changeLease(leaseId, options) {
        const operationArguments = {
            leaseId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, changeLeaseOperationSpec$1);
    }
    /**
     * [Update] The Lease File operation establishes and manages a lock on a file for write and delete
     * operations
     * @param options The options parameters.
     */
    breakLease(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, breakLeaseOperationSpec$1);
    }
    /**
     * Upload a range of bytes to a file.
     * @param range Specifies the range of bytes to be written. Both the start and end of the range must be
     *              specified. For an update operation, the range can be up to 4 MB in size. For a clear operation, the
     *              range can be up to the value of the file's full size. The File service accepts only a single byte
     *              range for the Range and 'x-ms-range' headers, and the byte range must be specified in the following
     *              format: bytes=startByte-endByte.
     * @param fileRangeWrite Specify one of the following options: - Update: Writes the bytes specified by
     *                       the request body into the specified range. The Range and Content-Length headers must match to
     *                       perform the update. - Clear: Clears the specified range and releases the space used in storage for
     *                       that range. To clear a range, set the Content-Length header to zero, and set the Range header to a
     *                       value that indicates the range to clear, up to maximum file size.
     * @param contentLength Specifies the number of bytes being transmitted in the request body. When the
     *                      x-ms-write header is set to clear, the value of this header must be set to zero.
     * @param options The options parameters.
     */
    uploadRange(range, fileRangeWrite, contentLength, options) {
        const operationArguments = {
            range,
            fileRangeWrite,
            contentLength,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, uploadRangeOperationSpec);
    }
    /**
     * Upload a range of bytes to a file where the contents are read from a URL.
     * @param range Writes data to the specified byte range in the file.
     * @param copySource Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file
     *                   to another file within the same storage account, you may use Shared Key to authenticate the source
     *                   file. If you are copying a file from another storage account, or if you are copying a blob from the
     *                   same storage account or another storage account, then you must authenticate the source file or blob
     *                   using a shared access signature. If the source is a public blob, no authentication is required to
     *                   perform the copy operation. A file in a share snapshot can also be specified as a copy source.
     * @param contentLength Specifies the number of bytes being transmitted in the request body. When the
     *                      x-ms-write header is set to clear, the value of this header must be set to zero.
     * @param options The options parameters.
     */
    uploadRangeFromURL(range, copySource, contentLength, options) {
        const operationArguments = {
            range,
            copySource,
            contentLength,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, uploadRangeFromURLOperationSpec);
    }
    /**
     * Returns the list of valid ranges for a file.
     * @param options The options parameters.
     */
    getRangeList(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getRangeListOperationSpec);
    }
    /**
     * Copies a blob or file to a destination file within the storage account.
     * @param copySource Specifies the URL of the source file or blob, up to 2 KB in length. To copy a file
     *                   to another file within the same storage account, you may use Shared Key to authenticate the source
     *                   file. If you are copying a file from another storage account, or if you are copying a blob from the
     *                   same storage account or another storage account, then you must authenticate the source file or blob
     *                   using a shared access signature. If the source is a public blob, no authentication is required to
     *                   perform the copy operation. A file in a share snapshot can also be specified as a copy source.
     * @param options The options parameters.
     */
    startCopy(copySource, options) {
        const operationArguments = {
            copySource,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, startCopyOperationSpec);
    }
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @param copyId The copy identifier provided in the x-ms-copy-id header of the original Copy File
     *               operation.
     * @param options The options parameters.
     */
    abortCopy(copyId, options) {
        const operationArguments = {
            copyId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, abortCopyOperationSpec);
    }
    /**
     * Lists handles for file
     * @param options The options parameters.
     */
    listHandles(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listHandlesOperationSpec$1);
    }
    /**
     * Closes all handles open for given file
     * @param handleId Specifies handle ID opened on the file or directory to be closed. Asterisk (‘*’) is
     *                 a wildcard that specifies all handles.
     * @param options The options parameters.
     */
    forceCloseHandles(handleId, options) {
        const operationArguments = {
            handleId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, forceCloseHandlesOperationSpec$1);
    }
}
// Operation Specifications
const xmlSerializer$3 = new coreHttp.Serializer(Mappers, /* isXml */ true);
const createOperationSpec$2 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: FileCreateHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileCreateExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        leaseId,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn,
        fileContentLength,
        fileTypeConstant,
        fileContentType,
        fileContentEncoding,
        fileContentLanguage,
        fileCacheControl,
        fileContentMD5,
        fileContentDisposition
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const downloadOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: FileDownloadHeaders
        },
        206: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: FileDownloadHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileDownloadExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        range,
        rangeGetContentMD5
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const getPropertiesOperationSpec$3 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: FileGetPropertiesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, shareSnapshot],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const deleteOperationSpec$2 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: FileDeleteHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileDeleteExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const setHttpHeadersOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileSetHttpHeadersHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSetHttpHeadersExceptionHeaders
        }
    },
    queryParameters: [comp, timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        filePermission,
        filePermissionKey1,
        fileAttributes,
        fileCreatedOn,
        fileLastWriteOn,
        fileContentType,
        fileContentEncoding,
        fileContentLanguage,
        fileCacheControl,
        fileContentMD5,
        fileContentDisposition,
        fileContentLength1
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const setMetadataOperationSpec$2 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileSetMetadataHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileSetMetadataExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp5],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        leaseId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const acquireLeaseOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: FileAcquireLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileAcquireLeaseExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        action,
        duration,
        proposedLeaseId,
        requestId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const releaseLeaseOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileReleaseLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileReleaseLeaseExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        requestId,
        action1,
        leaseId1
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const changeLeaseOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileChangeLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileChangeLeaseExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        proposedLeaseId,
        requestId,
        leaseId1,
        action2
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const breakLeaseOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        202: {
            headersMapper: FileBreakLeaseHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileBreakLeaseExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp2],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        requestId,
        action4
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const uploadRangeOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: FileUploadRangeHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileUploadRangeExceptionHeaders
        }
    },
    requestBody: body,
    queryParameters: [timeoutInSeconds, comp11],
    urlParameters: [url],
    headerParameters: [
        version,
        leaseId,
        contentType1,
        accept3,
        range1,
        fileRangeWrite,
        contentLength,
        contentMD5
    ],
    contentType: "application/octet-stream",
    isXML: true,
    serializer: xmlSerializer$3
};
const uploadRangeFromURLOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: FileUploadRangeFromURLHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileUploadRangeFromURLExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds, comp11],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        range1,
        contentLength,
        copySource,
        sourceRange,
        fileRangeWriteFromUrl,
        sourceContentCrc64,
        sourceIfMatchCrc64,
        sourceIfNoneMatchCrc64,
        copySourceAuthorization
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const getRangeListOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ShareFileRangeList,
            headersMapper: FileGetRangeListHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileGetRangeListExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        shareSnapshot,
        comp12,
        prevsharesnapshot
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        range
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const startCopyOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        202: {
            headersMapper: FileStartCopyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileStartCopyExceptionHeaders
        }
    },
    queryParameters: [timeoutInSeconds],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        metadata,
        leaseId,
        filePermission,
        filePermissionKey1,
        copySource,
        filePermissionCopyMode,
        ignoreReadOnly,
        fileAttributes1,
        fileCreationTime,
        fileLastWriteTime,
        setArchiveAttribute
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const abortCopyOperationSpec = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        204: {
            headersMapper: FileAbortCopyHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileAbortCopyExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        comp13,
        copyId
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        leaseId,
        copyActionAbortConstant
    ],
    isXML: true,
    serializer: xmlSerializer$3
};
const listHandlesOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHandlesResponse,
            headersMapper: FileListHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileListHandlesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        marker,
        maxResults,
        shareSnapshot,
        comp9
    ],
    urlParameters: [url],
    headerParameters: [version, accept1],
    isXML: true,
    serializer: xmlSerializer$3
};
const forceCloseHandlesOperationSpec$1 = {
    path: "/{shareName}/{directory}/{fileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: FileForceCloseHandlesHeaders
        },
        default: {
            bodyMapper: StorageError,
            headersMapper: FileForceCloseHandlesExceptionHeaders
        }
    },
    queryParameters: [
        timeoutInSeconds,
        marker,
        shareSnapshot,
        comp10
    ],
    urlParameters: [url],
    headerParameters: [
        version,
        accept1,
        handleId
    ],
    isXML: true,
    serializer: xmlSerializer$3
};

// Copyright (c) Microsoft Corporation.
/**
 * The `@azure/logger` configuration for this package.
 */
const logger = logger$1.createClientLogger("storage-file-share");

// Copyright (c) Microsoft Corporation.
/**
 * StorageBrowserPolicy will handle differences between Node.js and browser runtime, including:
 *
 * 1. Browsers cache GET/HEAD requests by adding conditional headers such as 'IF_MODIFIED_SINCE'.
 * StorageBrowserPolicy is a policy used to add a timestamp query to GET/HEAD request URL
 * thus avoid the browser cache.
 *
 * 2. Remove cookie header for security
 *
 * 3. Remove content-length header to avoid browsers warning
 */
class StorageBrowserPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Creates an instance of StorageBrowserPolicy.
     * @param nextPolicy -
     * @param options -
     */
    // The base class has a protected constructor. Adding a public one to enable constructing of this class.
    /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
    constructor(nextPolicy, options) {
        super(nextPolicy, options);
    }
    /**
     * Sends out request.
     *
     * @param request -
     */
    async sendRequest(request) {
        {
            return this._nextPolicy.sendRequest(request);
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * StorageBrowserPolicyFactory is a factory class helping generating BrowserPolicy objects.
 */
class StorageBrowserPolicyFactory {
    /**
     * Creates a StorageBrowserPolicyFactory object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy, options) {
        return new StorageBrowserPolicy(nextPolicy, options);
    }
}

// Copyright (c) Microsoft Corporation.
(function (StorageRetryPolicyType) {
    /**
     * Exponential retry. Retry time delay grows exponentially.
     */
    StorageRetryPolicyType[StorageRetryPolicyType["EXPONENTIAL"] = 0] = "EXPONENTIAL";
    /**
     * Linear retry. Retry time delay grows linearly.
     */
    StorageRetryPolicyType[StorageRetryPolicyType["FIXED"] = 1] = "FIXED";
})(exports.StorageRetryPolicyType || (exports.StorageRetryPolicyType = {}));
// Default values of RetryOptions
const DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120 * 1000,
    maxTries: 4,
    retryDelayInMs: 4 * 1000,
    retryPolicyType: exports.StorageRetryPolicyType.EXPONENTIAL,
    tryTimeoutInMs: undefined // Use server side default timeout strategy
};
const RETRY_ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
/**
 * Retry policy with exponential retry and linear retry implemented.
 */
class StorageRetryPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Creates an instance of RetryPolicy.
     *
     * @param nextPolicy -
     * @param options -
     * @param retryOptions -
     */
    constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS) {
        super(nextPolicy, options);
        // Initialize retry options
        this.retryOptions = {
            retryPolicyType: retryOptions.retryPolicyType
                ? retryOptions.retryPolicyType
                : DEFAULT_RETRY_OPTIONS.retryPolicyType,
            maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1
                ? Math.floor(retryOptions.maxTries)
                : DEFAULT_RETRY_OPTIONS.maxTries,
            tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0
                ? retryOptions.tryTimeoutInMs
                : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
            retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0
                ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs
                    ? retryOptions.maxRetryDelayInMs
                    : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs)
                : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
            maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0
                ? retryOptions.maxRetryDelayInMs
                : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs
        };
    }
    /**
     * Sends request.
     *
     * @param request -
     */
    async sendRequest(request) {
        return this.attemptSendRequest(request, false, 1);
    }
    /**
     * Decide and perform next retry. Won't mutate request parameter.
     *
     * @param request -
     * @param response -
     * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
     *                                   the resource was not found. This may be due to replication delay. So, in this
     *                                   case, we'll never try the secondary again for this operation.
     * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
     *                                   the attempt will be performed by this method call.
     */
    async attemptSendRequest(request, secondaryHas404, attempt) {
        const newRequest = request.clone();
        const isPrimaryRetry = true; // File doesn't support secondary endpoint
        // Set the server-side timeout query parameter "timeout=[seconds]"
        if (this.retryOptions.tryTimeoutInMs) {
            newRequest.url = setURLParameter(newRequest.url, URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
        }
        let response;
        try {
            logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`);
            response = await this._nextPolicy.sendRequest(newRequest);
            if (!this.shouldRetry(isPrimaryRetry, attempt, response)) {
                return response;
            }
            secondaryHas404 = secondaryHas404 || (!isPrimaryRetry && response.status === 404);
        }
        catch (err) {
            logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`);
            if (!this.shouldRetry(isPrimaryRetry, attempt, response, err)) {
                throw err;
            }
        }
        await this.delay(isPrimaryRetry, attempt, request.abortSignal);
        return this.attemptSendRequest(request, secondaryHas404, ++attempt);
    }
    /**
     * Decide whether to retry according to last HTTP response and retry counters.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param response -
     * @param err -
     */
    shouldRetry(isPrimaryRetry, attempt, response, err) {
        if (attempt >= this.retryOptions.maxTries) {
            logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions
                .maxTries}, no further try.`);
            return false;
        }
        // Handle network failures, you may need to customize the list when you implement
        // your own http client
        const retriableErrors = [
            "ETIMEDOUT",
            "ESOCKETTIMEDOUT",
            "ECONNREFUSED",
            "ECONNRESET",
            "ENOENT",
            "ENOTFOUND",
            "TIMEOUT",
            "EPIPE",
            "REQUEST_SEND_ERROR" // For default xhr based http client provided in ms-rest-js
        ];
        if (err) {
            for (const retriableError of retriableErrors) {
                if (err.name.toUpperCase().includes(retriableError) ||
                    err.message.toUpperCase().includes(retriableError) ||
                    (err.code && err.code.toString().toUpperCase() === retriableError)) {
                    logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`);
                    return true;
                }
            }
        }
        // If attempt was against the secondary & it returned a StatusNotFound (404), then
        // the resource was not found. This may be due to replication delay. So, in this
        // case, we'll never try the secondary again for this operation.
        if (response || err) {
            const statusCode = response ? response.status : err ? err.statusCode : 0;
            if (!isPrimaryRetry && statusCode === 404) {
                logger.info(`RetryPolicy: Secondary access with 404, will retry.`);
                return true;
            }
            // Server internal error or server timeout
            if (statusCode === 503 || statusCode === 500) {
                logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`);
                return true;
            }
        }
        if ((err === null || err === void 0 ? void 0 : err.code) === "PARSE_ERROR" && (err === null || err === void 0 ? void 0 : err.message.startsWith(`Error "Error: Unclosed root tag`))) {
            logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry.");
            return true;
        }
        return false;
    }
    /**
     * Delay a calculated time between retries.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param abortSignal -
     */
    async delay(isPrimaryRetry, attempt, abortSignal) {
        let delayTimeInMs = 0;
        if (isPrimaryRetry) {
            switch (this.retryOptions.retryPolicyType) {
                case exports.StorageRetryPolicyType.EXPONENTIAL:
                    delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
                    break;
                case exports.StorageRetryPolicyType.FIXED:
                    delayTimeInMs = this.retryOptions.retryDelayInMs;
                    break;
            }
        }
        else {
            delayTimeInMs = Math.random() * 1000;
        }
        logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`);
        return delay(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * StorageRetryPolicyFactory is a factory class helping generating StorageRetryPolicy objects.
 */
class StorageRetryPolicyFactory {
    /**
     * Creates an instance of StorageRetryPolicyFactory.
     * @param retryOptions -
     */
    constructor(retryOptions) {
        this.retryOptions = retryOptions;
    }
    /**
     * Creates a StorageRetryPolicy object.
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy, options) {
        return new StorageRetryPolicy(nextPolicy, options, this.retryOptions);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * TelemetryPolicy is a policy used to tag user-agent header for every requests.
 */
class TelemetryPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Creates an instance of TelemetryPolicy.
     * @param nextPolicy -
     * @param options -
     * @param telemetry -
     */
    constructor(nextPolicy, options, telemetry) {
        super(nextPolicy, options);
        this.telemetry = telemetry;
    }
    /**
     * Sends out request.
     *
     * @param request -
     */
    async sendRequest(request) {
        {
            if (!request.headers) {
                request.headers = new coreHttp.HttpHeaders();
            }
            if (!request.headers.get(HeaderConstants.USER_AGENT)) {
                request.headers.set(HeaderConstants.USER_AGENT, this.telemetry);
            }
        }
        return this._nextPolicy.sendRequest(request);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * TelemetryPolicyFactory is a factory class helping generating {@link TelemetryPolicy} objects.
 */
class TelemetryPolicyFactory {
    /**
     * Creates an instance of TelemetryPolicyFactory.
     * @param telemetry -
     */
    constructor(telemetry) {
        const userAgentInfo = [];
        {
            if (telemetry) {
                const telemetryString = telemetry.userAgentPrefix || "";
                if (telemetryString.length > 0 && userAgentInfo.indexOf(telemetryString) === -1) {
                    userAgentInfo.push(telemetryString);
                }
            }
            // e.g. azsdk-js-storagefile/11.0.0
            const libInfo = `azsdk-js-storagefile/${SDK_VERSION}`;
            if (userAgentInfo.indexOf(libInfo) === -1) {
                userAgentInfo.push(libInfo);
            }
            // e.g. (NODE-VERSION 4.9.1; Windows_NT 10.0.16299)
            const runtimeInfo = `(NODE-VERSION ${process.version}; ${os.type()} ${os.release()})`;
            if (userAgentInfo.indexOf(runtimeInfo) === -1) {
                userAgentInfo.push(runtimeInfo);
            }
        }
        this.telemetryString = userAgentInfo.join(" ");
    }
    /**
     * Creates a {@link RequestPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy, options) {
        return new TelemetryPolicy(nextPolicy, options, this.telemetryString);
    }
}

// Copyright (c) Microsoft Corporation.
const _defaultHttpClient = new coreHttp.DefaultHttpClient();
function getCachedDefaultHttpClient() {
    return _defaultHttpClient;
}

// Copyright (c) Microsoft Corporation.
/**
 * Credential policy used to sign HTTP(S) requests before sending. This is an
 * abstract class.
 */
class CredentialPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Sends out request.
     *
     * @param request -
     */
    sendRequest(request) {
        return this._nextPolicy.sendRequest(this.signRequest(request));
    }
    /**
     * Child classes must implement this method with request signing. This method
     * will be executed in {@link sendRequest}.
     *
     * @param request -
     */
    signRequest(request) {
        // Child classes must override this method with request signing. This method
        // will be executed in sendRequest().
        return request;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * AnonymousCredentialPolicy is used with HTTP(S) requests that read public resources
 * or for use with Shared Access Signatures (SAS).
 */
class AnonymousCredentialPolicy extends CredentialPolicy {
    /**
     * Creates an instance of AnonymousCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     */
    // The base class has a protected constructor. Adding a public one to enable constructing of this class.
    /* eslint-disable-next-line @typescript-eslint/no-useless-constructor*/
    constructor(nextPolicy, options) {
        super(nextPolicy, options);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Credential is an abstract class for Azure Storage HTTP requests signing. This
 * class will host an credentialPolicyCreator factory which generates CredentialPolicy.
 */
class Credential {
    /**
     * Creates a RequestPolicy object.
     *
     * @param _nextPolicy -
     * @param _options -
     */
    create(_nextPolicy, _options) {
        throw new Error("Method should be implemented in children classes.");
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * AnonymousCredential provides a credentialPolicyCreator member used to create
 * {@link AnonymousCredentialPolicy} objects. AnonymousCredentialPolicy is used with
 * HTTP(S) requests that read public resources or for use with Shared Access
 * Signatures (SAS).
 */
class AnonymousCredential extends Credential {
    /**
     * Creates an {@link AnonymousCredentialPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy, options) {
        return new AnonymousCredentialPolicy(nextPolicy, options);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A Pipeline class containing HTTP request policies.
 * You can create a default Pipeline by calling {@link newPipeline}.
 * Or you can create a Pipeline with your own policies by the constructor of Pipeline.
 *
 * Refer to {@link newPipeline} and provided policies as reference before
 * implementing your customized Pipeline.
 */
class Pipeline {
    /**
     * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
     *
     * @param factories -
     * @param options -
     */
    constructor(factories, options = {}) {
        this.factories = factories;
        // when options.httpClient is not specified, passing in a DefaultHttpClient instance to
        // avoid each client creating its own http client.
        this.options = Object.assign(Object.assign({}, options), { httpClient: options.httpClient || getCachedDefaultHttpClient() });
    }
    /**
     * Transfer Pipeline object to ServiceClientOptions object which required by
     * ServiceClient constructor.
     *
     * @returns The ServiceClientOptions object from this Pipeline.
     */
    toServiceClientOptions() {
        return {
            httpClient: this.options.httpClient,
            requestPolicyFactories: this.factories
        };
    }
}
/**
 * Creates a new {@link Pipeline} object with {@link Credential} provided.
 *
 * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential.
 * @param pipelineOptions - Optional. Options.
 * @returns A new Pipeline object.
 */
function newPipeline(credential, pipelineOptions = {}) {
    if (credential === undefined) {
        credential = new AnonymousCredential();
    }
    // Order is important. Closer to the API at the top & closer to the network at the bottom.
    // The credential's policy factory must appear close to the wire so it can sign any
    // changes made by other factories (like UniqueRequestIDPolicyFactory)
    const telemetryPolicy = new TelemetryPolicyFactory(pipelineOptions.userAgentOptions);
    const factories = [
        coreHttp.tracingPolicy({ userAgent: telemetryPolicy.telemetryString }),
        coreHttp.keepAlivePolicy(pipelineOptions.keepAliveOptions),
        telemetryPolicy,
        coreHttp.generateClientRequestIdPolicy(),
        new StorageBrowserPolicyFactory(),
        new StorageRetryPolicyFactory(pipelineOptions.retryOptions),
        coreHttp.deserializationPolicy(),
        coreHttp.logPolicy({
            logger: logger.info,
            allowedHeaderNames: StorageFileLoggingAllowedHeaderNames,
            allowedQueryParameters: StorageFileLoggingAllowedQueryParameters
        })
    ];
    {
        // policies only available in Node.js runtime, not in browsers
        factories.push(coreHttp.proxyPolicy(pipelineOptions.proxyOptions));
        factories.push(coreHttp.disableResponseDecompressionPolicy());
    }
    factories.push(credential);
    return new Pipeline(factories, pipelineOptions);
}

// Copyright (c) Microsoft Corporation.
/**
 * StorageSharedKeyCredentialPolicy is a policy used to sign HTTP request with a shared key.
 */
class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    /**
     * Creates an instance of StorageSharedKeyCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     * @param factory -
     */
    constructor(nextPolicy, options, factory) {
        super(nextPolicy, options);
        this.factory = factory;
    }
    /**
     * Signs request.
     *
     * @param request -
     */
    signRequest(request) {
        request.headers.set(HeaderConstants.X_MS_DATE, new Date().toUTCString());
        if (request.body && typeof request.body === "string" && request.body.length > 0) {
            request.headers.set(HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
        }
        const stringToSign = [
            request.method.toUpperCase(),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LANGUAGE),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_ENCODING),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_LENGTH),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_MD5),
            this.getHeaderValueToSign(request, HeaderConstants.CONTENT_TYPE),
            this.getHeaderValueToSign(request, HeaderConstants.DATE),
            this.getHeaderValueToSign(request, HeaderConstants.IF_MODIFIED_SINCE),
            this.getHeaderValueToSign(request, HeaderConstants.IF_MATCH),
            this.getHeaderValueToSign(request, HeaderConstants.IF_NONE_MATCH),
            this.getHeaderValueToSign(request, HeaderConstants.IF_UNMODIFIED_SINCE),
            this.getHeaderValueToSign(request, HeaderConstants.RANGE)
        ].join("\n") +
            "\n" +
            this.getCanonicalizedHeadersString(request) +
            this.getCanonicalizedResourceString(request);
        const signature = this.factory.computeHMACSHA256(stringToSign);
        request.headers.set(HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`);
        // console.log(`[URL]:${request.url}`);
        // console.log(`[HEADERS]:${request.headers.toString()}`);
        // console.log(`[STRING TO SIGN]:${JSON.stringify(stringToSign)}`);
        // console.log(`[KEY]: ${request.headers.get(HeaderConstants.AUTHORIZATION)}`);
        return request;
    }
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
     *
     * @param request -
     * @param headerName -
     */
    getHeaderValueToSign(request, headerName) {
        const value = request.headers.get(headerName);
        if (!value) {
            return "";
        }
        // When using version 2015-02-21 or later, if Content-Length is zero, then
        // set the Content-Length part of the StringToSign to an empty string.
        // https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
        if (headerName === HeaderConstants.CONTENT_LENGTH && value === "0") {
            return "";
        }
        return value;
    }
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     * @param request -
     */
    getCanonicalizedHeadersString(request) {
        let headersArray = request.headers.headersArray().filter((value) => {
            return value.name.toLowerCase().startsWith(HeaderConstants.PREFIX_FOR_STORAGE);
        });
        headersArray.sort((a, b) => {
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
        // Remove duplicate headers
        headersArray = headersArray.filter((value, index, array) => {
            if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase()) {
                return false;
            }
            return true;
        });
        let canonicalizedHeadersStringToSign = "";
        headersArray.forEach((header) => {
            canonicalizedHeadersStringToSign += `${header.name
                .toLowerCase()
                .trimRight()}:${header.value.trimLeft()}\n`;
        });
        return canonicalizedHeadersStringToSign;
    }
    /**
     * Retrieves the webResource canonicalized resource string.
     *
     * @param request -
     */
    getCanonicalizedResourceString(request) {
        const path = getURLPath(request.url) || "/";
        let canonicalizedResourceString = "";
        canonicalizedResourceString += `/${this.factory.accountName}${path}`;
        const queries = getURLQueries(request.url);
        const lowercaseQueries = {};
        if (queries) {
            const queryKeys = [];
            for (const key in queries) {
                if (Object.prototype.hasOwnProperty.call(queries, key)) {
                    const lowercaseKey = key.toLowerCase();
                    lowercaseQueries[lowercaseKey] = queries[key];
                    queryKeys.push(lowercaseKey);
                }
            }
            queryKeys.sort();
            for (const key of queryKeys) {
                canonicalizedResourceString += `\n${key}:${decodeURIComponent(lowercaseQueries[key])}`;
            }
        }
        return canonicalizedResourceString;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * StorageSharedKeyCredential for account key authorization of Azure Storage service.
 */
class StorageSharedKeyCredential extends Credential {
    /**
     * Creates an instance of StorageSharedKeyCredential.
     * @param accountName -
     * @param accountKey -
     */
    constructor(accountName, accountKey) {
        super();
        this.accountName = accountName;
        this.accountKey = Buffer.from(accountKey, "base64");
    }
    /**
     * Creates a {@link StorageSharedKeyCredentialPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy, options) {
        return new StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
    }
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param stringToSign -
     */
    computeHMACSHA256(stringToSign) {
        return crypto.createHmac("sha256", this.accountKey)
            .update(stringToSign, "utf8")
            .digest("base64");
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const createSpan = coreTracing.createSpanFunction({
    packagePrefix: "Azure.Storage.File",
    namespace: "Microsoft.Storage"
});
/**
 * @internal
 *
 * Adapt the tracing options from OperationOptions to what they need to be for
 * RequestOptionsBase (when we update to later OpenTelemetry versions this is now
 * two separate fields, not just one).
 */
function convertTracingToRequestOptionsBase(options) {
    var _a, _b;
    return {
        // By passing spanOptions if they exist at runtime, we're backwards compatible with @azure/core-tracing@preview.13 and earlier.
        spanOptions: (_a = options === null || options === void 0 ? void 0 : options.tracingOptions) === null || _a === void 0 ? void 0 : _a.spanOptions,
        tracingContext: (_b = options === null || options === void 0 ? void 0 : options.tracingOptions) === null || _b === void 0 ? void 0 : _b.tracingContext
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "azure-storage-file-share";
const packageVersion = "12.8.0";
class StorageClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the StorageClientContext class.
     * @param url The URL of the service account, share, directory or file that is the target of the
     *            desired operation.
     * @param options The parameter options
     */
    constructor(url, options) {
        if (url === undefined) {
            throw new Error("'url' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{url}";
        // Parameter assignments
        this.url = url;
        // Assigning values to Constant parameters
        this.version = options.version || "2020-10-02";
        this.fileRangeWriteFromUrl = options.fileRangeWriteFromUrl || "update";
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A StorageClient represents a base client class for ServiceClient, ContainerClient and etc.
 */
class StorageClient {
    /**
     * Creates an instance of StorageClient.
     * @param url -
     * @param pipeline -
     */
    constructor(url, pipeline) {
        // URL should be encoded and only once, protocol layer shouldn't encode URL again
        this.url = escapeURLPath(url);
        this.accountName = getAccountNameFromUrl(url);
        this.pipeline = pipeline;
        this.storageClientContext = new StorageClientContext(this.url, Object.assign({ version: SERVICE_VERSION }, pipeline.toServiceClientOptions()));
        // Remove the default content-type in generated code of StorageClientContext
        const storageClientContext = this.storageClientContext;
        if (storageClientContext.requestContentType) {
            storageClientContext.requestContentType = undefined;
        }
        // Retrieve credential from the pipeline.
        this.credential = new AnonymousCredential();
        for (const factory of this.pipeline.factories) {
            if ((coreHttp.isNode && factory instanceof StorageSharedKeyCredential) ||
                factory instanceof AnonymousCredential) {
                this.credential = factory;
                break;
            }
        }
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * This is a helper class to construct a string representing the NTFS attributes to a file or directory.
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file#file-system-attributes
 */
class FileSystemAttributes {
    constructor() {
        /**
         * Specifies a directory or file that is read-only.
         */
        this.readonly = false;
        /**
         * Specifies a directory or file is hidden.
         */
        this.hidden = false;
        /**
         * Specifies a directory or file that the operating system uses a part of, or uses exclusively.
         */
        this.system = false;
        /**
         * Specifies a directory or file that does not have other attributes set. This attribute is valid only when used alone.
         */
        this.none = false;
        /**
         * Specifies the handle identifies a directory.
         */
        this.directory = false;
        /**
         * Specifies a directory or file is an archive. Applications typically use this attribute to mark files for backup or removal.
         */
        this.archive = false;
        /**
         * Specifies if a file is temporary.
         */
        this.temporary = false;
        /**
         * Specifies the data of a directory or file is not available immediately.
         * This file system attribute is presented primarily to provide compatibility with Windows - Azure Files does not support with offline storage options.
         */
        this.offline = false;
        /**
         * Specifies the directory or file is not to be indexed by the content indexing service.
         */
        this.notContentIndexed = false;
        /**
         * Specifies the user data stream not to be read by the background data integrity scanner.
         * This file system attribute is presented primarily to provide compatibility with Windows.
         * Applicable to directory or file.
         */
        this.noScrubData = false;
    }
    /**
     * Creates a FileSystemAttributes from the specified attributes string. This method will throw an
     * Error if it encounters a string that does not correspond to a valid attributes.
     *
     * @param fileAttributes - The value of header x-ms-file-attributes.
     */
    static parse(fileAttributes) {
        if (!fileAttributes) {
            throw new RangeError(`Invalid fileAttributes: '${fileAttributes}'.`);
        }
        const fileSystemAttributes = new FileSystemAttributes();
        const attributes = fileAttributes.trim().split("|");
        for (let str of attributes) {
            str = str.trim();
            switch (str) {
                case "ReadOnly":
                    fileSystemAttributes.readonly = true;
                    break;
                case "Hidden":
                    fileSystemAttributes.hidden = true;
                    break;
                case "System":
                    fileSystemAttributes.system = true;
                    break;
                case "None":
                    fileSystemAttributes.none = true;
                    break;
                case "Temporary":
                    fileSystemAttributes.temporary = true;
                    break;
                case "Offline":
                    fileSystemAttributes.offline = true;
                    break;
                case "Directory":
                    fileSystemAttributes.directory = true;
                    break;
                case "Archive":
                    fileSystemAttributes.archive = true;
                    break;
                case "NotContentIndexed":
                    fileSystemAttributes.notContentIndexed = true;
                    break;
                case "NoScrubData":
                    fileSystemAttributes.noScrubData = true;
                    break;
                default:
                    throw new RangeError(`Invalid attribute: ${str}`);
            }
        }
        return fileSystemAttributes;
    }
    /**
     * Converts the given attributes to a string.
     *
     * @returns A string which represents the FileSystemAttributes
     */
    toString() {
        const attributes = [];
        if (this.readonly) {
            attributes.push("ReadOnly");
        }
        if (this.hidden) {
            attributes.push("Hidden");
        }
        if (this.system) {
            attributes.push("System");
        }
        if (this.none) {
            attributes.push("None");
        }
        if (this.temporary) {
            attributes.push("Temporary");
        }
        if (this.directory) {
            attributes.push("Directory");
        }
        if (this.archive) {
            attributes.push("Archive");
        }
        if (this.offline) {
            attributes.push("Offline");
        }
        if (this.notContentIndexed) {
            attributes.push("NotContentIndexed");
        }
        if (this.noScrubData) {
            attributes.push("NoScrubData");
        }
        return attributes.join("|");
    }
}

// Copyright (c) Microsoft Corporation.
const ABORT_ERROR = new abortController.AbortError("The operation was aborted.");
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * A Node.js ReadableStream will internally retry when internal ReadableStream unexpected ends.
 */
class RetriableReadableStream extends stream.Readable {
    /**
     * Creates an instance of RetriableReadableStream.
     *
     * @param source - The current ReadableStream returned from getter
     * @param getter - A method calling downloading request returning
     *                                      a new ReadableStream from specified offset
     * @param offset - Offset position in original data source to read
     * @param count - How much data in original data source to read
     * @param options -
     */
    constructor(source, getter, offset, count, options = {}) {
        super();
        this.retries = 0;
        this.abortHandler = () => {
            this.source.pause();
            this.emit("error", ABORT_ERROR);
        };
        const aborter = options.abortSignal || abortController.AbortSignal.none;
        this.aborter = aborter;
        this.getter = getter;
        this.source = source;
        this.start = offset;
        this.offset = offset;
        this.end = offset + count - 1;
        this.maxRetryRequests =
            options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
        this.onProgress = options.onProgress;
        this.options = options;
        aborter.addEventListener("abort", this.abortHandler);
        this.setSourceDataHandler();
        this.setSourceEndHandler();
        this.setSourceErrorHandler();
    }
    _read() {
        if (!this.aborter.aborted) {
            this.source.resume();
        }
    }
    setSourceDataHandler() {
        this.source.on("data", (data) => {
            if (this.options.doInjectErrorOnce) {
                this.options.doInjectErrorOnce = undefined;
                this.source.pause();
                this.source.removeAllListeners("data");
                this.source.emit("end");
                return;
            }
            // console.log(
            //   `Offset: ${this.offset}, Received ${data.length} from internal stream`
            // );
            this.offset += data.length;
            if (this.onProgress) {
                this.onProgress({ loadedBytes: this.offset - this.start });
            }
            if (!this.push(data)) {
                this.source.pause();
            }
        });
    }
    setSourceEndHandler() {
        this.source.on("end", () => {
            // console.log(
            //   `Source stream emits end, offset: ${
            //     this.offset
            //   }, dest end : ${this.end}`
            // );
            if (this.offset - 1 === this.end) {
                this.aborter.removeEventListener("abort", this.abortHandler);
                this.push(null);
            }
            else if (this.offset <= this.end) {
                // console.log(
                //   `retries: ${this.retries}, max retries: ${this.maxRetries}`
                // );
                if (this.retries < this.maxRetryRequests) {
                    this.retries += 1;
                    this.getter(this.offset)
                        .then((newSource) => {
                        this.source = newSource;
                        this.setSourceDataHandler();
                        this.setSourceEndHandler();
                        this.setSourceErrorHandler();
                        return;
                    })
                        .catch((error) => {
                        this.emit("error", error);
                    });
                }
                else {
                    this.emit("error", new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this
                        .offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
                }
            }
            else {
                this.emit("error", new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
            }
        });
    }
    setSourceErrorHandler() {
        this.source.on("error", (error) => {
            this.emit("error", error);
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * FileDownloadResponse implements the `FileDownloadResponseModel` interface, and in a Node.js runtime it will
 * automatically retry when its internal read stream unexpectedly ends. (This kind of unexpected end cannot
 * trigger retries defined in the pipeline retry policy.)
 *
 * The {@link readableStreamBody} stream will retry beneath the `ReadableStream` layer, so you can just use it as
 * a normal Node.js Readable stream.
 */
class FileDownloadResponse {
    /**
     * Creates an instance of FileDownloadResponse.
     *
     * @param originalResponse -
     * @param getter -
     * @param offset -
     * @param count -
     * @param options -
     */
    constructor(originalResponse, getter, offset, count, options = {}) {
        this.originalResponse = originalResponse;
        this.fileDownloadStream = new RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
    }
    /**
     * Indicates that the service supports
     * requests for partial file content.
     *
     * @readonly
     */
    get acceptRanges() {
        return this.originalResponse.acceptRanges;
    }
    /**
     * Returnes if it was previously specified
     * for the file.
     *
     * @readonly
     */
    get cacheControl() {
        return this.originalResponse.cacheControl;
    }
    /**
     * Returns the value that was specified
     * for the 'x-ms-content-disposition' header and specifies how to process the
     * response.
     *
     * @readonly
     */
    get contentDisposition() {
        return this.originalResponse.contentDisposition;
    }
    /**
     * Returns the value that was specified
     * for the Content-Encoding request header.
     *
     * @readonly
     */
    get contentEncoding() {
        return this.originalResponse.contentEncoding;
    }
    /**
     * Returns the value that was specified
     * for the Content-Language request header.
     *
     * @readonly
     */
    get contentLanguage() {
        return this.originalResponse.contentLanguage;
    }
    /**
     * The number of bytes present in the
     * response body.
     *
     * @readonly
     */
    get contentLength() {
        return this.originalResponse.contentLength;
    }
    /**
     * If the file has an MD5 hash and the
     * request is to read the full file, this response header is returned so that
     * the client can check for message content integrity. If the request is to
     * read a specified range and the 'x-ms-range-get-content-md5' is set to
     * true, then the request returns an MD5 hash for the range, as long as the
     * range size is less than or equal to 4 MB. If neither of these sets of
     * conditions is true, then no value is returned for the 'Content-MD5'
     * header.
     *
     * @readonly
     */
    get contentMD5() {
        return this.originalResponse.contentMD5;
    }
    /**
     * Indicates the range of bytes returned if
     * the client requested a subset of the file by setting the Range request
     * header.
     *
     * @readonly
     */
    get contentRange() {
        return this.originalResponse.contentRange;
    }
    /**
     * The content type specified for the file.
     * The default content type is 'application/octet-stream'
     *
     * @readonly
     */
    get contentType() {
        return this.originalResponse.contentType;
    }
    /**
     * Conclusion time of the last attempted
     * Copy File operation where this file was the destination file. This value
     * can specify the time of a completed, aborted, or failed copy attempt.
     *
     * @readonly
     */
    get copyCompletedOn() {
        return this.originalResponse.copyCompletedOn;
    }
    /**
     * String identifier for the last attempted Copy
     * File operation where this file was the destination file.
     *
     * @readonly
     */
    get copyId() {
        return this.originalResponse.copyId;
    }
    /**
     * Contains the number of bytes copied and
     * the total bytes in the source in the last attempted Copy File operation
     * where this file was the destination file. Can show between 0 and
     * Content-Length bytes copied.
     *
     * @readonly
     */
    get copyProgress() {
        return this.originalResponse.copyProgress;
    }
    /**
     * URL up to 2KB in length that specifies the
     * source file used in the last attempted Copy File operation where this file
     * was the destination file.
     *
     * @readonly
     */
    get copySource() {
        return this.originalResponse.copySource;
    }
    /**
     * State of the copy operation
     * identified by 'x-ms-copy-id'. Possible values include: 'pending',
     * 'success', 'aborted', 'failed'
     *
     * @readonly
     */
    get copyStatus() {
        return this.originalResponse.copyStatus;
    }
    /**
     * Only appears when
     * x-ms-copy-status is failed or pending. Describes cause of fatal or
     * non-fatal copy operation failure.
     *
     * @readonly
     */
    get copyStatusDescription() {
        return this.originalResponse.copyStatusDescription;
    }
    /**
     * A UTC date/time value generated by the service that
     * indicates the time at which the response was initiated.
     *
     * @readonly
     */
    get date() {
        return this.originalResponse.date;
    }
    /**
     * The ETag contains a value that you can use to
     * perform operations conditionally, in quotes.
     *
     * @readonly
     */
    get etag() {
        return this.originalResponse.etag;
    }
    get errorCode() {
        return this.originalResponse.errorCode;
    }
    /**
     * If the file has a MD5 hash, and if
     * request contains range header (Range or x-ms-range), this response header
     * is returned with the value of the whole file's MD5 value. This value may
     * or may not be equal to the value returned in Content-MD5 header, with the
     * latter calculated from the requested range.
     *
     * @readonly
     */
    get fileContentMD5() {
        return this.originalResponse.fileContentMD5;
    }
    /**
     * The value of this header is set to
     * true if the file data and application metadata are completely encrypted
     * using the specified algorithm. Otherwise, the value is set to false (when
     * the file is unencrypted, or if only parts of the file/application metadata
     * are encrypted).
     *
     * @readonly
     */
    get isServerEncrypted() {
        return this.originalResponse.isServerEncrypted;
    }
    /**
     * Returns the date and time the file was last
     * modified. Any operation that modifies the file or its properties updates
     * the last modified time.
     *
     * @readonly
     */
    get lastModified() {
        return this.originalResponse.lastModified;
    }
    /**
     * A name-value pair
     * to associate with a file storage object.
     *
     * @readonly
     */
    get metadata() {
        return this.originalResponse.metadata;
    }
    /**
     * This header uniquely identifies the request
     * that was made and can be used for troubleshooting the request.
     *
     * @readonly
     */
    get requestId() {
        return this.originalResponse.requestId;
    }
    /**
     * Indicates the version of the File service used
     * to execute the request.
     *
     * @readonly
     */
    get version() {
        return this.originalResponse.version;
    }
    /**
     * Attributes set for the file.
     *
     * @readonly
     */
    get fileAttributes() {
        return this.originalResponse.fileAttributes;
    }
    /**
     * Creation time for the file.
     *
     * @readonly
     */
    get fileCreatedOn() {
        return this.originalResponse.fileCreatedOn;
    }
    /**
     * Last write time for the file.
     *
     * @readonly
     */
    get fileLastWriteOn() {
        return this.originalResponse.fileLastWriteOn;
    }
    /**
     * Change time for the file.
     *
     * @readonly
     */
    get fileChangeOn() {
        return this.originalResponse.fileChangeOn;
    }
    /**
     * Key of the permission set for the file.
     *
     * @readonly
     */
    get filePermissionKey() {
        return this.originalResponse.filePermissionKey;
    }
    /**
     * The fileId of the file.
     *
     * @readonly
     */
    get fileId() {
        return this.originalResponse.fileId;
    }
    /**
     * The parent fileId of the file.
     *
     * @readonly
     */
    get fileParentId() {
        return this.originalResponse.fileParentId;
    }
    /**
     * The response body as a browser Blob.
     * Always undefined in node.js.
     *
     * @readonly
     */
    get contentAsBlob() {
        return this.originalResponse.blobBody;
    }
    /**
     * When a file is leased, specifies whether the lease is of infinite or fixed duration. Possible
     * values include: 'infinite', 'fixed'
     */
    get leaseDuration() {
        return this.originalResponse.leaseDuration;
    }
    /**
     * Lease state of the file. Possible values include: 'available', 'leased', 'expired',
     * 'breaking', 'broken'
     */
    get leaseState() {
        return this.originalResponse.leaseState;
    }
    /**
     * The current lease status of the file. Possible values include: 'locked', 'unlocked'
     */
    get leaseStatus() {
        return this.originalResponse.leaseStatus;
    }
    /**
     * The response body as a node.js Readable stream.
     * Always undefined in the browser.
     *
     * It will automatically retry when internal read stream unexpected ends.
     *
     * @readonly
     */
    get readableStreamBody() {
        return coreHttp.isNode ? this.fileDownloadStream : undefined;
    }
    get _response() {
        return this.originalResponse._response;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Generate a range string. For example:
 *
 * "bytes=255-" or "bytes=0-511"
 *
 * @param range - A range of byte positions.
 * @returns The string representation for the byte range.
 */
function rangeToString(range) {
    if (range.offset < 0) {
        throw new RangeError(`Range.offset cannot be smaller than 0.`);
    }
    if (range.count && range.count <= 0) {
        throw new RangeError(`Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.`);
    }
    return range.count
        ? `bytes=${range.offset}-${range.offset + range.count - 1}`
        : `bytes=${range.offset}-`;
}

// Copyright (c) Microsoft Corporation.
/**
 * Convert protocols from joined string to ShareProtocols.
 *
 * @param protocolsString -
 */
function toShareProtocols(protocolsString) {
    if (protocolsString === undefined) {
        return undefined;
    }
    const protocolStrArray = protocolsString.split(";");
    const protocols = {};
    for (const protocol of protocolStrArray) {
        if (protocol === "SMB") {
            protocols.smbEnabled = true;
        }
        else if (protocol === "NFS") {
            protocols.nfsEnabled = true;
        }
    }
    return protocols;
}
/**
 * Convert ShareProtocols to joined string.
 *
 * @param protocols -
 */
function toShareProtocolsString(protocols = {}) {
    let protocolStr = undefined;
    if (protocols.smbEnabled === true) {
        protocolStr = "SMB";
    }
    if (protocols.nfsEnabled === true) {
        logger.info(`Using "NFS" in favor of "SMB" for the share protocol as currently they can't be supported at the same time.`);
        protocolStr = "NFS";
    }
    return protocolStr;
}
function validateFilePermissionOptions(filePermission, filePermissionKey) {
    if (filePermission && filePermissionKey) {
        throw new RangeError("Only one of filePermission or filePermissionKey can be specified.");
    }
}
function validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options) {
    // Would better deep copy params set by user.
    if (!options) {
        options = {};
    }
    validateFilePermissionOptions(options.filePermission, options.filePermissionKey);
    if (!options.creationTime) {
        options.creationTime = "now";
    }
    if (!options.lastWriteTime) {
        options.lastWriteTime = "now";
    }
    if (!options.filePermission && !options.filePermissionKey) {
        options.filePermission = "inherit";
    }
    return options;
}
function validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options) {
    // Would better deep copy params set by user.
    if (!options) {
        options = {};
    }
    validateFilePermissionOptions(options.filePermission, options.filePermissionKey);
    if (!options.creationTime) {
        options.creationTime = "preserve";
    }
    if (!options.lastWriteTime) {
        options.lastWriteTime = "preserve";
    }
    if (!options.fileAttributes) {
        options.fileAttributes = "preserve";
    }
    if (!options.filePermission && !options.filePermissionKey) {
        options.filePermission = "preserve";
    }
    return options;
}
function fileAttributesToString(fileAttributes) {
    return fileAttributes instanceof FileSystemAttributes
        ? fileAttributes.toString()
        : fileAttributes;
}
function fileCreationTimeToString(time) {
    return time instanceof Date ? truncatedISO8061Date(time) : time;
}
function fileLastWriteTimeToString(time) {
    return time instanceof Date ? truncatedISO8061Date(time) : time;
}

// Copyright (c) Microsoft Corporation.
/**
 * States for Batch.
 */
var BatchStates;
(function (BatchStates) {
    BatchStates[BatchStates["Good"] = 0] = "Good";
    BatchStates[BatchStates["Error"] = 1] = "Error";
})(BatchStates || (BatchStates = {}));
/**
 * Batch provides basic parallel execution with concurrency limits.
 * Will stop execute left operations when one of the executed operation throws an error.
 * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.
 */
class Batch {
    /**
     * Creates an instance of Batch.
     * @param concurrency -
     */
    constructor(concurrency = 5) {
        /**
         * Number of active operations under execution.
         */
        this.actives = 0;
        /**
         * Number of completed operations under execution.
         */
        this.completed = 0;
        /**
         * Offset of next operation to be executed.
         */
        this.offset = 0;
        /**
         * Operation array to be executed.
         */
        this.operations = [];
        /**
         * States of Batch. When an error happens, state will turn into error.
         * Batch will stop execute left operations.
         */
        this.state = BatchStates.Good;
        if (concurrency < 1) {
            throw new RangeError("concurrency must be larger than 0");
        }
        this.concurrency = concurrency;
        this.emitter = new events.EventEmitter();
    }
    /**
     * Add a operation into queue.
     *
     * @param operation -
     */
    addOperation(operation) {
        this.operations.push(async () => {
            try {
                this.actives++;
                await operation();
                this.actives--;
                this.completed++;
                this.parallelExecute();
            }
            catch (error) {
                this.emitter.emit("error", error);
            }
        });
    }
    /**
     * Start execute operations in the queue.
     *
     */
    async do() {
        if (this.operations.length === 0) {
            return Promise.resolve();
        }
        this.parallelExecute();
        return new Promise((resolve, reject) => {
            this.emitter.on("finish", resolve);
            this.emitter.on("error", (error) => {
                this.state = BatchStates.Error;
                reject(error);
            });
        });
    }
    /**
     * Get next operation to be executed. Return null when reaching ends.
     *
     */
    nextOperation() {
        if (this.offset < this.operations.length) {
            return this.operations[this.offset++];
        }
        return null;
    }
    /**
     * Start execute operations. One one the most important difference between
     * this method with do() is that do() wraps as an sync method.
     *
     */
    parallelExecute() {
        if (this.state === BatchStates.Error) {
            return;
        }
        if (this.completed >= this.operations.length) {
            this.emitter.emit("finish");
            return;
        }
        while (this.actives < this.concurrency) {
            const operation = this.nextOperation();
            if (operation) {
                operation();
            }
            else {
                return;
            }
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * This class accepts a Node.js Readable stream as input, and keeps reading data
 * from the stream into the internal buffer structure, until it reaches maxBuffers.
 * Every available buffer will try to trigger outgoingHandler.
 *
 * The internal buffer structure includes an incoming buffer array, and a outgoing
 * buffer array. The incoming buffer array includes the "empty" buffers can be filled
 * with new incoming data. The outgoing array includes the filled buffers to be
 * handled by outgoingHandler. Every above buffer size is defined by parameter bufferSize.
 *
 * NUM_OF_ALL_BUFFERS = BUFFERS_IN_INCOMING + BUFFERS_IN_OUTGOING + BUFFERS_UNDER_HANDLING
 *
 * NUM_OF_ALL_BUFFERS lesser than or equal to maxBuffers
 *
 * PERFORMANCE IMPROVEMENT TIPS:
 * 1. Input stream highWaterMark is better to set a same value with bufferSize
 *    parameter, which will avoid Buffer.concat() operations.
 * 2. Concurrency should set a smaller value than maxBuffers, which is helpful to
 *    reduce the possibility when a outgoing handler waits for the stream data.
 *    in this situation, outgoing handlers are blocked.
 *    Outgoing queue shouldn't be empty.
 */
class BufferScheduler {
    /**
     * Creates an instance of BufferScheduler.
     *
     * @param readable - A Node.js Readable stream
     * @param bufferSize - Buffer size of every maintained buffer
     * @param maxBuffers - How many buffers can be allocated
     * @param outgoingHandler - An async function scheduled to be
     *                                          triggered when a buffer fully filled
     *                                          with stream data
     * @param concurrency - Concurrency of executing outgoingHandlers (greater than 0)
     * @param encoding - [Optional] Encoding of Readable stream when it's a string stream
     */
    constructor(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
        /**
         * An internal event emitter.
         */
        this.emitter = new events.EventEmitter();
        /**
         * An internal offset marker to track data offset in bytes of next outgoingHandler.
         */
        this.offset = 0;
        /**
         * An internal marker to track whether stream is end.
         */
        this.isStreamEnd = false;
        /**
         * An internal marker to track whether stream or outgoingHandler returns error.
         */
        this.isError = false;
        /**
         * How many handlers are executing.
         */
        this.executingOutgoingHandlers = 0;
        /**
         * How many buffers have been allocated.
         */
        this.numBuffers = 0;
        /**
         * Because this class doesn't know how much data every time stream pops, which
         * is defined by highWaterMarker of the stream. So BufferScheduler will cache
         * data received from the stream, when data in unresolvedDataArray exceeds the
         * blockSize defined, it will try to concat a blockSize of buffer, fill into available
         * buffers from incoming and push to outgoing array.
         */
        this.unresolvedDataArray = [];
        /**
         * How much data consisted in unresolvedDataArray.
         */
        this.unresolvedLength = 0;
        /**
         * The array includes all the available buffers can be used to fill data from stream.
         */
        this.incoming = [];
        /**
         * The array (queue) includes all the buffers filled from stream data.
         */
        this.outgoing = [];
        if (bufferSize <= 0) {
            throw new RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
        }
        if (maxBuffers <= 0) {
            throw new RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
        }
        if (concurrency <= 0) {
            throw new RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
        }
        this.bufferSize = bufferSize;
        this.maxBuffers = maxBuffers;
        this.readable = readable;
        this.outgoingHandler = outgoingHandler;
        this.concurrency = concurrency;
        this.encoding = encoding;
    }
    /**
     * Start the scheduler, will return error when stream of any of the outgoingHandlers
     * returns error.
     *
     */
    async do() {
        return new Promise((resolve, reject) => {
            this.readable.on("data", (data) => {
                data = typeof data === "string" ? Buffer.from(data, this.encoding) : data;
                this.appendUnresolvedData(data);
                if (!this.resolveData()) {
                    this.readable.pause();
                }
            });
            this.readable.on("error", (err) => {
                this.emitter.emit("error", err);
            });
            this.readable.on("end", () => {
                this.isStreamEnd = true;
                this.emitter.emit("checkEnd");
            });
            this.emitter.on("error", (err) => {
                this.isError = true;
                this.readable.pause();
                reject(err);
            });
            this.emitter.on("checkEnd", () => {
                if (this.outgoing.length > 0) {
                    this.triggerOutgoingHandlers();
                    return;
                }
                if (this.isStreamEnd && this.executingOutgoingHandlers === 0) {
                    if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
                        this.outgoingHandler(this.shiftBufferFromUnresolvedDataArray(), this.offset)
                            .then(resolve)
                            .catch(reject);
                    }
                    else if (this.unresolvedLength >= this.bufferSize) {
                        return;
                    }
                    else {
                        resolve();
                    }
                }
            });
        });
    }
    /**
     * Insert a new data into unresolved array.
     *
     * @param data -
     */
    appendUnresolvedData(data) {
        this.unresolvedDataArray.push(data);
        this.unresolvedLength += data.length;
    }
    /**
     * Try to shift a buffer with size in blockSize. The buffer returned may be less
     * than blockSize when data in unresolvedDataArray is less than bufferSize.
     *
     */
    shiftBufferFromUnresolvedDataArray() {
        if (this.unresolvedLength >= this.bufferSize) {
            if (this.bufferSize === this.unresolvedDataArray[0].length) {
                this.unresolvedLength -= this.bufferSize;
                return this.unresolvedDataArray.shift();
            }
            // Lazy concat because Buffer.concat highly drops performance
            let merged = Buffer.concat(this.unresolvedDataArray, this.unresolvedLength);
            const buffer = merged.slice(0, this.bufferSize);
            merged = merged.slice(this.bufferSize);
            this.unresolvedDataArray = [merged];
            this.unresolvedLength -= buffer.length;
            return buffer;
        }
        else if (this.unresolvedLength > 0) {
            const merged = Buffer.concat(this.unresolvedDataArray, this.unresolvedLength);
            this.unresolvedDataArray = [];
            this.unresolvedLength = 0;
            return merged;
        }
        else {
            return Buffer.allocUnsafe(0);
        }
    }
    /**
     * Resolve data in unresolvedDataArray. For every buffer with size in blockSize
     * shifted, it will try to get (or allocate a buffer) from incoming, and fill it,
     * then push it into outgoing to be handled by outgoing handler.
     *
     * Return false when available buffers in incoming are not enough, else true.
     *
     * @returns Return false when buffers in incoming are not enough, else true.
     */
    resolveData() {
        while (this.unresolvedLength >= this.bufferSize) {
            let buffer;
            if (this.incoming.length > 0) {
                buffer = this.incoming.shift();
            }
            else {
                if (this.numBuffers < this.maxBuffers) {
                    buffer = Buffer.allocUnsafe(this.bufferSize);
                    this.numBuffers++;
                }
                else {
                    // No available buffer, wait for buffer returned
                    return false;
                }
            }
            buffer.fill(this.shiftBufferFromUnresolvedDataArray());
            this.outgoing.push(buffer);
            this.triggerOutgoingHandlers();
        }
        return true;
    }
    /**
     * Try to trigger a outgoing handler for every buffer in outgoing. Stop when
     * concurrency reaches.
     */
    async triggerOutgoingHandlers() {
        let buffer;
        do {
            if (this.executingOutgoingHandlers >= this.concurrency) {
                return;
            }
            buffer = this.outgoing.shift();
            if (buffer) {
                this.triggerOutgoingHandler(buffer);
            }
        } while (buffer);
    }
    /**
     * Trigger a outgoing handler for a buffer shifted from outgoing.
     *
     * @param buffer -
     */
    async triggerOutgoingHandler(buffer) {
        const bufferLength = buffer.length;
        this.executingOutgoingHandlers++;
        this.offset += bufferLength;
        try {
            await this.outgoingHandler(buffer, this.offset - bufferLength);
        }
        catch (err) {
            this.emitter.emit("error", err);
            return;
        }
        this.executingOutgoingHandlers--;
        this.reuseBuffer(buffer);
        this.emitter.emit("checkEnd");
    }
    /**
     * Return buffer used by outgoing handler into incoming.
     *
     * @param buffer -
     */
    reuseBuffer(buffer) {
        this.incoming.push(buffer);
        if (!this.isError && this.resolveData() && !this.isStreamEnd) {
            this.readable.resume();
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Reads a readable stream into buffer. Fill the buffer from offset to end.
 *
 * @param stream - A Node.js Readable stream
 * @param buffer - Buffer to be filled, length must greater than or equal to offset
 * @param offset - From which position in the buffer to be filled, inclusive
 * @param end - To which position in the buffer to be filled, exclusive
 * @param encoding - Encoding of the Readable stream
 */
async function streamToBuffer(stream, buffer, offset, end, encoding) {
    let pos = 0; // Position in stream
    const count = end - offset; // Total amount of data needed in stream
    return new Promise((resolve, reject) => {
        stream.on("readable", () => {
            if (pos >= count) {
                resolve();
                return;
            }
            let chunk = stream.read();
            if (!chunk) {
                return;
            }
            if (typeof chunk === "string") {
                chunk = Buffer.from(chunk, encoding);
            }
            // How much data needed in this chunk
            const chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
            buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength);
            pos += chunkLength;
        });
        stream.on("end", () => {
            if (pos < count) {
                reject(new Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
            }
            resolve();
        });
        stream.on("error", reject);
    });
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Writes the content of a readstream to a local file. Returns a Promise which is completed after the file handle is closed.
 *
 * @param rs - The read stream.
 * @param file - Destination file path.
 */
async function readStreamToLocalFile(rs, file) {
    return new Promise((resolve, reject) => {
        const ws = fs.createWriteStream(file);
        rs.on("error", (err) => {
            reject(err);
        });
        ws.on("error", (err) => {
            reject(err);
        });
        ws.on("close", resolve);
        rs.pipe(ws);
    });
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Promisified version of fs.stat().
 */
const fsStat = util.promisify(fs.stat);
const fsCreateReadStream = fs.createReadStream;

// Copyright (c) Microsoft Corporation.
/**
 * A ShareClient represents a URL to the Azure Storage share allowing you to manipulate its directories and files.
 */
class ShareClient extends StorageClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrShareName, 
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */
    options) {
        let pipeline;
        let url;
        if (credentialOrPipelineOrShareName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrShareName;
        }
        else if (credentialOrPipelineOrShareName instanceof Credential) {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = newPipeline(credentialOrPipelineOrShareName, options);
        }
        else if (!credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName !== "string") {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName === "string") {
            // (connectionString: string, name: string, options?: StoragePipelineOptions)
            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            const name = credentialOrPipelineOrShareName;
            if (extractedCreds.kind === "AccountConnString") {
                {
                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(extractedCreds.url, name);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url = appendToURLPath(extractedCreds.url, name) + "?" + extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for name parameter");
        }
        super(url, pipeline);
        this._name = getShareNameAndPathFromUrl(this.url).shareName;
        this.context = new Share(this.storageClientContext);
    }
    /**
     * The name of the share
     */
    get name() {
        return this._name;
    }
    /**
     * Creates a new ShareClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base share.
     *
     * @param snapshot - The snapshot timestamp.
     * @returns A new ShareClient object identical to the source but with the specified snapshot timestamp
     */
    withSnapshot(snapshot) {
        return new ShareClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    }
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, the operation fails.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options - Options to Share Create operation.
     * @returns Response data for the Share Create operation.
     */
    async create(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-create", options);
        try {
            return await this.context.create(Object.assign(Object.assign(Object.assign({}, options), { enabledProtocols: toShareProtocolsString(options.protocols) }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, it is not changed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options -
     */
    async createIfNotExists(options = {}) {
        var _a, _b;
        const { span, updatedOptions } = createSpan("ShareClient-createIfNotExists", options);
        try {
            const res = await this.create(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ShareAlreadyExists") {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: "Expected exception when creating a share only if it doesn't already exist."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a {@link ShareDirectoryClient} object.
     *
     * @param directoryName - A directory name
     * @returns The ShareDirectoryClient object for the given directory name.
     */
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */
    getDirectoryClient(directoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);
    }
    /**
     * Gets the directory client for the root directory of this share.
     * Note that the root directory always exists and cannot be deleted.
     *
     * @readonly A new ShareDirectoryClient object for the root directory.
     */
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */
    get rootDirectoryClient() {
        return this.getDirectoryClient("");
    }
    /**
     * Creates a new subdirectory under this share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory creation response data and the corresponding directory client.
     */
    async createDirectory(directoryName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-createDirectory", options);
        try {
            const directoryClient = this.getDirectoryClient(directoryName);
            const directoryCreateResponse = await directoryClient.create(updatedOptions);
            return {
                directoryClient,
                directoryCreateResponse
            };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified empty sub directory under this share.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    async deleteDirectory(directoryName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-deleteDirectory", options);
        try {
            const directoryClient = this.getDirectoryClient(directoryName);
            return await directoryClient.delete(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new file or replaces a file under the root directory of this share.
     * Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    async createFile(fileName, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-createFile", options);
        try {
            const directoryClient = this.rootDirectoryClient;
            const fileClient = directoryClient.getFileClient(fileName);
            const fileCreateResponse = await fileClient.create(size, updatedOptions);
            return {
                fileClient,
                fileCreateResponse
            };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes a file under the root directory of this share from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code `SharingViolation`
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400
     * (`InvalidQueryParameterValue`)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param directoryName -
     * @param fileName -
     * @param options - Options to File Delete operation.
     * @returns Promise<FileDeleteResponse> File Delete response data.
     */
    async deleteFile(fileName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-deleteFile", options);
        try {
            const directoryClient = this.rootDirectoryClient;
            const fileClient = directoryClient.getFileClient(fileName);
            return await fileClient.delete(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns true if the Azrue share resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing share might be deleted by other clients or
     * applications. Vice versa new shares might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    async exists(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-exists", options);
        try {
            await this.getProperties(updatedOptions);
            return true;
        }
        catch (e) {
            if (e.statusCode === 404) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: "Expected exception when checking share existence"
                });
                return false;
            }
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns all user-defined metadata and system properties for the specified
     * share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listShares` method of {@link ShareServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @returns Response data for the Share Get Properties operation.
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-getProperties", options);
        try {
            const res = await this.context.getProperties(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
            // parse protocols
            const protocols = toShareProtocols(res.enabledProtocols);
            res.protocols = protocols;
            return res;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Marks the specified share for deletion. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options - Options to Share Delete operation.
     * @returns Response data for the Share Delete operation.
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-delete", options);
        try {
            return await this.context.delete(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Marks the specified share for deletion if it exists. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options -
     */
    async deleteIfExists(options = {}) {
        var _a, _b;
        const { span, updatedOptions } = createSpan("ShareClient-deleteIfExists", options);
        try {
            const res = await this.delete(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ShareNotFound") {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: "Expected exception when deleting a share only if it exists."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     *
     * If no option provided, or no metadata defined in the option parameter, the share
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed.
     * @param option - Options to Share Set Metadata operation.
     * @returns Response data for the Share Set Metadata operation.
     */
    async setMetadata(metadata, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-setMetadata", options);
        try {
            return await this.context.setMetadata(Object.assign(Object.assign(Object.assign({}, options), { metadata }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Gets the permissions for the specified share. The permissions indicate
     * whether share data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-acl
     *
     * @param option - Options to Share Get Access Policy operation.
     * @returns Response data for the Share Get Access Policy operation.
     */
    async getAccessPolicy(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-getAccessPolicy", options);
        try {
            const response = await this.context.getAccessPolicy(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
            const res = {
                _response: response._response,
                date: response.date,
                etag: response.etag,
                lastModified: response.lastModified,
                requestId: response.requestId,
                signedIdentifiers: [],
                version: response.version
            };
            for (const identifier of response) {
                let accessPolicy = undefined;
                if (identifier.accessPolicy) {
                    accessPolicy = {
                        permissions: identifier.accessPolicy.permissions
                    };
                    if (identifier.accessPolicy.expiresOn) {
                        accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
                    }
                    if (identifier.accessPolicy.startsOn) {
                        accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
                    }
                }
                res.signedIdentifiers.push({
                    accessPolicy,
                    id: identifier.id
                });
            }
            return res;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets the permissions for the specified share. The permissions indicate
     * whether directories or files in a share may be accessed publicly.
     *
     * When you set permissions for a share, the existing permissions are replaced.
     * If no shareAcl provided, the existing share ACL will be
     * removed.
     *
     * When you establish a stored access policy on a share, it may take up to 30 seconds to take effect.
     * During this interval, a shared access signature that is associated with the stored access policy will
     * fail with status code 403 (Forbidden), until the access policy becomes active.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
     *
     * @param shareAcl - Array of signed identifiers, each having a unique Id and details of access policy.
     * @param option - Options to Share Set Access Policy operation.
     * @returns Response data for the Share Set Access Policy operation.
     */
    async setAccessPolicy(shareAcl, options = {}) {
        var _a, _b, _c;
        const { span, updatedOptions } = createSpan("ShareClient-setAccessPolicy", options);
        try {
            const acl = [];
            for (const identifier of shareAcl || []) {
                acl.push({
                    accessPolicy: {
                        expiresOn: ((_a = identifier.accessPolicy) === null || _a === void 0 ? void 0 : _a.expiresOn)
                            ? truncatedISO8061Date(identifier.accessPolicy.expiresOn)
                            : undefined,
                        permissions: (_b = identifier.accessPolicy) === null || _b === void 0 ? void 0 : _b.permissions,
                        startsOn: ((_c = identifier.accessPolicy) === null || _c === void 0 ? void 0 : _c.startsOn)
                            ? truncatedISO8061Date(identifier.accessPolicy.startsOn)
                            : undefined
                    },
                    id: identifier.id
                });
            }
            return await this.context.setAccessPolicy(Object.assign(Object.assign(Object.assign({}, options), { shareAcl: acl }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a read-only snapshot of a share.
     *
     * @param options - Options to Share Create Snapshot operation.
     * @returns Response data for the Share Create Snapshot operation.
     */
    async createSnapshot(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-createSnapshot", options);
        try {
            return await this.context.createSnapshot(Object.assign(Object.assign({ abortSignal: options.abortSignal }, options), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets quota for the specified share.
     *
     * @deprecated Use {@link ShareClient.setProperties} instead.
     *
     * @param quotaInGB - Specifies the maximum size of the share in gigabytes
     * @param option - Options to Share Set Quota operation.
     * @returns Response data for the Share Get Quota operation.
     */
    async setQuota(quotaInGB, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-setQuota", options);
        try {
            return await this.context.setProperties(Object.assign(Object.assign(Object.assign({}, options), { quota: quotaInGB }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets properties of the share.
     *
     * @param option - Options to Share Set Properties operation.
     * @returns Response data for the Share Set Properties operation.
     */
    async setProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-setProperties", options);
        try {
            return await this.context.setProperties(Object.assign(Object.assign({}, options), { quota: options.quotaInGB, tracingOptions: updatedOptions.tracingOptions }));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves statistics related to the share.
     *
     * @param option - Options to Share Get Statistics operation.
     * @returns Response data for the Share Get Statistics operation.
     */
    async getStatistics(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-getStatistics", options);
        try {
            const response = await this.context.getStatistics(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
            const GBBytes = 1024 * 1024 * 1024;
            return Object.assign(Object.assign({}, response), { shareUsage: Math.ceil(response.shareUsageBytes / GBBytes) });
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a file permission (a security descriptor) at the share level.
     * The created security descriptor can be used for the files/directories in the share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermission - File permission described in the SDDL
     */
    async createPermission(filePermission, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-createPermission", options);
        try {
            return await this.context.createPermission({
                permission: filePermission
            }, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Gets the Security Descriptor Definition Language (SDDL) for a given file permission key
     * which indicates a security descriptor.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermissionKey - File permission key which indicates the security descriptor of the permission.
     */
    async getPermission(filePermissionKey, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-getPermission", options);
        try {
            return await this.context.getPermission(filePermissionKey, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Only available for ShareClient constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateSasUrl(options) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateFileSASQueryParameters(Object.assign({ shareName: this.name }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    }
}
/**
 * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.
 */
class ShareDirectoryClient extends StorageClient {
    constructor(url, credentialOrPipeline, options = {}) {
        let pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        super(url, pipeline);
        ({
            baseName: this._name,
            shareName: this._shareName,
            path: this._path
        } = getShareNameAndPathFromUrl(this.url));
        this.context = new Directory(this.storageClientContext);
    }
    /**
     * The share name corresponding to this directory client
     */
    get shareName() {
        return this._shareName;
    }
    /**
     * The full path of the directory
     */
    get path() {
        return this._path;
    }
    /**
     * The name of the directory
     */
    get name() {
        return this._name;
    }
    /**
     * Creates a new directory under the specified share or parent directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options - Options to Directory Create operation.
     * @returns Response data for the Directory  operation.
     */
    async create(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-create", options);
        try {
            if (!options.fileAttributes) {
                options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                // By default set it as a directory.
                const attributes = new FileSystemAttributes();
                attributes.directory = true;
                options.fileAttributes = attributes;
            }
            return await this.context.create(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), Object.assign({ abortSignal: options.abortSignal, metadata: options.metadata, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new directory under the specified share or parent directory if it does not already exists.
     * If the directory already exists, it is not modified.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options -
     */
    async createIfNotExists(options = {}) {
        var _a, _b;
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-createIfNotExists", options);
        try {
            const res = await this.create(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceAlreadyExists") {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: "Expected exception when creating a directory only if it does not already exist."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets properties on the directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties
     *
     * @param DirectoryProperties - Directory properties. If no values are provided,
     *                                            existing values will be preserved.
     */
    async setProperties(properties = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-setProperties", properties);
        try {
            properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
            return await this.context.setProperties(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), Object.assign({ abortSignal: properties.abortSignal, filePermission: properties.filePermission, filePermissionKey: properties.filePermissionKey }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a ShareDirectoryClient object for a sub directory.
     *
     * @param subDirectoryName - A subdirectory name
     * @returns The ShareDirectoryClient object for the given subdirectory name.
     *
     * Example usage:
     *
     * ```js
     * const directoryClient = shareClient.getDirectoryClient("<directory name>");
     * await directoryClient.create();
     * console.log("Created directory successfully");
     * ```
     */
    getDirectoryClient(subDirectoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(subDirectoryName)), this.pipeline);
    }
    /**
     * Creates a new subdirectory under this directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory create response data and the corresponding DirectoryClient instance.
     */
    async createSubdirectory(directoryName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-createSubdirectory", options);
        try {
            const directoryClient = this.getDirectoryClient(directoryName);
            const directoryCreateResponse = await directoryClient.create(updatedOptions);
            return {
                directoryClient,
                directoryCreateResponse
            };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified empty sub directory under this directory.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    async deleteSubdirectory(directoryName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-deleteSubdirectory", options);
        try {
            const directoryClient = this.getDirectoryClient(directoryName);
            return await directoryClient.delete(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    async createFile(fileName, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-createFile", options);
        try {
            const fileClient = this.getFileClient(fileName);
            const fileCreateResponse = await fileClient.create(size, updatedOptions);
            return {
                fileClient,
                fileCreateResponse
            };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified file under this directory from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param fileName - Name of the file to delete
     * @param options - Options to File Delete operation.
     * @returns File deletion response data.
     */
    async deleteFile(fileName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-deleteFile", options);
        try {
            const fileClient = this.getFileClient(fileName);
            return await fileClient.delete(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a {@link ShareFileClient} object.
     *
     * @param fileName - A file name.
     * @returns A new ShareFileClient object for the given file name.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!"
     *
     * const fileClient = directoryClient.getFileClient("<file name>");
     *
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */
    getFileClient(fileName) {
        return new ShareFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    }
    /**
     * Returns true if the specified directory exists; false otherwise.
     *
     * NOTE: use this function with care since an existing directory might be deleted by other clients or
     * applications. Vice versa new directories might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    async exists(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-exists", options);
        try {
            await this.getProperties({
                abortSignal: options.abortSignal,
                tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
            });
            return true;
        }
        catch (e) {
            if (e.statusCode === 404) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: "Expected exception when checking directory existence"
                });
                return false;
            }
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties
     *
     * @param options - Options to Directory Get Properties operation.
     * @returns Response data for the Directory Get Properties operation.
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-getProperties", options);
        try {
            return await this.context.getProperties(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options - Options to Directory Delete operation.
     * @returns Response data for the Directory Delete operation.
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-delete", options);
        try {
            return await this.context.delete(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified empty directory if it exists. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options -
     */
    async deleteIfExists(options = {}) {
        var _a, _b, _c;
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-deleteIfExists", options);
        try {
            const res = await this.delete(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceNotFound" ||
                ((_b = e.details) === null || _b === void 0 ? void 0 : _b.errorCode) === "ParentNotFound") {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: "Expected exception when deleting a directory only if it exists."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_c = e.response) === null || _c === void 0 ? void 0 : _c.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates user defined metadata for the specified directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to Directory Set Metadata operation.
     * @returns Response data for the Directory Set Metadata operation.
     */
    async setMetadata(metadata, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-setMetadata", options);
        try {
            return await this.context.setMetadata(Object.assign({ abortSignal: options.abortSignal, metadata }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListFilesAndDirectoriesSegmentResponse} objects
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of files and directories to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all files and directories remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list files and directories operation.
     */
    iterateFilesAndDirectoriesSegments(marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* iterateFilesAndDirectoriesSegments_1() {
            if (options.prefix === "") {
                options.prefix = undefined;
            }
            let listFilesAndDirectoriesResponse;
            do {
                listFilesAndDirectoriesResponse = yield tslib.__await(this.listFilesAndDirectoriesSegment(marker, options));
                marker = listFilesAndDirectoriesResponse.continuationToken;
                yield yield tslib.__await(yield tslib.__await(listFilesAndDirectoriesResponse));
            } while (marker);
        });
    }
    /**
     * Returns an AsyncIterableIterator for file and directory items
     *
     * @param options - Options to list files and directories operation.
     */
    listFilesAndDirectoriesItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listFilesAndDirectoriesItems_1() {
            var e_1, _a;
            if (options.prefix === "") {
                options.prefix = undefined;
            }
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.iterateFilesAndDirectoriesSegments(marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const listFilesAndDirectoriesResponse = _c.value;
                    for (const file of listFilesAndDirectoriesResponse.segment.fileItems) {
                        yield yield tslib.__await(Object.assign({ kind: "file" }, file));
                    }
                    for (const directory of listFilesAndDirectoriesResponse.segment.directoryItems) {
                        yield yield tslib.__await(Object.assign({ kind: "directory" }, directory));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the files and directories
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the files and directories in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const entity of directoryClient.listFilesAndDirectories()) {
     *   if (entity.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.name}`);
     *   }
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = directoryClient.listFilesAndDirectories();
     * let entity = await iter.next();
     * while (!entity.done) {
     *   if (entity.value.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.value.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.value.name}`);
     *   }
     *   entity = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const fileItem of response.segment.fileItems) {
     *     console.log(`${i++} - file\t: ${fileItem.name}`);
     *   }
     *   for (const dirItem of response.segment.directoryItems) {
     *     console.log(`${i++} - directory\t: ${dirItem.name}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 3 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     *
     * // Gets next marker
     * let dirMarker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ continuationToken: dirMarker, maxPageSize: 4 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     * ```
     *
     * @param options - Options to list files and directories operation.
     * @returns An asyncIterableIterator that supports paging.
     */
    listFilesAndDirectories(options = {}) {
        const include = [];
        if (options.includeTimestamps) {
            include.push("Timestamps");
        }
        if (options.includeEtag) {
            include.push("Etag");
        }
        if (options.includeAttributes) {
            include.push("Attributes");
        }
        if (options.includePermissionKey) {
            include.push("PermissionKey");
        }
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        const updatedOptions = Object.assign(Object.assign({}, options), (include.length > 0 ? { include: include } : {}));
        // AsyncIterableIterator to iterate over files and directories
        const iter = this.listFilesAndDirectoriesItems(updatedOptions);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            async next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                return this.iterateFilesAndDirectoriesSegments(settings.continuationToken, Object.assign({ maxResults: settings.maxPageSize }, updatedOptions));
            }
        };
    }
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the
     * contents only for a single level of the directory hierarchy.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files
     *
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to Directory List Files and Directories Segment operation.
     * @returns Response data for the Directory List Files and Directories operation.
     */
    async listFilesAndDirectoriesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-listFilesAndDirectoriesSegment", options);
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        try {
            return await this.context.listFilesAndDirectoriesSegment(Object.assign(Object.assign({ marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListHandlesResponse}
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    iterateHandleSegments(marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* iterateHandleSegments_1() {
            let listHandlesResponse;
            if (!!marker || marker === undefined) {
                do {
                    listHandlesResponse = yield tslib.__await(this.listHandlesSegment(marker, options));
                    marker = listHandlesResponse.continuationToken;
                    yield yield tslib.__await(yield tslib.__await(listHandlesResponse));
                } while (marker);
            }
        });
    }
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    listHandleItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listHandleItems_1() {
            var e_2, _a;
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.iterateHandleSegments(marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const listHandlesResponse = _c.value;
                    if (listHandlesResponse.handleList) {
                        for (const handle of listHandlesResponse.handleList) {
                            yield yield tslib.__await(handle);
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * for await (const handle of iter) {
     *   console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * let handleItem = await iter.next();
     * while (!handleItem.done) {
     *   console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);
     *   handleItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {
     *   if (response.handleList) {
     *     for (const handle of response.handleList) {
     *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });
     * let response = await iterator.next();
     *
     * // Prints 2 handles
     * if (response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.value.continuationToken;
     *
     * // Passing next marker as continuationToken
     * console.log(`    continuation`);
     * iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = await iterator.next();
     *
     * // Prints 2 more handles assuming you have more than four directory/files opened
     * if (!response.done && response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    listHandles(options = {}) {
        // an AsyncIterableIterator to iterate over handles
        const iter = this.listHandleItems(options);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            async next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                return this.iterateHandleSegments(settings.continuationToken, Object.assign({ maxResults: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Lists handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    async listHandlesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-listHandlesSegment", options);
        try {
            marker = marker === "" ? undefined : marker;
            const response = await this.context.listHandles(Object.assign(Object.assign({ marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));
            // TODO: Protocol layer issue that when handle list is in returned XML
            // response.handleList is an empty string
            if (response.handleList === "") {
                response.handleList = undefined;
            }
            return response;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options -
     */
    async forceCloseHandlesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-forceCloseHandlesSegment", options);
        try {
            marker = marker === "" ? undefined : marker;
            const rawResponse = await this.context.forceCloseHandles("*", Object.assign(Object.assign({ marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));
            const response = rawResponse;
            response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
            response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options -
     */
    async forceCloseAllHandles(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-forceCloseAllHandles", options);
        try {
            let handlesClosed = 0;
            let numberOfHandlesFailedToClose = 0;
            let marker = "";
            do {
                const response = await this.forceCloseHandlesSegment(marker, updatedOptions);
                marker = response.marker;
                if (response.closedHandlesCount) {
                    handlesClosed += response.closedHandlesCount;
                }
                if (response.closeFailureCount) {
                    numberOfHandlesFailedToClose += response.closeFailureCount;
                }
            } while (marker);
            return { closedHandlesCount: handlesClosed, closeFailureCount: numberOfHandlesFailedToClose };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close a specific handle for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param aborter - Create a new Aborter instance with Aborter.none or Aborter.timeout(),
     *                          goto documents of Aborter for more examples about request cancellation
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseHandlesSegment() to close all handles.
     * @param options -
     */
    async forceCloseHandle(handleId, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-forceCloseHandle", options);
        try {
            if (handleId === "*") {
                throw new RangeError(`Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.`);
            }
            const rawResponse = await this.context.forceCloseHandles(handleId, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
            const response = rawResponse;
            response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
            response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
}
/**
 * A ShareFileClient represents a URL to an Azure Storage file.
 */
class ShareFileClient extends StorageClient {
    constructor(url, credentialOrPipeline, 
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */
    options) {
        let pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        super(url, pipeline);
        ({
            baseName: this._name,
            shareName: this._shareName,
            path: this._path
        } = getShareNameAndPathFromUrl(this.url));
        this.context = new File(this.storageClientContext);
    }
    /**
     * The share name corresponding to this file client
     */
    get shareName() {
        return this._shareName;
    }
    /**
     * The full path of the file
     */
    get path() {
        return this._path;
    }
    /**
     * The name of the file
     */
    get name() {
        return this._name;
    }
    /**
     * Creates a new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base ShareFileClient.
     *
     * @param shareSnapshot - The share snapshot timestamp.
     * @returns A new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     */
    withShareSnapshot(shareSnapshot) {
        return new ShareFileClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, shareSnapshot.length === 0 ? undefined : shareSnapshot), this.pipeline);
    }
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns Response data for the File Create  operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    async create(size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-create", options);
        try {
            if (size < 0 || size > FILE_MAX_SIZE_BYTES) {
                throw new RangeError(`File size must >= 0 and < ${FILE_MAX_SIZE_BYTES}.`);
            }
            options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
            if (!options.fileAttributes) {
                // Note: It would be Archive in service side if None is set.
                const attributes = new FileSystemAttributes();
                attributes.none = true;
                options.fileAttributes = attributes;
            }
            options.fileHttpHeaders = options.fileHttpHeaders || {};
            return await this.context.create(size, fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), Object.assign({ abortSignal: options.abortSignal, fileHttpHeaders: options.fileHttpHeaders, metadata: options.metadata, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream `readableStreamBody`
     * * In browsers, data returns in a promise `contentAsBlob`
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file
     *
     * @param offset - From which position of the file to download, greater than or equal to 0
     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
     * @param options - Options to File Download operation.
     * @returns Response data for the File Download operation.
     *
     * Example usage (Node.js):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download();
     * console.log(
     *   "Downloaded file content:",
     *   (await streamToBuffer(downloadFileResponse.readableStreamBody)).toString()}
     * );
     *
     * // A helper method used to read a Node.js readable stream into string
     * async function streamToBuffer(readableStream) {
     *   return new Promise((resolve, reject) => {
     *     const chunks = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));
     *     });
     *     readableStream.on("end", () => {
     *       resolve(Buffer.concat(chunks));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * Example usage (browsers):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download(0);
     * console.log(
     *   "Downloaded file content:",
     *   await blobToString(await downloadFileResponse.blobBody)}
     * );
     *
     * // A helper method used to convert a browser Blob into string.
     * export async function blobToString(blob: Blob): Promise<string> {
     *   const fileReader = new FileReader();
     *   return new Promise<string>((resolve, reject) => {
     *     fileReader.onloadend = (ev: any) => {
     *       resolve(ev.target!.result);
     *     };
     *     fileReader.onerror = reject;
     *     fileReader.readAsText(blob);
     *   });
     * }
     * ```
     */
    async download(offset = 0, count, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-download", options);
        try {
            if (options.rangeGetContentMD5 && offset === 0 && count === undefined) {
                throw new RangeError(`rangeGetContentMD5 only works with partial data downloading`);
            }
            const downloadFullFile = offset === 0 && !count;
            const res = await this.context.download(Object.assign({ abortSignal: options.abortSignal, requestOptions: {
                    onDownloadProgress: coreHttp.isNode ? undefined : options.onProgress // for Node.js, progress is reported by RetriableReadableStream
                }, range: downloadFullFile ? undefined : rangeToString({ offset, count }), rangeGetContentMD5: options.rangeGetContentMD5, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
            // Return browser response immediately
            if (!coreHttp.isNode) {
                return res;
            }
            // We support retrying when download stream unexpected ends in Node.js runtime
            // Following code shouldn't be bundled into browser build, however some
            // bundlers may try to bundle following code and "FileReadResponse.ts".
            // In this case, "FileDownloadResponse.browser.ts" will be used as a shim of "FileDownloadResponse.ts"
            // The config is in package.json "browser" field
            if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
                // TODO: Default value or make it a required parameter?
                options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
            }
            if (res.contentLength === undefined) {
                throw new RangeError(`File download response doesn't contain valid content length header`);
            }
            return new FileDownloadResponse(res, async (start) => {
                const updatedDownloadOptions = {
                    range: rangeToString({
                        count: offset + res.contentLength - start,
                        offset: start
                    })
                };
                // Debug purpose only
                // console.log(
                //   `Read from internal stream, range: ${
                //     chunkDownloadOptions.range
                //   }, options: ${JSON.stringify(chunkDownloadOptions)}`
                // );
                const downloadRes = await this.context.download(Object.assign(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, updatedDownloadOptions), convertTracingToRequestOptionsBase(updatedDownloadOptions)));
                if (!(downloadRes.etag === res.etag)) {
                    throw new Error("File has been modified concurrently");
                }
                return downloadRes.readableStreamBody;
            }, offset, res.contentLength, {
                abortSignal: options.abortSignal,
                maxRetryRequests: options.maxRetryRequests,
                onProgress: options.onProgress
            });
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns true if the specified file exists; false otherwise.
     *
     * NOTE: use this function with care since an existing file might be deleted by other clients or
     * applications. Vice versa new files might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    async exists(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-exists", options);
        try {
            await this.getProperties({
                abortSignal: options.abortSignal,
                tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
            });
            return true;
        }
        catch (e) {
            if (e.statusCode === 404) {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: "Expected exception when checking file existence"
                });
                return false;
            }
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the file. It does not return the content of the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties
     *
     * @param options - Options to File Get Properties operation.
     * @returns Response data for the File Get Properties operation.
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-getProperties", options);
        try {
            return this.context.getProperties(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets properties on the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param properties - File properties. For file HTTP headers(e.g. Content-Type),
     *                                       if no values are provided, existing HTTP headers will be removed.
     *                                       For other file properties(e.g. fileAttributes), if no values are provided,
     *                                       existing values will be preserved.
     */
    async setProperties(properties = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-setProperties", properties);
        try {
            properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
            properties.fileHttpHeaders = properties.fileHttpHeaders || {};
            return await this.context.setHttpHeaders(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), Object.assign({ abortSignal: properties.abortSignal, fileHttpHeaders: properties.fileHttpHeaders, filePermission: properties.filePermission, filePermissionKey: properties.filePermissionKey, leaseAccessConditions: properties.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the file from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options - Options to File Delete operation.
     * @returns Response data for the File Delete operation.
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-delete", options);
        try {
            return await this.context.delete(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the file from the storage account if it exists.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options -
     */
    async deleteIfExists(options = {}) {
        var _a, _b, _c;
        const { span, updatedOptions } = createSpan("ShareFileClient-deleteIfExists", options);
        try {
            const res = await this.delete(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceNotFound" ||
                ((_b = e.details) === null || _b === void 0 ? void 0 : _b.errorCode) === "ParentNotFound") {
                span.setStatus({
                    code: coreTracing.SpanStatusCode.ERROR,
                    message: "Expected exception when deleting a file only if it exists."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_c = e.response) === null || _c === void 0 ? void 0 : _c.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets HTTP headers on the file.
     *
     * If no option provided, or no value provided for the file HTTP headers in the options,
     * these file HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param FileHttpHeaders - File HTTP headers like Content-Type.
     *                                             Provide undefined will remove existing HTTP headers.
     * @param options - Options to File Set HTTP Headers operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    async setHttpHeaders(fileHttpHeaders = {}, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-setHTTPHeaders", options);
        try {
            // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved
            options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
            return await this.context.setHttpHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), Object.assign({ abortSignal: options.abortSignal, fileHttpHeaders, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Resize file.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param length - Resizes a file to the specified size in bytes.
     *                        If the specified byte value is less than the current size of the file,
     *                        then all ranges above the specified byte value are cleared.
     * @param options - Options to File Resize operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    async resize(length, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-resize", options);
        try {
            if (length < 0) {
                throw new RangeError(`Size cannot less than 0 when resizing file.`);
            }
            // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved.
            options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
            return await this.context.setHttpHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), Object.assign({ abortSignal: options.abortSignal, fileContentLength: length, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates user-defined metadata for the specified file.
     *
     * If no metadata defined in the option parameter, the file
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to File Set Metadata operation.
     * @returns Response data for the File Set Metadata operation.
     */
    async setMetadata(metadata = {}, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-setMetadata", options);
        try {
            return await this.context.setMetadata(Object.assign({ abortSignal: options.abortSignal, metadata, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Upload a range of bytes to a file. This operation can only be called on an existing file.
     * It won't change the size, properties or metadata of the file.
     * Both the start and count of the range must be specified. The range can be up to 4 MB in size.
     *
     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param offset - Offset position of the destination Azure File to upload.
     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param options - Options to File Upload Range operation.
     * @returns Response data for the File Upload Range operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    async uploadRange(body, offset, contentLength, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadRange", options);
        try {
            if (offset < 0) {
                throw new RangeError(`offset must be >= 0`);
            }
            if (contentLength <= 0 || contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`contentLength must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);
            }
            if (contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`offset must be < ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);
            }
            return await this.context.uploadRange(rangeToString({ count: contentLength, offset }), "update", contentLength, Object.assign(Object.assign({ abortSignal: options.abortSignal, contentMD5: options.contentMD5, requestOptions: {
                    onUploadProgress: options.onProgress
                }, body: body }, convertTracingToRequestOptionsBase(updatedOptions)), { leaseAccessConditions: options.leaseAccessConditions }));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Upload a range of bytes to a file where the contents are read from a another file's URL.
     * The range can be up to 4 MB in size.
     *
     * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.
     * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source file.
     * @param destOffset - Offset of destination file.
     * @param count - Number of bytes to be uploaded from source file.
     * @param options - Options to configure File - Upload Range from URL operation.
     */
    async uploadRangeFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadRangeFromURL", options);
        try {
            if (sourceOffset < 0 || destOffset < 0) {
                throw new RangeError(`sourceOffset and destOffset must be >= 0`);
            }
            if (count <= 0 || count > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`count must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);
            }
            return await this.context.uploadRangeFromURL(rangeToString({ offset: destOffset, count }), sourceURL, 0, Object.assign(Object.assign({ abortSignal: options.abortSignal, sourceRange: rangeToString({ offset: sourceOffset, count }), sourceModifiedAccessConditions: options.sourceConditions, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization) }, options), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Clears the specified range and
     * releases the space used in storage for that range.
     *
     * @param offset -
     * @param contentLength -
     * @param options - Options to File Clear Range operation.
     */
    async clearRange(offset, contentLength, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-clearRange", options);
        try {
            if (offset < 0 || contentLength <= 0) {
                throw new RangeError(`offset must >= 0 and contentLength must be > 0`);
            }
            return await this.context.uploadRange(rangeToString({ count: contentLength, offset }), "clear", 0, Object.assign(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)), { leaseAccessConditions: options.leaseAccessConditions }));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns the list of valid ranges for a file.
     *
     * @param options - Options to File Get range List operation.
     */
    async getRangeList(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-getRangeList", options);
        try {
            const originalResponse = await this.context.getRangeList(Object.assign({ abortSignal: options.abortSignal, range: options.range ? rangeToString(options.range) : undefined, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
            // Only returns ranges, ignoring clearRanges.
            const parsedBody = originalResponse._response.parsedBody.ranges
                ? originalResponse._response.parsedBody.ranges
                : [];
            return Object.assign(Object.assign({}, originalResponse), { _response: Object.assign(Object.assign({}, originalResponse._response), { parsedBody }), rangeList: originalResponse.ranges ? originalResponse.ranges : [] });
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns the list of ranges that differ between a previous share snapshot and this file.
     *
     * @param prevShareSnapshot - The previous snapshot parameter is an opaque DateTime value that specifies the previous share snapshot to compare with.
     * @param options -
     */
    async getRangeListDiff(prevShareSnapshot, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-getRangeListDiff", options);
        try {
            return await this.context.getRangeList(Object.assign(Object.assign(Object.assign({ prevsharesnapshot: prevShareSnapshot }, options), { range: options.range ? rangeToString(options.range) : undefined }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Copies a blob or file to a destination file within the storage account.
     *
     * @param copySource - Specifies the URL of the source file or blob, up to 2 KB in length.
     * To copy a file to another file within the same storage account, you may use Shared Key to
     * authenticate the source file. If you are copying a file from another storage account, or if you
     * are copying a blob from the same storage account or another storage account, then you must
     * authenticate the source file or blob using a shared access signature. If the source is a public
     * blob, no authentication is required to perform the copy operation. A file in a share snapshot
     * can also be specified as a copy source.
     * @param options - Options to File Start Copy operation.
     */
    async startCopyFromURL(copySource, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-startCopyFromURL", options);
        try {
            return await this.context.startCopy(copySource, Object.assign({ abortSignal: options.abortSignal, metadata: options.metadata, leaseAccessConditions: options.leaseAccessConditions, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, copyFileSmbInfo: options.copyFileSmbInfo }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file
     *
     * @param copyId - Id of the Copy File operation to abort.
     * @param options - Options to File Abort Copy From URL operation.
     */
    async abortCopyFromURL(copyId, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-abortCopyFromURL", options);
        try {
            return await this.context.abortCopy(copyId, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    // High Level functions
    /**
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Buffer(Node)/Blob/ArrayBuffer/ArrayBufferView to it.
     *
     * @param data - Buffer(Node), Blob, ArrayBuffer or ArrayBufferView
     * @param options -
     */
    async uploadData(data, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadData", options);
        try {
            if (true) {
                let buffer;
                if (data instanceof Buffer) {
                    buffer = data;
                }
                else if (data instanceof ArrayBuffer) {
                    buffer = Buffer.from(data);
                }
                else {
                    data = data;
                    buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
                }
                return this.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);
            }
            else {
                const browserBlob = new Blob([data]);
                return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
            }
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,
     * which need to return a Blob object with the offset and size provided.
     *
     * @param blobFactory -
     * @param size -
     * @param options -
     */
    async uploadSeekableBlob(blobFactory, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-UploadSeekableBlob", options);
        try {
            return this.uploadSeekableInternal(blobFactory, size, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a local file to it.
     *
     * @param filePath - Full path of local file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    async uploadFile(filePath, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadFile", options);
        try {
            const size = (await fsStat(filePath)).size;
            return await this.uploadSeekableInternal((offset, count) => {
                return () => fsCreateReadStream(filePath, {
                    autoClose: true,
                    end: count ? offset + count - 1 : Infinity,
                    start: offset
                });
            }, size, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.
     * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset
     * is the offset in the Azure file to be uploaded.
     *
     * @param streamFactory - Returns a Node.js Readable stream starting
     *                                                                  from the offset defined
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    async uploadResetableStream(streamFactory, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadResetableStream", options);
        try {
            return await this.uploadSeekableInternal((offset, count) => {
                return () => streamFactory(offset, count);
            }, size, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     *
     * @param bodyFactory -
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    async uploadSeekableInternal(bodyFactory, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadSeekableInternal", options);
        try {
            if (!options.rangeSize) {
                options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
            }
            if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`options.rangeSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);
            }
            if (!options.fileHttpHeaders) {
                options.fileHttpHeaders = {};
            }
            if (!options.concurrency) {
                options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
            }
            if (options.concurrency < 0) {
                throw new RangeError(`options.concurrency cannot less than 0.`);
            }
            // Create the file
            await this.create(size, {
                abortSignal: options.abortSignal,
                fileHttpHeaders: options.fileHttpHeaders,
                metadata: options.metadata,
                leaseAccessConditions: options.leaseAccessConditions,
                tracingOptions: updatedOptions.tracingOptions
            });
            const numBlocks = Math.floor((size - 1) / options.rangeSize) + 1;
            let transferProgress = 0;
            const batch = new Batch(options.concurrency);
            for (let i = 0; i < numBlocks; i++) {
                batch.addOperation(async () => {
                    const start = options.rangeSize * i;
                    const end = i === numBlocks - 1 ? size : start + options.rangeSize;
                    const contentLength = end - start;
                    await this.uploadRange(bodyFactory(start, contentLength), start, contentLength, {
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.leaseAccessConditions,
                        tracingOptions: updatedOptions.tracingOptions
                    });
                    // Update progress after block is successfully uploaded to server, in case of block trying
                    transferProgress += contentLength;
                    if (options.onProgress) {
                        options.onProgress({ loadedBytes: transferProgress });
                    }
                });
            }
            return await batch.do();
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async downloadToBuffer(bufferOrOffset, offsetOrCount, countOrOptions, optOptions = {}) {
        let buffer = undefined;
        let offset;
        let count;
        let options = optOptions;
        if (bufferOrOffset instanceof Buffer) {
            buffer = bufferOrOffset;
            offset = offsetOrCount || 0;
            count = typeof countOrOptions === "number" ? countOrOptions : 0;
        }
        else {
            offset = typeof bufferOrOffset === "number" ? bufferOrOffset : 0;
            count = typeof offsetOrCount === "number" ? offsetOrCount : 0;
            options = countOrOptions || {};
        }
        const { span, updatedOptions } = createSpan("ShareFileClient-downloadToBuffer", options);
        try {
            if (!options.rangeSize) {
                options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
            }
            if (options.rangeSize < 0) {
                throw new RangeError("rangeSize option must be > 0");
            }
            if (offset < 0) {
                throw new RangeError("offset option must be >= 0");
            }
            if (count && count <= 0) {
                throw new RangeError("count option must be > 0");
            }
            if (!options.concurrency) {
                options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
            }
            if (options.concurrency < 0) {
                throw new RangeError(`options.concurrency cannot less than 0.`);
            }
            // Customer doesn't specify length, get it
            if (!count) {
                const response = await this.getProperties({
                    abortSignal: options.abortSignal,
                    leaseAccessConditions: options.leaseAccessConditions,
                    tracingOptions: updatedOptions.tracingOptions
                });
                count = response.contentLength - offset;
                if (count < 0) {
                    throw new RangeError(`offset ${offset} shouldn't be larger than file size ${response.contentLength}`);
                }
            }
            if (!buffer) {
                try {
                    buffer = Buffer.alloc(count);
                }
                catch (error) {
                    throw new Error(`Unable to allocate a buffer of size: ${count} bytes. Please try passing your own Buffer to ` +
                        'the "downloadToBuffer method or try using other methods like "download" or "downloadToFile".' +
                        `\t ${error.message}`);
                }
            }
            if (buffer.length < count) {
                throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
            }
            let transferProgress = 0;
            const batch = new Batch(options.concurrency);
            for (let off = offset; off < offset + count; off = off + options.rangeSize) {
                batch.addOperation(async () => {
                    // Exclusive chunk end position
                    let chunkEnd = offset + count;
                    if (off + options.rangeSize < chunkEnd) {
                        chunkEnd = off + options.rangeSize;
                    }
                    const response = await this.download(off, chunkEnd - off, {
                        abortSignal: options.abortSignal,
                        maxRetryRequests: options.maxRetryRequestsPerRange,
                        leaseAccessConditions: options.leaseAccessConditions,
                        tracingOptions: updatedOptions.tracingOptions
                    });
                    const stream = response.readableStreamBody;
                    await streamToBuffer(stream, buffer, off - offset, chunkEnd - offset);
                    // Update progress after block is downloaded, in case of block trying
                    // Could provide finer grained progress updating inside HTTP requests,
                    // only if convenience layer download try is enabled
                    transferProgress += chunkEnd - off;
                    if (options.onProgress) {
                        options.onProgress({ loadedBytes: transferProgress });
                    }
                });
            }
            await batch.do();
            return buffer;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Node.js Readable stream into it.
     * This method will try to create an Azure File, then starts uploading chunk by chunk.
     * Size of chunk is defined by `bufferSize` parameter.
     * Please make sure potential size of stream doesn't exceed file size.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *   parameter, which will avoid Buffer.concat() operations.
     *
     * @param stream - Node.js Readable stream. Must be less or equal than file size.
     * @param size - Size of file to be created. Maximum size allowed is 4 TB.
     *                      If this value is larger than stream size, there will be empty bytes in file tail.
     * @param bufferSize - Size of every buffer allocated in bytes, also the chunk/range size during
     *                            the uploaded file. Size must be greater than 0 and lesser than or equal to 4 * 1024 * 1024 (4MB)
     * @param maxBuffers - Max buffers will allocate during uploading, positive correlation
     *                            with max uploading concurrency
     * @param options -
     */
    async uploadStream(stream, size, bufferSize, maxBuffers, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadStream", options);
        try {
            if (!options.fileHttpHeaders) {
                options.fileHttpHeaders = {};
            }
            if (bufferSize <= 0 || bufferSize > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`bufferSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);
            }
            if (maxBuffers < 0) {
                throw new RangeError(`maxBuffers must be > 0.`);
            }
            // Create the file
            await this.create(size, {
                abortSignal: options.abortSignal,
                fileHttpHeaders: options.fileHttpHeaders,
                metadata: options.metadata,
                leaseAccessConditions: options.leaseAccessConditions,
                tracingOptions: updatedOptions.tracingOptions
            });
            let transferProgress = 0;
            const scheduler = new BufferScheduler(stream, bufferSize, maxBuffers, async (buffer, offset) => {
                if (transferProgress + buffer.length > size) {
                    throw new RangeError(`Stream size is larger than file size ${size} bytes, uploading failed. ` +
                        `Please make sure stream length is less or equal than file size.`);
                }
                await this.uploadRange(buffer, offset, buffer.length, {
                    abortSignal: options.abortSignal,
                    leaseAccessConditions: options.leaseAccessConditions,
                    tracingOptions: updatedOptions.tracingOptions
                });
                // Update progress after block is successfully uploaded to server, in case of block trying
                transferProgress += buffer.length;
                if (options.onProgress) {
                    options.onProgress({ loadedBytes: transferProgress });
                }
            }, 
            // Concurrency should set a smaller value than maxBuffers, which is helpful to
            // reduce the possibility when a outgoing handler waits for stream data, in
            // this situation, outgoing handlers are blocked.
            // Outgoing queue shouldn't be empty.
            Math.ceil((maxBuffers / 4) * 3));
            return await scheduler.do();
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param filePath -
     * @param offset - From which position of the block blob to download.
     * @param count - How much data to be downloaded. Will download to the end when passing undefined.
     * @param options - Options to Blob download options.
     * @returns The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     */
    async downloadToFile(filePath, offset = 0, count, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-downloadToFile", options);
        try {
            const response = await this.download(offset, count, updatedOptions);
            if (response.readableStreamBody) {
                await readStreamToLocalFile(response.readableStreamBody, filePath);
            }
            // The stream is no longer accessible so setting it to undefined.
            response.fileDownloadStream = undefined;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Lists handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    async listHandlesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-listHandlesSegment", options);
        try {
            marker = marker === "" ? undefined : marker;
            const response = await this.context.listHandles(Object.assign(Object.assign({ abortSignal: options.abortSignal, marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));
            // TODO: Protocol layer issue that when handle list is in returned XML
            // response.handleList is an empty string
            if (response.handleList === "") {
                response.handleList = undefined;
            }
            return response;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an AsyncIterableIterator for FileListHandlesResponse
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    iterateHandleSegments(marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* iterateHandleSegments_2() {
            let listHandlesResponse;
            if (!!marker || marker === undefined) {
                do {
                    listHandlesResponse = yield tslib.__await(this.listHandlesSegment(marker, options));
                    marker = listHandlesResponse.continuationToken;
                    yield yield tslib.__await(listHandlesResponse);
                } while (marker);
            }
        });
    }
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    listHandleItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listHandleItems_2() {
            var e_3, _a;
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.iterateHandleSegments(marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const listHandlesResponse = _c.value;
                    if (listHandlesResponse.handleList) {
                        for (const handle of listHandlesResponse.handleList) {
                            yield yield tslib.__await(handle);
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    listHandles(options = {}) {
        // an AsyncIterableIterator to iterate over handles
        const iter = this.listHandleItems(options);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            async next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                return this.iterateHandleSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options - Options to force close handles operation.
     */
    async forceCloseHandlesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-forceCloseHandlesSegment", options);
        try {
            marker = marker === "" ? undefined : marker;
            const rawResponse = await this.context.forceCloseHandles("*", Object.assign({ abortSignal: options.abortSignal, marker }, convertTracingToRequestOptionsBase(updatedOptions)));
            const response = rawResponse;
            response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
            response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options - Options to force close handles operation.
     */
    async forceCloseAllHandles(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-forceCloseAllHandles", options);
        try {
            let handlesClosed = 0;
            let numberOfHandlesFailedToClose = 0;
            let marker = "";
            do {
                const response = await this.forceCloseHandlesSegment(marker, { tracingOptions: updatedOptions.tracingOptions });
                marker = response.marker;
                if (response.closedHandlesCount) {
                    handlesClosed += response.closedHandlesCount;
                }
                if (response.closeFailureCount) {
                    numberOfHandlesFailedToClose += response.closeFailureCount;
                }
            } while (marker);
            return {
                closedHandlesCount: handlesClosed,
                closeFailureCount: numberOfHandlesFailedToClose
            };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close a specific handle for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseAllHandles() to close all handles.
     * @param FileForceCloseHandlesOptions - Options to force close handles operation.
     */
    async forceCloseHandle(handleId, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-forceCloseHandle", options);
        try {
            if (handleId === "*") {
                throw new RangeError(`Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.`);
            }
            const rawResponse = await this.context.forceCloseHandles(handleId, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
            const response = rawResponse;
            response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
            response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Get a {@link ShareLeaseClient} that manages leases on the file.
     *
     * @param proposeLeaseId - Initial proposed lease Id.
     * @returns A new ShareLeaseClient object for managing leases on the file.
     */
    getShareLeaseClient(proposeLeaseId) {
        return new ShareLeaseClient(this, proposeLeaseId);
    }
    /**
     * Only available for clients constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateSasUrl(options) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateFileSASQueryParameters(Object.assign({ shareName: this.shareName, filePath: this.path }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    }
}
/**
 * A client that manages leases for a {@link ShareFileClient} or {@link ShareClient}.
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-file
 * and
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-share
 */
class ShareLeaseClient {
    /**
     * Creates an instance of ShareLeaseClient.
     * @param client - The client to make the lease operation requests.
     * @param leaseId - Initial proposed lease id.
     */
    constructor(client, leaseId) {
        const clientContext = new StorageClientContext(client.url, Object.assign({ version: SERVICE_VERSION }, client.pipeline.toServiceClientOptions()));
        if (client instanceof ShareClient) {
            this.isShare = true;
            this.fileOrShare = new Share(clientContext);
        }
        else {
            this.isShare = false;
            this.fileOrShare = new File(clientContext);
        }
        this._url = client.url;
        if (!leaseId) {
            leaseId = coreHttp.generateUuid();
        }
        this._leaseId = leaseId;
    }
    /**
     * Gets the lease Id.
     *
     * @readonly
     */
    get leaseId() {
        return this._leaseId;
    }
    /**
     * Gets the url.
     *
     * @readonly
     */
    get url() {
        return this._url;
    }
    /**
     * Establishes and manages a lock on a file, share or share snapshot for write and delete operations.
     *
     * @param duration - Specifies the duration of lease in seconds. For file, the only allowed value is -1 for a lease that never expires. For share, must be -1 or between 15 to 60.
     * @param options - Options for the lease management operation.
     * @returns Response data for acquire lease operation.
     */
    async acquireLease(duration = -1, options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-acquireLease", options);
        try {
            return await this.fileOrShare.acquireLease(Object.assign({ abortSignal: options.abortSignal, duration, proposedLeaseId: this._leaseId }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * To change the ID of an existing lease.
     *
     * @param proposedLeaseId - the proposed new lease Id.
     * @param options - Options for the lease management operation.
     * @returns Response data for change lease operation.
     */
    async changeLease(proposedLeaseId, options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-changeLease", options);
        try {
            const response = await this.fileOrShare.changeLease(this._leaseId, Object.assign({ proposedLeaseId, abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
            this._leaseId = proposedLeaseId;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * To free the lease if it is no longer needed so that another client may
     * immediately acquire a lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for release lease operation.
     */
    async releaseLease(options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-releaseLease", options);
        try {
            return await this.fileOrShare.releaseLease(this._leaseId, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * To force end the lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for break lease operation.
     */
    async breakLease(options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-breakLease", options);
        try {
            return await this.fileOrShare.breakLease(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * To renew the lease. Only available for lease on share or share snapshot.
     * Note that the lease may be renewed even if it has expired as long as the share has not been leased again since the expiration of that lease.
     * When you renew a lease, the lease duration clock resets.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for renew lease operation.
     */
    async renewLease(options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-renewLease", options);
        if (!this.isShare) {
            throw new RangeError("The renewLease operation is not available for lease on file.");
        }
        try {
            return await this.fileOrShare.renewLease(this._leaseId, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * ShareClientInternal is the thin wrapper for Share which contains internal helper methods.
 */
class ShareClientInternal extends StorageClient {
    constructor(url, pipeline) {
        super(url, pipeline);
        this.context = new Share(this.storageClientContext);
    }
    async restore(options = {}) {
        return this.context.restore(options);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A ShareServiceClient represents a URL to the Azure Storage File service allowing you
 * to manipulate file shares.
 */
class ShareServiceClient extends StorageClient {
    constructor(url, credentialOrPipeline, 
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */
    options) {
        let pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        super(url, pipeline);
        this.serviceContext = new Service(this.storageClientContext);
    }
    /**
     *
     * Creates an instance of ShareServiceClient from connection string.
     *
     * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param options - Options to configure the HTTP pipeline.
     * @returns A new ShareServiceClient from the given connection string.
     */
    static fromConnectionString(connectionString, 
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */
    options) {
        const extractedCreds = extractConnectionStringParts(connectionString);
        if (extractedCreds.kind === "AccountConnString") {
            {
                const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                const pipeline = newPipeline(sharedKeyCredential, options);
                return new ShareServiceClient(extractedCreds.url, pipeline);
            }
        }
        else if (extractedCreds.kind === "SASConnString") {
            const pipeline = newPipeline(new AnonymousCredential(), options);
            return new ShareServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
        }
        else {
            throw new Error("Connection string must be either an Account connection string or a SAS connection string");
        }
    }
    /**
     * Creates a ShareClient object.
     *
     * @param shareName - Name of a share.
     * @returns The ShareClient object for the given share name.
     *
     * Example usage:
     *
     * ```js
     * const shareClient = serviceClient.getShareClient("<share name>");
     * await shareClient.create();
     * console.log("Created share successfully!");
     * ```
     */
    getShareClient(shareName) {
        return new ShareClient(appendToURLPath(this.url, shareName), this.pipeline);
    }
    /**
     * Creates a Share.
     *
     * @param shareName -
     * @param options -
     * @returns Share creation response and the corresponding share client.
     */
    async createShare(shareName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareServiceClient-createShare", options);
        try {
            const shareClient = this.getShareClient(shareName);
            const shareCreateResponse = await shareClient.create(updatedOptions);
            return {
                shareCreateResponse,
                shareClient
            };
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a Share.
     *
     * @param shareName -
     * @param options -
     * @returns Share deletion response and the corresponding share client.
     */
    async deleteShare(shareName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareServiceClient-deleteShare", options);
        try {
            const shareClient = this.getShareClient(shareName);
            return await shareClient.delete(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Gets the properties of a storage account’s file service, including properties
     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-service-properties
     *
     * @param options - Options to Get Properties operation.
     * @returns Response data for the Get Properties operation.
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ShareServiceClient-getProperties", options);
        try {
            return await this.serviceContext.getProperties(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets properties for a storage account’s file service endpoint, including properties
     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-service-properties
     *
     * @param properties -
     * @param options - Options to Set Properties operation.
     * @returns Response data for the Set Properties operation.
     */
    async setProperties(properties, options = {}) {
        const { span, updatedOptions } = createSpan("ShareServiceClient-setProperties", options);
        try {
            return await this.serviceContext.setProperties(properties, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an AsyncIterableIterator for {@link ServiceListSharesSegmentResponse} objects
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of shares to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all shares remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list shares operation.
     */
    listSegments(marker, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listSegments_1() {
            if (options.prefix === "") {
                options.prefix = undefined;
            }
            let listSharesSegmentResponse;
            do {
                listSharesSegmentResponse = yield tslib.__await(this.listSharesSegment(marker, options));
                marker = listSharesSegmentResponse.continuationToken;
                yield yield tslib.__await(yield tslib.__await(listSharesSegmentResponse));
            } while (marker);
        });
    }
    /**
     * Returns an AsyncIterableIterator for share items
     *
     * @param options - Options to list shares operation.
     */
    listItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listItems_1() {
            var e_1, _a;
            if (options.prefix === "") {
                options.prefix = undefined;
            }
            let marker;
            try {
                for (var _b = tslib.__asyncValues(this.listSegments(marker, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const segment = _c.value;
                    if (segment.shareItems) {
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(segment.shareItems)));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the shares
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the shares in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const share of serviceClient.listShares()) {
     *   console.log(`Share ${i++}: ${share.name}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = serviceClient.listShares();
     * let shareItem = await iter.next();
     * while (!shareItem.done) {
     *   console.log(`Share ${i++}: ${shareItem.value.name}`);
     *   shareItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of serviceClient.listShares().byPage({ maxPageSize: 20 })) {
     *   if (response.shareItems) {
     *    for (const share of response.shareItems) {
     *        console.log(`Share ${i++}: ${share.name}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = serviceClient.listShares().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 share names
     * if (response.shareItems) {
     *   for (const share of response.shareItems) {
     *     console.log(`Share ${i++}: ${share.name}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = serviceClient.listShares().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 share names
     * if (response.shareItems) {
     *   for (const share of response.shareItems) {
     *     console.log(`Share ${i++}: ${share.name}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list shares operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    listShares(options = {}) {
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        const include = [];
        if (options.includeMetadata) {
            include.push("metadata");
        }
        if (options.includeSnapshots) {
            include.push("snapshots");
        }
        if (options.includeDeleted) {
            include.push("deleted");
        }
        const updatedOptions = Object.assign(Object.assign({}, options), (include.length > 0 ? { include: include } : {}));
        // AsyncIterableIterator to iterate over queues
        const iter = this.listItems(updatedOptions);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                return this.listSegments(settings.continuationToken, Object.assign({ maxResults: settings.maxPageSize }, updatedOptions));
            }
        };
    }
    /**
     * Gets the properties of a storage account's File service, including properties for Storage
     * Analytics metrics and CORS (Cross-Origin Resource Sharing) rules.
     *
     * @param marker - A string value that identifies the portion of
     *                          the list to be returned with the next list operation. The operation
     *                          returns a marker value within the response body if the list returned was
     *                          not complete. The marker value may then be used in a subsequent call to
     *                          request the next set of list items. The marker value is opaque to the
     *                          client.
     * @param options - Options to List Shares Segment operation.
     * @returns Response data for the List Shares Segment operation.
     */
    async listSharesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareServiceClient-listSharesSegment", options);
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        try {
            const res = await this.serviceContext.listSharesSegment(Object.assign(Object.assign({ marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));
            // parse protocols
            if (res.shareItems) {
                for (let i = 0; i < res.shareItems.length; i++) {
                    const protocolsStr = res.shareItems[i].properties.enabledProtocols;
                    res.shareItems[i].properties.protocols = toShareProtocols(protocolsStr);
                }
            }
            return res;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Restores a previously deleted share.
     * This API is only functional if Share Soft Delete is enabled
     * for the storage account associated with the share.
     *
     * @param deletedShareName - The name of the previously deleted share.
     * @param deletedShareVersion - The version of the previously deleted share.
     * @param options - Options to Share undelete operation.
     * @returns Restored share.
     */
    async undeleteShare(deletedShareName, deletedShareVersion, options = {}) {
        const { span, updatedOptions } = createSpan("ShareServiceClient-undeleteShare", options);
        try {
            const shareClient = this.getShareClient(deletedShareName);
            await new ShareClientInternal(shareClient.url, this.pipeline).restore(Object.assign({ deletedShareName: deletedShareName, deletedShareVersion: deletedShareVersion, abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
            return shareClient;
        }
        catch (e) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Only available for ShareServiceClient constructed with a shared key credential.
     *
     * Generates an account Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-account-sas
     *
     * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not specified.
     * @param permissions - Specifies the list of permissions to be associated with the SAS.
     * @param resourceTypes - Specifies the resource types associated with the shared access signature.
     * @param options - Optional parameters.
     * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
        }
        if (expiresOn === undefined) {
            const now = new Date();
            expiresOn = new Date(now.getTime() + 3600 * 1000);
        }
        const sas = generateAccountSASQueryParameters(Object.assign({ permissions,
            expiresOn,
            resourceTypes, services: AccountSASServices.parse("f").toString() }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    }
}

Object.defineProperty(exports, 'BaseRequestPolicy', {
    enumerable: true,
    get: function () {
        return coreHttp.BaseRequestPolicy;
    }
});
Object.defineProperty(exports, 'HttpHeaders', {
    enumerable: true,
    get: function () {
        return coreHttp.HttpHeaders;
    }
});
Object.defineProperty(exports, 'RequestPolicyOptions', {
    enumerable: true,
    get: function () {
        return coreHttp.RequestPolicyOptions;
    }
});
Object.defineProperty(exports, 'RestError', {
    enumerable: true,
    get: function () {
        return coreHttp.RestError;
    }
});
Object.defineProperty(exports, 'WebResource', {
    enumerable: true,
    get: function () {
        return coreHttp.WebResource;
    }
});
Object.defineProperty(exports, 'deserializationPolicy', {
    enumerable: true,
    get: function () {
        return coreHttp.deserializationPolicy;
    }
});
exports.AccountSASPermissions = AccountSASPermissions;
exports.AccountSASResourceTypes = AccountSASResourceTypes;
exports.AccountSASServices = AccountSASServices;
exports.AnonymousCredential = AnonymousCredential;
exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
exports.Credential = Credential;
exports.CredentialPolicy = CredentialPolicy;
exports.FileSASPermissions = FileSASPermissions;
exports.FileSystemAttributes = FileSystemAttributes;
exports.Pipeline = Pipeline;
exports.SASQueryParameters = SASQueryParameters;
exports.ShareClient = ShareClient;
exports.ShareDirectoryClient = ShareDirectoryClient;
exports.ShareFileClient = ShareFileClient;
exports.ShareLeaseClient = ShareLeaseClient;
exports.ShareSASPermissions = ShareSASPermissions;
exports.ShareServiceClient = ShareServiceClient;
exports.StorageBrowserPolicy = StorageBrowserPolicy;
exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
exports.StorageRetryPolicy = StorageRetryPolicy;
exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
exports.generateFileSASQueryParameters = generateFileSASQueryParameters;
exports.logger = logger;
exports.newPipeline = newPipeline;
//# sourceMappingURL=index.js.map
