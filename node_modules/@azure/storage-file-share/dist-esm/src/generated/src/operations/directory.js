/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import * as coreHttp from "@azure/core-http";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
/** Class representing a Directory. */
export class Directory {
    /**
     * Initialize a new instance of the class Directory class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a new directory under the specified share or parent directory.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    create(fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        const operationArguments = {
            fileAttributes,
            fileCreatedOn,
            fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createOperationSpec);
    }
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @param options The options parameters.
     */
    getProperties(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getPropertiesOperationSpec);
    }
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @param options The options parameters.
     */
    delete(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteOperationSpec);
    }
    /**
     * Sets properties on the directory.
     * @param fileAttributes If specified, the provided file attributes shall be set. Default value:
     *                       ‘Archive’ for file and ‘Directory’ for directory. ‘None’ can also be specified as default.
     * @param fileCreatedOn Creation time for the file/directory. Default value: Now.
     * @param fileLastWriteOn Last write time for the file/directory. Default value: Now.
     * @param options The options parameters.
     */
    setProperties(fileAttributes, fileCreatedOn, fileLastWriteOn, options) {
        const operationArguments = {
            fileAttributes,
            fileCreatedOn,
            fileLastWriteOn,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setPropertiesOperationSpec);
    }
    /**
     * Updates user defined metadata for the specified directory.
     * @param options The options parameters.
     */
    setMetadata(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, setMetadataOperationSpec);
    }
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the contents
     * only for a single level of the directory hierarchy.
     * @param options The options parameters.
     */
    listFilesAndDirectoriesSegment(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listFilesAndDirectoriesSegmentOperationSpec);
    }
    /**
     * Lists handles for directory.
     * @param options The options parameters.
     */
    listHandles(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listHandlesOperationSpec);
    }
    /**
     * Closes all handles open for given directory.
     * @param handleId Specifies handle ID opened on the file or directory to be closed. Asterisk (‘*’) is
     *                 a wildcard that specifies all handles.
     * @param options The options parameters.
     */
    forceCloseHandles(handleId, options) {
        const operationArguments = {
            handleId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, forceCloseHandlesOperationSpec);
    }
}
// Operation Specifications
const xmlSerializer = new coreHttp.Serializer(Mappers, /* isXml */ true);
const createOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: Mappers.DirectoryCreateHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError,
            headersMapper: Mappers.DirectoryCreateExceptionHeaders
        }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.accept1,
        Parameters.metadata,
        Parameters.filePermission,
        Parameters.filePermissionKey1,
        Parameters.fileAttributes,
        Parameters.fileCreatedOn,
        Parameters.fileLastWriteOn
    ],
    isXML: true,
    serializer: xmlSerializer
};
const getPropertiesOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "GET",
    responses: {
        200: {
            headersMapper: Mappers.DirectoryGetPropertiesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError,
            headersMapper: Mappers.DirectoryGetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.shareSnapshot,
        Parameters.restype2
    ],
    urlParameters: [Parameters.url],
    headerParameters: [Parameters.version, Parameters.accept1],
    isXML: true,
    serializer: xmlSerializer
};
const deleteOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: Mappers.DirectoryDeleteHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError,
            headersMapper: Mappers.DirectoryDeleteExceptionHeaders
        }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [Parameters.version, Parameters.accept1],
    isXML: true,
    serializer: xmlSerializer
};
const setPropertiesOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: Mappers.DirectorySetPropertiesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError,
            headersMapper: Mappers.DirectorySetPropertiesExceptionHeaders
        }
    },
    queryParameters: [
        Parameters.comp,
        Parameters.timeoutInSeconds,
        Parameters.restype2
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.accept1,
        Parameters.filePermission,
        Parameters.filePermissionKey1,
        Parameters.fileAttributes,
        Parameters.fileCreatedOn,
        Parameters.fileLastWriteOn
    ],
    isXML: true,
    serializer: xmlSerializer
};
const setMetadataOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: Mappers.DirectorySetMetadataHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError,
            headersMapper: Mappers.DirectorySetMetadataExceptionHeaders
        }
    },
    queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.comp5,
        Parameters.restype2
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.accept1,
        Parameters.metadata
    ],
    isXML: true,
    serializer: xmlSerializer
};
const listFilesAndDirectoriesSegmentOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ListFilesAndDirectoriesSegmentResponse,
            headersMapper: Mappers.DirectoryListFilesAndDirectoriesSegmentHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError,
            headersMapper: Mappers.DirectoryListFilesAndDirectoriesSegmentExceptionHeaders
        }
    },
    queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.comp1,
        Parameters.prefix,
        Parameters.marker,
        Parameters.maxResults,
        Parameters.shareSnapshot,
        Parameters.restype2,
        Parameters.include1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.accept1,
        Parameters.includeExtendedInfo
    ],
    isXML: true,
    serializer: xmlSerializer
};
const listHandlesOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.ListHandlesResponse,
            headersMapper: Mappers.DirectoryListHandlesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError,
            headersMapper: Mappers.DirectoryListHandlesExceptionHeaders
        }
    },
    queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.marker,
        Parameters.maxResults,
        Parameters.shareSnapshot,
        Parameters.comp9
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.accept1,
        Parameters.recursive
    ],
    isXML: true,
    serializer: xmlSerializer
};
const forceCloseHandlesOperationSpec = {
    path: "/{shareName}/{directory}",
    httpMethod: "PUT",
    responses: {
        200: {
            headersMapper: Mappers.DirectoryForceCloseHandlesHeaders
        },
        default: {
            bodyMapper: Mappers.StorageError,
            headersMapper: Mappers.DirectoryForceCloseHandlesExceptionHeaders
        }
    },
    queryParameters: [
        Parameters.timeoutInSeconds,
        Parameters.marker,
        Parameters.shareSnapshot,
        Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
        Parameters.version,
        Parameters.accept1,
        Parameters.recursive,
        Parameters.handleId
    ],
    isXML: true,
    serializer: xmlSerializer
};
//# sourceMappingURL=directory.js.map