// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncGenerator, __asyncValues, __await } from "tslib";
import { isNode } from "@azure/core-http";
import { SpanStatusCode } from "@azure/core-tracing";
import { Share, Directory, File } from "./generated/src/operations";
import { newPipeline, Pipeline } from "./Pipeline";
import { DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, DEFAULT_HIGH_LEVEL_CONCURRENCY, FILE_MAX_SIZE_BYTES, FILE_RANGE_MAX_SIZE_BYTES, URLConstants } from "./utils/constants";
import { appendToURLPath, setURLParameter, truncatedISO8061Date, extractConnectionStringParts, getShareNameAndPathFromUrl, appendToURLQuery, httpAuthorizationToString } from "./utils/utils.common";
import { Credential } from "./credentials/Credential";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { convertTracingToRequestOptionsBase, createSpan } from "./utils/tracing";
import { StorageClient } from "./StorageClient";
import "@azure/core-paging";
import { FileSystemAttributes } from "./FileSystemAttributes";
import { FileDownloadResponse } from "./FileDownloadResponse";
import { rangeToString } from "./Range";
import { fileAttributesToString, fileCreationTimeToString, fileLastWriteTimeToString, validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions, validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions, toShareProtocolsString, toShareProtocols } from "./models";
import { Batch } from "./utils/Batch";
import { BufferScheduler } from "./utils/BufferScheduler";
import { fsStat, fsCreateReadStream, readStreamToLocalFile, streamToBuffer } from "./utils/utils.node";
import { StorageClientContext } from "./generated/src/storageClientContext";
import { SERVICE_VERSION } from "./utils/constants";
import { generateUuid } from "@azure/core-http";
import { generateFileSASQueryParameters } from "./FileSASSignatureValues";
/**
 * A ShareClient represents a URL to the Azure Storage share allowing you to manipulate its directories and files.
 */
export class ShareClient extends StorageClient {
    constructor(urlOrConnectionString, credentialOrPipelineOrShareName, 
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */
    options) {
        let pipeline;
        let url;
        if (credentialOrPipelineOrShareName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrShareName;
        }
        else if (credentialOrPipelineOrShareName instanceof Credential) {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = newPipeline(credentialOrPipelineOrShareName, options);
        }
        else if (!credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName !== "string") {
            // (url: string, credential?: Credential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrShareName &&
            typeof credentialOrPipelineOrShareName === "string") {
            // (connectionString: string, name: string, options?: StoragePipelineOptions)
            const extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            const name = credentialOrPipelineOrShareName;
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(extractedCreds.url, name);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url = appendToURLPath(extractedCreds.url, name) + "?" + extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for name parameter");
        }
        super(url, pipeline);
        this._name = getShareNameAndPathFromUrl(this.url).shareName;
        this.context = new Share(this.storageClientContext);
    }
    /**
     * The name of the share
     */
    get name() {
        return this._name;
    }
    /**
     * Creates a new ShareClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base share.
     *
     * @param snapshot - The snapshot timestamp.
     * @returns A new ShareClient object identical to the source but with the specified snapshot timestamp
     */
    withSnapshot(snapshot) {
        return new ShareClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    }
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, the operation fails.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options - Options to Share Create operation.
     * @returns Response data for the Share Create operation.
     */
    async create(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-create", options);
        try {
            return await this.context.create(Object.assign(Object.assign(Object.assign({}, options), { enabledProtocols: toShareProtocolsString(options.protocols) }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, it is not changed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options -
     */
    async createIfNotExists(options = {}) {
        var _a, _b;
        const { span, updatedOptions } = createSpan("ShareClient-createIfNotExists", options);
        try {
            const res = await this.create(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ShareAlreadyExists") {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: "Expected exception when creating a share only if it doesn't already exist."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a {@link ShareDirectoryClient} object.
     *
     * @param directoryName - A directory name
     * @returns The ShareDirectoryClient object for the given directory name.
     */
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */
    getDirectoryClient(directoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(directoryName)), this.pipeline);
    }
    /**
     * Gets the directory client for the root directory of this share.
     * Note that the root directory always exists and cannot be deleted.
     *
     * @readonly A new ShareDirectoryClient object for the root directory.
     */
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */
    get rootDirectoryClient() {
        return this.getDirectoryClient("");
    }
    /**
     * Creates a new subdirectory under this share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory creation response data and the corresponding directory client.
     */
    async createDirectory(directoryName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-createDirectory", options);
        try {
            const directoryClient = this.getDirectoryClient(directoryName);
            const directoryCreateResponse = await directoryClient.create(updatedOptions);
            return {
                directoryClient,
                directoryCreateResponse
            };
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified empty sub directory under this share.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    async deleteDirectory(directoryName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-deleteDirectory", options);
        try {
            const directoryClient = this.getDirectoryClient(directoryName);
            return await directoryClient.delete(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new file or replaces a file under the root directory of this share.
     * Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    async createFile(fileName, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-createFile", options);
        try {
            const directoryClient = this.rootDirectoryClient;
            const fileClient = directoryClient.getFileClient(fileName);
            const fileCreateResponse = await fileClient.create(size, updatedOptions);
            return {
                fileClient,
                fileCreateResponse
            };
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes a file under the root directory of this share from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code `SharingViolation`
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400
     * (`InvalidQueryParameterValue`)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param directoryName -
     * @param fileName -
     * @param options - Options to File Delete operation.
     * @returns Promise<FileDeleteResponse> File Delete response data.
     */
    async deleteFile(fileName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-deleteFile", options);
        try {
            const directoryClient = this.rootDirectoryClient;
            const fileClient = directoryClient.getFileClient(fileName);
            return await fileClient.delete(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns true if the Azrue share resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing share might be deleted by other clients or
     * applications. Vice versa new shares might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    async exists(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-exists", options);
        try {
            await this.getProperties(updatedOptions);
            return true;
        }
        catch (e) {
            if (e.statusCode === 404) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: "Expected exception when checking share existence"
                });
                return false;
            }
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns all user-defined metadata and system properties for the specified
     * share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listShares` method of {@link ShareServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @returns Response data for the Share Get Properties operation.
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-getProperties", options);
        try {
            const res = await this.context.getProperties(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
            // parse protocols
            const protocols = toShareProtocols(res.enabledProtocols);
            res.protocols = protocols;
            return res;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Marks the specified share for deletion. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options - Options to Share Delete operation.
     * @returns Response data for the Share Delete operation.
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-delete", options);
        try {
            return await this.context.delete(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Marks the specified share for deletion if it exists. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options -
     */
    async deleteIfExists(options = {}) {
        var _a, _b;
        const { span, updatedOptions } = createSpan("ShareClient-deleteIfExists", options);
        try {
            const res = await this.delete(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ShareNotFound") {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: "Expected exception when deleting a share only if it exists."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     *
     * If no option provided, or no metadata defined in the option parameter, the share
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed.
     * @param option - Options to Share Set Metadata operation.
     * @returns Response data for the Share Set Metadata operation.
     */
    async setMetadata(metadata, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-setMetadata", options);
        try {
            return await this.context.setMetadata(Object.assign(Object.assign(Object.assign({}, options), { metadata }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Gets the permissions for the specified share. The permissions indicate
     * whether share data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-acl
     *
     * @param option - Options to Share Get Access Policy operation.
     * @returns Response data for the Share Get Access Policy operation.
     */
    async getAccessPolicy(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-getAccessPolicy", options);
        try {
            const response = await this.context.getAccessPolicy(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
            const res = {
                _response: response._response,
                date: response.date,
                etag: response.etag,
                lastModified: response.lastModified,
                requestId: response.requestId,
                signedIdentifiers: [],
                version: response.version
            };
            for (const identifier of response) {
                let accessPolicy = undefined;
                if (identifier.accessPolicy) {
                    accessPolicy = {
                        permissions: identifier.accessPolicy.permissions
                    };
                    if (identifier.accessPolicy.expiresOn) {
                        accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
                    }
                    if (identifier.accessPolicy.startsOn) {
                        accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
                    }
                }
                res.signedIdentifiers.push({
                    accessPolicy,
                    id: identifier.id
                });
            }
            return res;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets the permissions for the specified share. The permissions indicate
     * whether directories or files in a share may be accessed publicly.
     *
     * When you set permissions for a share, the existing permissions are replaced.
     * If no shareAcl provided, the existing share ACL will be
     * removed.
     *
     * When you establish a stored access policy on a share, it may take up to 30 seconds to take effect.
     * During this interval, a shared access signature that is associated with the stored access policy will
     * fail with status code 403 (Forbidden), until the access policy becomes active.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
     *
     * @param shareAcl - Array of signed identifiers, each having a unique Id and details of access policy.
     * @param option - Options to Share Set Access Policy operation.
     * @returns Response data for the Share Set Access Policy operation.
     */
    async setAccessPolicy(shareAcl, options = {}) {
        var _a, _b, _c;
        const { span, updatedOptions } = createSpan("ShareClient-setAccessPolicy", options);
        try {
            const acl = [];
            for (const identifier of shareAcl || []) {
                acl.push({
                    accessPolicy: {
                        expiresOn: ((_a = identifier.accessPolicy) === null || _a === void 0 ? void 0 : _a.expiresOn)
                            ? truncatedISO8061Date(identifier.accessPolicy.expiresOn)
                            : undefined,
                        permissions: (_b = identifier.accessPolicy) === null || _b === void 0 ? void 0 : _b.permissions,
                        startsOn: ((_c = identifier.accessPolicy) === null || _c === void 0 ? void 0 : _c.startsOn)
                            ? truncatedISO8061Date(identifier.accessPolicy.startsOn)
                            : undefined
                    },
                    id: identifier.id
                });
            }
            return await this.context.setAccessPolicy(Object.assign(Object.assign(Object.assign({}, options), { shareAcl: acl }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a read-only snapshot of a share.
     *
     * @param options - Options to Share Create Snapshot operation.
     * @returns Response data for the Share Create Snapshot operation.
     */
    async createSnapshot(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-createSnapshot", options);
        try {
            return await this.context.createSnapshot(Object.assign(Object.assign({ abortSignal: options.abortSignal }, options), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets quota for the specified share.
     *
     * @deprecated Use {@link ShareClient.setProperties} instead.
     *
     * @param quotaInGB - Specifies the maximum size of the share in gigabytes
     * @param option - Options to Share Set Quota operation.
     * @returns Response data for the Share Get Quota operation.
     */
    async setQuota(quotaInGB, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-setQuota", options);
        try {
            return await this.context.setProperties(Object.assign(Object.assign(Object.assign({}, options), { quota: quotaInGB }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets properties of the share.
     *
     * @param option - Options to Share Set Properties operation.
     * @returns Response data for the Share Set Properties operation.
     */
    async setProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-setProperties", options);
        try {
            return await this.context.setProperties(Object.assign(Object.assign({}, options), { quota: options.quotaInGB, tracingOptions: updatedOptions.tracingOptions }));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Retrieves statistics related to the share.
     *
     * @param option - Options to Share Get Statistics operation.
     * @returns Response data for the Share Get Statistics operation.
     */
    async getStatistics(options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-getStatistics", options);
        try {
            const response = await this.context.getStatistics(Object.assign(Object.assign({}, options), convertTracingToRequestOptionsBase(updatedOptions)));
            const GBBytes = 1024 * 1024 * 1024;
            return Object.assign(Object.assign({}, response), { shareUsage: Math.ceil(response.shareUsageBytes / GBBytes) });
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a file permission (a security descriptor) at the share level.
     * The created security descriptor can be used for the files/directories in the share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermission - File permission described in the SDDL
     */
    async createPermission(filePermission, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-createPermission", options);
        try {
            return await this.context.createPermission({
                permission: filePermission
            }, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Gets the Security Descriptor Definition Language (SDDL) for a given file permission key
     * which indicates a security descriptor.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermissionKey - File permission key which indicates the security descriptor of the permission.
     */
    async getPermission(filePermissionKey, options = {}) {
        const { span, updatedOptions } = createSpan("ShareClient-getPermission", options);
        try {
            return await this.context.getPermission(filePermissionKey, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Only available for ShareClient constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateSasUrl(options) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateFileSASQueryParameters(Object.assign({ shareName: this.name }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    }
}
/**
 * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.
 */
export class ShareDirectoryClient extends StorageClient {
    constructor(url, credentialOrPipeline, options = {}) {
        let pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        super(url, pipeline);
        ({
            baseName: this._name,
            shareName: this._shareName,
            path: this._path
        } = getShareNameAndPathFromUrl(this.url));
        this.context = new Directory(this.storageClientContext);
    }
    /**
     * The share name corresponding to this directory client
     */
    get shareName() {
        return this._shareName;
    }
    /**
     * The full path of the directory
     */
    get path() {
        return this._path;
    }
    /**
     * The name of the directory
     */
    get name() {
        return this._name;
    }
    /**
     * Creates a new directory under the specified share or parent directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options - Options to Directory Create operation.
     * @returns Response data for the Directory  operation.
     */
    async create(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-create", options);
        try {
            if (!options.fileAttributes) {
                options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                // By default set it as a directory.
                const attributes = new FileSystemAttributes();
                attributes.directory = true;
                options.fileAttributes = attributes;
            }
            return await this.context.create(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), Object.assign({ abortSignal: options.abortSignal, metadata: options.metadata, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new directory under the specified share or parent directory if it does not already exists.
     * If the directory already exists, it is not modified.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options -
     */
    async createIfNotExists(options = {}) {
        var _a, _b;
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-createIfNotExists", options);
        try {
            const res = await this.create(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceAlreadyExists") {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: "Expected exception when creating a directory only if it does not already exist."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_b = e.response) === null || _b === void 0 ? void 0 : _b.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets properties on the directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties
     *
     * @param DirectoryProperties - Directory properties. If no values are provided,
     *                                            existing values will be preserved.
     */
    async setProperties(properties = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-setProperties", properties);
        try {
            properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
            return await this.context.setProperties(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), Object.assign({ abortSignal: properties.abortSignal, filePermission: properties.filePermission, filePermissionKey: properties.filePermissionKey }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a ShareDirectoryClient object for a sub directory.
     *
     * @param subDirectoryName - A subdirectory name
     * @returns The ShareDirectoryClient object for the given subdirectory name.
     *
     * Example usage:
     *
     * ```js
     * const directoryClient = shareClient.getDirectoryClient("<directory name>");
     * await directoryClient.create();
     * console.log("Created directory successfully");
     * ```
     */
    getDirectoryClient(subDirectoryName) {
        return new ShareDirectoryClient(appendToURLPath(this.url, encodeURIComponent(subDirectoryName)), this.pipeline);
    }
    /**
     * Creates a new subdirectory under this directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory create response data and the corresponding DirectoryClient instance.
     */
    async createSubdirectory(directoryName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-createSubdirectory", options);
        try {
            const directoryClient = this.getDirectoryClient(directoryName);
            const directoryCreateResponse = await directoryClient.create(updatedOptions);
            return {
                directoryClient,
                directoryCreateResponse
            };
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified empty sub directory under this directory.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    async deleteSubdirectory(directoryName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-deleteSubdirectory", options);
        try {
            const directoryClient = this.getDirectoryClient(directoryName);
            return await directoryClient.delete(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    async createFile(fileName, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-createFile", options);
        try {
            const fileClient = this.getFileClient(fileName);
            const fileCreateResponse = await fileClient.create(size, updatedOptions);
            return {
                fileClient,
                fileCreateResponse
            };
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified file under this directory from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param fileName - Name of the file to delete
     * @param options - Options to File Delete operation.
     * @returns File deletion response data.
     */
    async deleteFile(fileName, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-deleteFile", options);
        try {
            const fileClient = this.getFileClient(fileName);
            return await fileClient.delete(updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a {@link ShareFileClient} object.
     *
     * @param fileName - A file name.
     * @returns A new ShareFileClient object for the given file name.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!"
     *
     * const fileClient = directoryClient.getFileClient("<file name>");
     *
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-subclients */
    getFileClient(fileName) {
        return new ShareFileClient(appendToURLPath(this.url, encodeURIComponent(fileName)), this.pipeline);
    }
    /**
     * Returns true if the specified directory exists; false otherwise.
     *
     * NOTE: use this function with care since an existing directory might be deleted by other clients or
     * applications. Vice versa new directories might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    async exists(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-exists", options);
        try {
            await this.getProperties({
                abortSignal: options.abortSignal,
                tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
            });
            return true;
        }
        catch (e) {
            if (e.statusCode === 404) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: "Expected exception when checking directory existence"
                });
                return false;
            }
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties
     *
     * @param options - Options to Directory Get Properties operation.
     * @returns Response data for the Directory Get Properties operation.
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-getProperties", options);
        try {
            return await this.context.getProperties(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options - Options to Directory Delete operation.
     * @returns Response data for the Directory Delete operation.
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-delete", options);
        try {
            return await this.context.delete(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the specified empty directory if it exists. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options -
     */
    async deleteIfExists(options = {}) {
        var _a, _b, _c;
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-deleteIfExists", options);
        try {
            const res = await this.delete(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceNotFound" ||
                ((_b = e.details) === null || _b === void 0 ? void 0 : _b.errorCode) === "ParentNotFound") {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: "Expected exception when deleting a directory only if it exists."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_c = e.response) === null || _c === void 0 ? void 0 : _c.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates user defined metadata for the specified directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to Directory Set Metadata operation.
     * @returns Response data for the Directory Set Metadata operation.
     */
    async setMetadata(metadata, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-setMetadata", options);
        try {
            return await this.context.setMetadata(Object.assign({ abortSignal: options.abortSignal, metadata }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListFilesAndDirectoriesSegmentResponse} objects
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of files and directories to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all files and directories remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list files and directories operation.
     */
    iterateFilesAndDirectoriesSegments(marker, options = {}) {
        return __asyncGenerator(this, arguments, function* iterateFilesAndDirectoriesSegments_1() {
            if (options.prefix === "") {
                options.prefix = undefined;
            }
            let listFilesAndDirectoriesResponse;
            do {
                listFilesAndDirectoriesResponse = yield __await(this.listFilesAndDirectoriesSegment(marker, options));
                marker = listFilesAndDirectoriesResponse.continuationToken;
                yield yield __await(yield __await(listFilesAndDirectoriesResponse));
            } while (marker);
        });
    }
    /**
     * Returns an AsyncIterableIterator for file and directory items
     *
     * @param options - Options to list files and directories operation.
     */
    listFilesAndDirectoriesItems(options = {}) {
        return __asyncGenerator(this, arguments, function* listFilesAndDirectoriesItems_1() {
            var e_1, _a;
            if (options.prefix === "") {
                options.prefix = undefined;
            }
            let marker;
            try {
                for (var _b = __asyncValues(this.iterateFilesAndDirectoriesSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const listFilesAndDirectoriesResponse = _c.value;
                    for (const file of listFilesAndDirectoriesResponse.segment.fileItems) {
                        yield yield __await(Object.assign({ kind: "file" }, file));
                    }
                    for (const directory of listFilesAndDirectoriesResponse.segment.directoryItems) {
                        yield yield __await(Object.assign({ kind: "directory" }, directory));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the files and directories
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the files and directories in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const entity of directoryClient.listFilesAndDirectories()) {
     *   if (entity.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.name}`);
     *   }
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = directoryClient.listFilesAndDirectories();
     * let entity = await iter.next();
     * while (!entity.done) {
     *   if (entity.value.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.value.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.value.name}`);
     *   }
     *   entity = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const fileItem of response.segment.fileItems) {
     *     console.log(`${i++} - file\t: ${fileItem.name}`);
     *   }
     *   for (const dirItem of response.segment.directoryItems) {
     *     console.log(`${i++} - directory\t: ${dirItem.name}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 3 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     *
     * // Gets next marker
     * let dirMarker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ continuationToken: dirMarker, maxPageSize: 4 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     * ```
     *
     * @param options - Options to list files and directories operation.
     * @returns An asyncIterableIterator that supports paging.
     */
    listFilesAndDirectories(options = {}) {
        const include = [];
        if (options.includeTimestamps) {
            include.push("Timestamps");
        }
        if (options.includeEtag) {
            include.push("Etag");
        }
        if (options.includeAttributes) {
            include.push("Attributes");
        }
        if (options.includePermissionKey) {
            include.push("PermissionKey");
        }
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        const updatedOptions = Object.assign(Object.assign({}, options), (include.length > 0 ? { include: include } : {}));
        // AsyncIterableIterator to iterate over files and directories
        const iter = this.listFilesAndDirectoriesItems(updatedOptions);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            async next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                return this.iterateFilesAndDirectoriesSegments(settings.continuationToken, Object.assign({ maxResults: settings.maxPageSize }, updatedOptions));
            }
        };
    }
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the
     * contents only for a single level of the directory hierarchy.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files
     *
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to Directory List Files and Directories Segment operation.
     * @returns Response data for the Directory List Files and Directories operation.
     */
    async listFilesAndDirectoriesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-listFilesAndDirectoriesSegment", options);
        if (options.prefix === "") {
            options.prefix = undefined;
        }
        try {
            return await this.context.listFilesAndDirectoriesSegment(Object.assign(Object.assign({ marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListHandlesResponse}
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    iterateHandleSegments(marker, options = {}) {
        return __asyncGenerator(this, arguments, function* iterateHandleSegments_1() {
            let listHandlesResponse;
            if (!!marker || marker === undefined) {
                do {
                    listHandlesResponse = yield __await(this.listHandlesSegment(marker, options));
                    marker = listHandlesResponse.continuationToken;
                    yield yield __await(yield __await(listHandlesResponse));
                } while (marker);
            }
        });
    }
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    listHandleItems(options = {}) {
        return __asyncGenerator(this, arguments, function* listHandleItems_1() {
            var e_2, _a;
            let marker;
            try {
                for (var _b = __asyncValues(this.iterateHandleSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const listHandlesResponse = _c.value;
                    if (listHandlesResponse.handleList) {
                        for (const handle of listHandlesResponse.handleList) {
                            yield yield __await(handle);
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * for await (const handle of iter) {
     *   console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * let handleItem = await iter.next();
     * while (!handleItem.done) {
     *   console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);
     *   handleItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {
     *   if (response.handleList) {
     *     for (const handle of response.handleList) {
     *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });
     * let response = await iterator.next();
     *
     * // Prints 2 handles
     * if (response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.value.continuationToken;
     *
     * // Passing next marker as continuationToken
     * console.log(`    continuation`);
     * iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = await iterator.next();
     *
     * // Prints 2 more handles assuming you have more than four directory/files opened
     * if (!response.done && response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    listHandles(options = {}) {
        // an AsyncIterableIterator to iterate over handles
        const iter = this.listHandleItems(options);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            async next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                return this.iterateHandleSegments(settings.continuationToken, Object.assign({ maxResults: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Lists handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    async listHandlesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-listHandlesSegment", options);
        try {
            marker = marker === "" ? undefined : marker;
            const response = await this.context.listHandles(Object.assign(Object.assign({ marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));
            // TODO: Protocol layer issue that when handle list is in returned XML
            // response.handleList is an empty string
            if (response.handleList === "") {
                response.handleList = undefined;
            }
            return response;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options -
     */
    async forceCloseHandlesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-forceCloseHandlesSegment", options);
        try {
            marker = marker === "" ? undefined : marker;
            const rawResponse = await this.context.forceCloseHandles("*", Object.assign(Object.assign({ marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));
            const response = rawResponse;
            response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
            response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options -
     */
    async forceCloseAllHandles(options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-forceCloseAllHandles", options);
        try {
            let handlesClosed = 0;
            let numberOfHandlesFailedToClose = 0;
            let marker = "";
            do {
                const response = await this.forceCloseHandlesSegment(marker, updatedOptions);
                marker = response.marker;
                if (response.closedHandlesCount) {
                    handlesClosed += response.closedHandlesCount;
                }
                if (response.closeFailureCount) {
                    numberOfHandlesFailedToClose += response.closeFailureCount;
                }
            } while (marker);
            return { closedHandlesCount: handlesClosed, closeFailureCount: numberOfHandlesFailedToClose };
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close a specific handle for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param aborter - Create a new Aborter instance with Aborter.none or Aborter.timeout(),
     *                          goto documents of Aborter for more examples about request cancellation
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseHandlesSegment() to close all handles.
     * @param options -
     */
    async forceCloseHandle(handleId, options = {}) {
        const { span, updatedOptions } = createSpan("ShareDirectoryClient-forceCloseHandle", options);
        try {
            if (handleId === "*") {
                throw new RangeError(`Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.`);
            }
            const rawResponse = await this.context.forceCloseHandles(handleId, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
            const response = rawResponse;
            response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
            response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
}
/**
 * A ShareFileClient represents a URL to an Azure Storage file.
 */
export class ShareFileClient extends StorageClient {
    constructor(url, credentialOrPipeline, 
    // Legacy, no way to fix the eslint error without breaking. Disable the rule for this line.
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */
    options) {
        let pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        super(url, pipeline);
        ({
            baseName: this._name,
            shareName: this._shareName,
            path: this._path
        } = getShareNameAndPathFromUrl(this.url));
        this.context = new File(this.storageClientContext);
    }
    /**
     * The share name corresponding to this file client
     */
    get shareName() {
        return this._shareName;
    }
    /**
     * The full path of the file
     */
    get path() {
        return this._path;
    }
    /**
     * The name of the file
     */
    get name() {
        return this._name;
    }
    /**
     * Creates a new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base ShareFileClient.
     *
     * @param shareSnapshot - The share snapshot timestamp.
     * @returns A new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     */
    withShareSnapshot(shareSnapshot) {
        return new ShareFileClient(setURLParameter(this.url, URLConstants.Parameters.SHARE_SNAPSHOT, shareSnapshot.length === 0 ? undefined : shareSnapshot), this.pipeline);
    }
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns Response data for the File Create  operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    async create(size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-create", options);
        try {
            if (size < 0 || size > FILE_MAX_SIZE_BYTES) {
                throw new RangeError(`File size must >= 0 and < ${FILE_MAX_SIZE_BYTES}.`);
            }
            options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
            if (!options.fileAttributes) {
                // Note: It would be Archive in service side if None is set.
                const attributes = new FileSystemAttributes();
                attributes.none = true;
                options.fileAttributes = attributes;
            }
            options.fileHttpHeaders = options.fileHttpHeaders || {};
            return await this.context.create(size, fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), Object.assign({ abortSignal: options.abortSignal, fileHttpHeaders: options.fileHttpHeaders, metadata: options.metadata, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream `readableStreamBody`
     * * In browsers, data returns in a promise `contentAsBlob`
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file
     *
     * @param offset - From which position of the file to download, greater than or equal to 0
     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
     * @param options - Options to File Download operation.
     * @returns Response data for the File Download operation.
     *
     * Example usage (Node.js):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download();
     * console.log(
     *   "Downloaded file content:",
     *   (await streamToBuffer(downloadFileResponse.readableStreamBody)).toString()}
     * );
     *
     * // A helper method used to read a Node.js readable stream into string
     * async function streamToBuffer(readableStream) {
     *   return new Promise((resolve, reject) => {
     *     const chunks = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));
     *     });
     *     readableStream.on("end", () => {
     *       resolve(Buffer.concat(chunks));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * Example usage (browsers):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download(0);
     * console.log(
     *   "Downloaded file content:",
     *   await blobToString(await downloadFileResponse.blobBody)}
     * );
     *
     * // A helper method used to convert a browser Blob into string.
     * export async function blobToString(blob: Blob): Promise<string> {
     *   const fileReader = new FileReader();
     *   return new Promise<string>((resolve, reject) => {
     *     fileReader.onloadend = (ev: any) => {
     *       resolve(ev.target!.result);
     *     };
     *     fileReader.onerror = reject;
     *     fileReader.readAsText(blob);
     *   });
     * }
     * ```
     */
    async download(offset = 0, count, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-download", options);
        try {
            if (options.rangeGetContentMD5 && offset === 0 && count === undefined) {
                throw new RangeError(`rangeGetContentMD5 only works with partial data downloading`);
            }
            const downloadFullFile = offset === 0 && !count;
            const res = await this.context.download(Object.assign({ abortSignal: options.abortSignal, requestOptions: {
                    onDownloadProgress: isNode ? undefined : options.onProgress // for Node.js, progress is reported by RetriableReadableStream
                }, range: downloadFullFile ? undefined : rangeToString({ offset, count }), rangeGetContentMD5: options.rangeGetContentMD5, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
            // Return browser response immediately
            if (!isNode) {
                return res;
            }
            // We support retrying when download stream unexpected ends in Node.js runtime
            // Following code shouldn't be bundled into browser build, however some
            // bundlers may try to bundle following code and "FileReadResponse.ts".
            // In this case, "FileDownloadResponse.browser.ts" will be used as a shim of "FileDownloadResponse.ts"
            // The config is in package.json "browser" field
            if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
                // TODO: Default value or make it a required parameter?
                options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
            }
            if (res.contentLength === undefined) {
                throw new RangeError(`File download response doesn't contain valid content length header`);
            }
            return new FileDownloadResponse(res, async (start) => {
                const updatedDownloadOptions = {
                    range: rangeToString({
                        count: offset + res.contentLength - start,
                        offset: start
                    })
                };
                // Debug purpose only
                // console.log(
                //   `Read from internal stream, range: ${
                //     chunkDownloadOptions.range
                //   }, options: ${JSON.stringify(chunkDownloadOptions)}`
                // );
                const downloadRes = await this.context.download(Object.assign(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, updatedDownloadOptions), convertTracingToRequestOptionsBase(updatedDownloadOptions)));
                if (!(downloadRes.etag === res.etag)) {
                    throw new Error("File has been modified concurrently");
                }
                return downloadRes.readableStreamBody;
            }, offset, res.contentLength, {
                abortSignal: options.abortSignal,
                maxRetryRequests: options.maxRetryRequests,
                onProgress: options.onProgress
            });
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns true if the specified file exists; false otherwise.
     *
     * NOTE: use this function with care since an existing file might be deleted by other clients or
     * applications. Vice versa new files might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    async exists(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-exists", options);
        try {
            await this.getProperties({
                abortSignal: options.abortSignal,
                tracingOptions: Object.assign(Object.assign({}, options.tracingOptions), convertTracingToRequestOptionsBase(updatedOptions))
            });
            return true;
        }
        catch (e) {
            if (e.statusCode === 404) {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: "Expected exception when checking file existence"
                });
                return false;
            }
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the file. It does not return the content of the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties
     *
     * @param options - Options to File Get Properties operation.
     * @returns Response data for the File Get Properties operation.
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-getProperties", options);
        try {
            return this.context.getProperties(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets properties on the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param properties - File properties. For file HTTP headers(e.g. Content-Type),
     *                                       if no values are provided, existing HTTP headers will be removed.
     *                                       For other file properties(e.g. fileAttributes), if no values are provided,
     *                                       existing values will be preserved.
     */
    async setProperties(properties = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-setProperties", properties);
        try {
            properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
            properties.fileHttpHeaders = properties.fileHttpHeaders || {};
            return await this.context.setHttpHeaders(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), Object.assign({ abortSignal: properties.abortSignal, fileHttpHeaders: properties.fileHttpHeaders, filePermission: properties.filePermission, filePermissionKey: properties.filePermissionKey, leaseAccessConditions: properties.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the file from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options - Options to File Delete operation.
     * @returns Response data for the File Delete operation.
     */
    async delete(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-delete", options);
        try {
            return await this.context.delete(Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes the file from the storage account if it exists.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options -
     */
    async deleteIfExists(options = {}) {
        var _a, _b, _c;
        const { span, updatedOptions } = createSpan("ShareFileClient-deleteIfExists", options);
        try {
            const res = await this.delete(updatedOptions);
            return Object.assign({ succeeded: true }, res);
        }
        catch (e) {
            if (((_a = e.details) === null || _a === void 0 ? void 0 : _a.errorCode) === "ResourceNotFound" ||
                ((_b = e.details) === null || _b === void 0 ? void 0 : _b.errorCode) === "ParentNotFound") {
                span.setStatus({
                    code: SpanStatusCode.ERROR,
                    message: "Expected exception when deleting a file only if it exists."
                });
                return Object.assign(Object.assign({ succeeded: false }, (_c = e.response) === null || _c === void 0 ? void 0 : _c.parsedHeaders), { _response: e.response });
            }
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets HTTP headers on the file.
     *
     * If no option provided, or no value provided for the file HTTP headers in the options,
     * these file HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param FileHttpHeaders - File HTTP headers like Content-Type.
     *                                             Provide undefined will remove existing HTTP headers.
     * @param options - Options to File Set HTTP Headers operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    async setHttpHeaders(fileHttpHeaders = {}, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-setHTTPHeaders", options);
        try {
            // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved
            options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
            return await this.context.setHttpHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), Object.assign({ abortSignal: options.abortSignal, fileHttpHeaders, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Resize file.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param length - Resizes a file to the specified size in bytes.
     *                        If the specified byte value is less than the current size of the file,
     *                        then all ranges above the specified byte value are cleared.
     * @param options - Options to File Resize operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    async resize(length, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-resize", options);
        try {
            if (length < 0) {
                throw new RangeError(`Size cannot less than 0 when resizing file.`);
            }
            // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved.
            options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
            return await this.context.setHttpHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), Object.assign({ abortSignal: options.abortSignal, fileContentLength: length, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Updates user-defined metadata for the specified file.
     *
     * If no metadata defined in the option parameter, the file
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to File Set Metadata operation.
     * @returns Response data for the File Set Metadata operation.
     */
    async setMetadata(metadata = {}, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-setMetadata", options);
        try {
            return await this.context.setMetadata(Object.assign({ abortSignal: options.abortSignal, metadata, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Upload a range of bytes to a file. This operation can only be called on an existing file.
     * It won't change the size, properties or metadata of the file.
     * Both the start and count of the range must be specified. The range can be up to 4 MB in size.
     *
     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param offset - Offset position of the destination Azure File to upload.
     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param options - Options to File Upload Range operation.
     * @returns Response data for the File Upload Range operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    async uploadRange(body, offset, contentLength, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadRange", options);
        try {
            if (offset < 0) {
                throw new RangeError(`offset must be >= 0`);
            }
            if (contentLength <= 0 || contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`contentLength must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);
            }
            if (contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`offset must be < ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);
            }
            return await this.context.uploadRange(rangeToString({ count: contentLength, offset }), "update", contentLength, Object.assign(Object.assign({ abortSignal: options.abortSignal, contentMD5: options.contentMD5, requestOptions: {
                    onUploadProgress: options.onProgress
                }, body: body }, convertTracingToRequestOptionsBase(updatedOptions)), { leaseAccessConditions: options.leaseAccessConditions }));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Upload a range of bytes to a file where the contents are read from a another file's URL.
     * The range can be up to 4 MB in size.
     *
     * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.
     * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source file.
     * @param destOffset - Offset of destination file.
     * @param count - Number of bytes to be uploaded from source file.
     * @param options - Options to configure File - Upload Range from URL operation.
     */
    async uploadRangeFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadRangeFromURL", options);
        try {
            if (sourceOffset < 0 || destOffset < 0) {
                throw new RangeError(`sourceOffset and destOffset must be >= 0`);
            }
            if (count <= 0 || count > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`count must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES} bytes`);
            }
            return await this.context.uploadRangeFromURL(rangeToString({ offset: destOffset, count }), sourceURL, 0, Object.assign(Object.assign({ abortSignal: options.abortSignal, sourceRange: rangeToString({ offset: sourceOffset, count }), sourceModifiedAccessConditions: options.sourceConditions, copySourceAuthorization: httpAuthorizationToString(options.sourceAuthorization) }, options), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Clears the specified range and
     * releases the space used in storage for that range.
     *
     * @param offset -
     * @param contentLength -
     * @param options - Options to File Clear Range operation.
     */
    async clearRange(offset, contentLength, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-clearRange", options);
        try {
            if (offset < 0 || contentLength <= 0) {
                throw new RangeError(`offset must >= 0 and contentLength must be > 0`);
            }
            return await this.context.uploadRange(rangeToString({ count: contentLength, offset }), "clear", 0, Object.assign(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)), { leaseAccessConditions: options.leaseAccessConditions }));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns the list of valid ranges for a file.
     *
     * @param options - Options to File Get range List operation.
     */
    async getRangeList(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-getRangeList", options);
        try {
            const originalResponse = await this.context.getRangeList(Object.assign({ abortSignal: options.abortSignal, range: options.range ? rangeToString(options.range) : undefined, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
            // Only returns ranges, ignoring clearRanges.
            const parsedBody = originalResponse._response.parsedBody.ranges
                ? originalResponse._response.parsedBody.ranges
                : [];
            return Object.assign(Object.assign({}, originalResponse), { _response: Object.assign(Object.assign({}, originalResponse._response), { parsedBody }), rangeList: originalResponse.ranges ? originalResponse.ranges : [] });
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns the list of ranges that differ between a previous share snapshot and this file.
     *
     * @param prevShareSnapshot - The previous snapshot parameter is an opaque DateTime value that specifies the previous share snapshot to compare with.
     * @param options -
     */
    async getRangeListDiff(prevShareSnapshot, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-getRangeListDiff", options);
        try {
            return await this.context.getRangeList(Object.assign(Object.assign(Object.assign({ prevsharesnapshot: prevShareSnapshot }, options), { range: options.range ? rangeToString(options.range) : undefined }), convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Copies a blob or file to a destination file within the storage account.
     *
     * @param copySource - Specifies the URL of the source file or blob, up to 2 KB in length.
     * To copy a file to another file within the same storage account, you may use Shared Key to
     * authenticate the source file. If you are copying a file from another storage account, or if you
     * are copying a blob from the same storage account or another storage account, then you must
     * authenticate the source file or blob using a shared access signature. If the source is a public
     * blob, no authentication is required to perform the copy operation. A file in a share snapshot
     * can also be specified as a copy source.
     * @param options - Options to File Start Copy operation.
     */
    async startCopyFromURL(copySource, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-startCopyFromURL", options);
        try {
            return await this.context.startCopy(copySource, Object.assign({ abortSignal: options.abortSignal, metadata: options.metadata, leaseAccessConditions: options.leaseAccessConditions, filePermission: options.filePermission, filePermissionKey: options.filePermissionKey, copyFileSmbInfo: options.copyFileSmbInfo }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file
     *
     * @param copyId - Id of the Copy File operation to abort.
     * @param options - Options to File Abort Copy From URL operation.
     */
    async abortCopyFromURL(copyId, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-abortCopyFromURL", options);
        try {
            return await this.context.abortCopy(copyId, Object.assign({ abortSignal: options.abortSignal, leaseAccessConditions: options.leaseAccessConditions }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    // High Level functions
    /**
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Buffer(Node)/Blob/ArrayBuffer/ArrayBufferView to it.
     *
     * @param data - Buffer(Node), Blob, ArrayBuffer or ArrayBufferView
     * @param options -
     */
    async uploadData(data, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadData", options);
        try {
            if (isNode) {
                let buffer;
                if (data instanceof Buffer) {
                    buffer = data;
                }
                else if (data instanceof ArrayBuffer) {
                    buffer = Buffer.from(data);
                }
                else {
                    data = data;
                    buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
                }
                return this.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);
            }
            else {
                const browserBlob = new Blob([data]);
                return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
            }
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,
     * which need to return a Blob object with the offset and size provided.
     *
     * @param blobFactory -
     * @param size -
     * @param options -
     */
    async uploadSeekableBlob(blobFactory, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-UploadSeekableBlob", options);
        try {
            return this.uploadSeekableInternal(blobFactory, size, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a local file to it.
     *
     * @param filePath - Full path of local file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    async uploadFile(filePath, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadFile", options);
        try {
            const size = (await fsStat(filePath)).size;
            return await this.uploadSeekableInternal((offset, count) => {
                return () => fsCreateReadStream(filePath, {
                    autoClose: true,
                    end: count ? offset + count - 1 : Infinity,
                    start: offset
                });
            }, size, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.
     * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset
     * is the offset in the Azure file to be uploaded.
     *
     * @param streamFactory - Returns a Node.js Readable stream starting
     *                                                                  from the offset defined
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    async uploadResetableStream(streamFactory, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadResetableStream", options);
        try {
            return await this.uploadSeekableInternal((offset, count) => {
                return () => streamFactory(offset, count);
            }, size, updatedOptions);
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     *
     * @param bodyFactory -
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    async uploadSeekableInternal(bodyFactory, size, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadSeekableInternal", options);
        try {
            if (!options.rangeSize) {
                options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
            }
            if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`options.rangeSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);
            }
            if (!options.fileHttpHeaders) {
                options.fileHttpHeaders = {};
            }
            if (!options.concurrency) {
                options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
            }
            if (options.concurrency < 0) {
                throw new RangeError(`options.concurrency cannot less than 0.`);
            }
            // Create the file
            await this.create(size, {
                abortSignal: options.abortSignal,
                fileHttpHeaders: options.fileHttpHeaders,
                metadata: options.metadata,
                leaseAccessConditions: options.leaseAccessConditions,
                tracingOptions: updatedOptions.tracingOptions
            });
            const numBlocks = Math.floor((size - 1) / options.rangeSize) + 1;
            let transferProgress = 0;
            const batch = new Batch(options.concurrency);
            for (let i = 0; i < numBlocks; i++) {
                batch.addOperation(async () => {
                    const start = options.rangeSize * i;
                    const end = i === numBlocks - 1 ? size : start + options.rangeSize;
                    const contentLength = end - start;
                    await this.uploadRange(bodyFactory(start, contentLength), start, contentLength, {
                        abortSignal: options.abortSignal,
                        leaseAccessConditions: options.leaseAccessConditions,
                        tracingOptions: updatedOptions.tracingOptions
                    });
                    // Update progress after block is successfully uploaded to server, in case of block trying
                    transferProgress += contentLength;
                    if (options.onProgress) {
                        options.onProgress({ loadedBytes: transferProgress });
                    }
                });
            }
            return await batch.do();
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async downloadToBuffer(bufferOrOffset, offsetOrCount, countOrOptions, optOptions = {}) {
        let buffer = undefined;
        let offset;
        let count;
        let options = optOptions;
        if (bufferOrOffset instanceof Buffer) {
            buffer = bufferOrOffset;
            offset = offsetOrCount || 0;
            count = typeof countOrOptions === "number" ? countOrOptions : 0;
        }
        else {
            offset = typeof bufferOrOffset === "number" ? bufferOrOffset : 0;
            count = typeof offsetOrCount === "number" ? offsetOrCount : 0;
            options = countOrOptions || {};
        }
        const { span, updatedOptions } = createSpan("ShareFileClient-downloadToBuffer", options);
        try {
            if (!options.rangeSize) {
                options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
            }
            if (options.rangeSize < 0) {
                throw new RangeError("rangeSize option must be > 0");
            }
            if (offset < 0) {
                throw new RangeError("offset option must be >= 0");
            }
            if (count && count <= 0) {
                throw new RangeError("count option must be > 0");
            }
            if (!options.concurrency) {
                options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
            }
            if (options.concurrency < 0) {
                throw new RangeError(`options.concurrency cannot less than 0.`);
            }
            // Customer doesn't specify length, get it
            if (!count) {
                const response = await this.getProperties({
                    abortSignal: options.abortSignal,
                    leaseAccessConditions: options.leaseAccessConditions,
                    tracingOptions: updatedOptions.tracingOptions
                });
                count = response.contentLength - offset;
                if (count < 0) {
                    throw new RangeError(`offset ${offset} shouldn't be larger than file size ${response.contentLength}`);
                }
            }
            if (!buffer) {
                try {
                    buffer = Buffer.alloc(count);
                }
                catch (error) {
                    throw new Error(`Unable to allocate a buffer of size: ${count} bytes. Please try passing your own Buffer to ` +
                        'the "downloadToBuffer method or try using other methods like "download" or "downloadToFile".' +
                        `\t ${error.message}`);
                }
            }
            if (buffer.length < count) {
                throw new RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
            }
            let transferProgress = 0;
            const batch = new Batch(options.concurrency);
            for (let off = offset; off < offset + count; off = off + options.rangeSize) {
                batch.addOperation(async () => {
                    // Exclusive chunk end position
                    let chunkEnd = offset + count;
                    if (off + options.rangeSize < chunkEnd) {
                        chunkEnd = off + options.rangeSize;
                    }
                    const response = await this.download(off, chunkEnd - off, {
                        abortSignal: options.abortSignal,
                        maxRetryRequests: options.maxRetryRequestsPerRange,
                        leaseAccessConditions: options.leaseAccessConditions,
                        tracingOptions: updatedOptions.tracingOptions
                    });
                    const stream = response.readableStreamBody;
                    await streamToBuffer(stream, buffer, off - offset, chunkEnd - offset);
                    // Update progress after block is downloaded, in case of block trying
                    // Could provide finer grained progress updating inside HTTP requests,
                    // only if convenience layer download try is enabled
                    transferProgress += chunkEnd - off;
                    if (options.onProgress) {
                        options.onProgress({ loadedBytes: transferProgress });
                    }
                });
            }
            await batch.do();
            return buffer;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Node.js Readable stream into it.
     * This method will try to create an Azure File, then starts uploading chunk by chunk.
     * Size of chunk is defined by `bufferSize` parameter.
     * Please make sure potential size of stream doesn't exceed file size.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *   parameter, which will avoid Buffer.concat() operations.
     *
     * @param stream - Node.js Readable stream. Must be less or equal than file size.
     * @param size - Size of file to be created. Maximum size allowed is 4 TB.
     *                      If this value is larger than stream size, there will be empty bytes in file tail.
     * @param bufferSize - Size of every buffer allocated in bytes, also the chunk/range size during
     *                            the uploaded file. Size must be greater than 0 and lesser than or equal to 4 * 1024 * 1024 (4MB)
     * @param maxBuffers - Max buffers will allocate during uploading, positive correlation
     *                            with max uploading concurrency
     * @param options -
     */
    async uploadStream(stream, size, bufferSize, maxBuffers, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-uploadStream", options);
        try {
            if (!options.fileHttpHeaders) {
                options.fileHttpHeaders = {};
            }
            if (bufferSize <= 0 || bufferSize > FILE_RANGE_MAX_SIZE_BYTES) {
                throw new RangeError(`bufferSize must be > 0 and <= ${FILE_RANGE_MAX_SIZE_BYTES}`);
            }
            if (maxBuffers < 0) {
                throw new RangeError(`maxBuffers must be > 0.`);
            }
            // Create the file
            await this.create(size, {
                abortSignal: options.abortSignal,
                fileHttpHeaders: options.fileHttpHeaders,
                metadata: options.metadata,
                leaseAccessConditions: options.leaseAccessConditions,
                tracingOptions: updatedOptions.tracingOptions
            });
            let transferProgress = 0;
            const scheduler = new BufferScheduler(stream, bufferSize, maxBuffers, async (buffer, offset) => {
                if (transferProgress + buffer.length > size) {
                    throw new RangeError(`Stream size is larger than file size ${size} bytes, uploading failed. ` +
                        `Please make sure stream length is less or equal than file size.`);
                }
                await this.uploadRange(buffer, offset, buffer.length, {
                    abortSignal: options.abortSignal,
                    leaseAccessConditions: options.leaseAccessConditions,
                    tracingOptions: updatedOptions.tracingOptions
                });
                // Update progress after block is successfully uploaded to server, in case of block trying
                transferProgress += buffer.length;
                if (options.onProgress) {
                    options.onProgress({ loadedBytes: transferProgress });
                }
            }, 
            // Concurrency should set a smaller value than maxBuffers, which is helpful to
            // reduce the possibility when a outgoing handler waits for stream data, in
            // this situation, outgoing handlers are blocked.
            // Outgoing queue shouldn't be empty.
            Math.ceil((maxBuffers / 4) * 3));
            return await scheduler.do();
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param filePath -
     * @param offset - From which position of the block blob to download.
     * @param count - How much data to be downloaded. Will download to the end when passing undefined.
     * @param options - Options to Blob download options.
     * @returns The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     */
    async downloadToFile(filePath, offset = 0, count, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-downloadToFile", options);
        try {
            const response = await this.download(offset, count, updatedOptions);
            if (response.readableStreamBody) {
                await readStreamToLocalFile(response.readableStreamBody, filePath);
            }
            // The stream is no longer accessible so setting it to undefined.
            response.fileDownloadStream = undefined;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Lists handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    async listHandlesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-listHandlesSegment", options);
        try {
            marker = marker === "" ? undefined : marker;
            const response = await this.context.listHandles(Object.assign(Object.assign({ abortSignal: options.abortSignal, marker }, options), convertTracingToRequestOptionsBase(updatedOptions)));
            // TODO: Protocol layer issue that when handle list is in returned XML
            // response.handleList is an empty string
            if (response.handleList === "") {
                response.handleList = undefined;
            }
            return response;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns an AsyncIterableIterator for FileListHandlesResponse
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    iterateHandleSegments(marker, options = {}) {
        return __asyncGenerator(this, arguments, function* iterateHandleSegments_2() {
            let listHandlesResponse;
            if (!!marker || marker === undefined) {
                do {
                    listHandlesResponse = yield __await(this.listHandlesSegment(marker, options));
                    marker = listHandlesResponse.continuationToken;
                    yield yield __await(listHandlesResponse);
                } while (marker);
            }
        });
    }
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    listHandleItems(options = {}) {
        return __asyncGenerator(this, arguments, function* listHandleItems_2() {
            var e_3, _a;
            let marker;
            try {
                for (var _b = __asyncValues(this.iterateHandleSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const listHandlesResponse = _c.value;
                    if (listHandlesResponse.handleList) {
                        for (const handle of listHandlesResponse.handleList) {
                            yield yield __await(handle);
                        }
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    listHandles(options = {}) {
        // an AsyncIterableIterator to iterate over handles
        const iter = this.listHandleItems(options);
        return {
            /**
             * The next method, part of the iteration protocol
             */
            async next() {
                return iter.next();
            },
            /**
             * The connection to the async iterator, part of the iteration protocol
             */
            [Symbol.asyncIterator]() {
                return this;
            },
            /**
             * Return an AsyncIterableIterator that works a page at a time
             */
            byPage: (settings = {}) => {
                return this.iterateHandleSegments(settings.continuationToken, Object.assign({ maxPageSize: settings.maxPageSize }, options));
            }
        };
    }
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options - Options to force close handles operation.
     */
    async forceCloseHandlesSegment(marker, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-forceCloseHandlesSegment", options);
        try {
            marker = marker === "" ? undefined : marker;
            const rawResponse = await this.context.forceCloseHandles("*", Object.assign({ abortSignal: options.abortSignal, marker }, convertTracingToRequestOptionsBase(updatedOptions)));
            const response = rawResponse;
            response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
            response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options - Options to force close handles operation.
     */
    async forceCloseAllHandles(options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-forceCloseAllHandles", options);
        try {
            let handlesClosed = 0;
            let numberOfHandlesFailedToClose = 0;
            let marker = "";
            do {
                const response = await this.forceCloseHandlesSegment(marker, { tracingOptions: updatedOptions.tracingOptions });
                marker = response.marker;
                if (response.closedHandlesCount) {
                    handlesClosed += response.closedHandlesCount;
                }
                if (response.closeFailureCount) {
                    numberOfHandlesFailedToClose += response.closeFailureCount;
                }
            } while (marker);
            return {
                closedHandlesCount: handlesClosed,
                closeFailureCount: numberOfHandlesFailedToClose
            };
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Force close a specific handle for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseAllHandles() to close all handles.
     * @param FileForceCloseHandlesOptions - Options to force close handles operation.
     */
    async forceCloseHandle(handleId, options = {}) {
        const { span, updatedOptions } = createSpan("ShareFileClient-forceCloseHandle", options);
        try {
            if (handleId === "*") {
                throw new RangeError(`Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.`);
            }
            const rawResponse = await this.context.forceCloseHandles(handleId, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
            const response = rawResponse;
            response.closedHandlesCount = rawResponse.numberOfHandlesClosed || 0;
            response.closeFailureCount = rawResponse.numberOfHandlesFailedToClose || 0;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Get a {@link ShareLeaseClient} that manages leases on the file.
     *
     * @param proposeLeaseId - Initial proposed lease Id.
     * @returns A new ShareLeaseClient object for managing leases on the file.
     */
    getShareLeaseClient(proposeLeaseId) {
        return new ShareLeaseClient(this, proposeLeaseId);
    }
    /**
     * Only available for clients constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateSasUrl(options) {
        if (!(this.credential instanceof StorageSharedKeyCredential)) {
            throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        }
        const sas = generateFileSASQueryParameters(Object.assign({ shareName: this.shareName, filePath: this.path }, options), this.credential).toString();
        return appendToURLQuery(this.url, sas);
    }
}
/**
 * A client that manages leases for a {@link ShareFileClient} or {@link ShareClient}.
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-file
 * and
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-share
 */
export class ShareLeaseClient {
    /**
     * Creates an instance of ShareLeaseClient.
     * @param client - The client to make the lease operation requests.
     * @param leaseId - Initial proposed lease id.
     */
    constructor(client, leaseId) {
        const clientContext = new StorageClientContext(client.url, Object.assign({ version: SERVICE_VERSION }, client.pipeline.toServiceClientOptions()));
        if (client instanceof ShareClient) {
            this.isShare = true;
            this.fileOrShare = new Share(clientContext);
        }
        else {
            this.isShare = false;
            this.fileOrShare = new File(clientContext);
        }
        this._url = client.url;
        if (!leaseId) {
            leaseId = generateUuid();
        }
        this._leaseId = leaseId;
    }
    /**
     * Gets the lease Id.
     *
     * @readonly
     */
    get leaseId() {
        return this._leaseId;
    }
    /**
     * Gets the url.
     *
     * @readonly
     */
    get url() {
        return this._url;
    }
    /**
     * Establishes and manages a lock on a file, share or share snapshot for write and delete operations.
     *
     * @param duration - Specifies the duration of lease in seconds. For file, the only allowed value is -1 for a lease that never expires. For share, must be -1 or between 15 to 60.
     * @param options - Options for the lease management operation.
     * @returns Response data for acquire lease operation.
     */
    async acquireLease(duration = -1, options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-acquireLease", options);
        try {
            return await this.fileOrShare.acquireLease(Object.assign({ abortSignal: options.abortSignal, duration, proposedLeaseId: this._leaseId }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * To change the ID of an existing lease.
     *
     * @param proposedLeaseId - the proposed new lease Id.
     * @param options - Options for the lease management operation.
     * @returns Response data for change lease operation.
     */
    async changeLease(proposedLeaseId, options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-changeLease", options);
        try {
            const response = await this.fileOrShare.changeLease(this._leaseId, Object.assign({ proposedLeaseId, abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
            this._leaseId = proposedLeaseId;
            return response;
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * To free the lease if it is no longer needed so that another client may
     * immediately acquire a lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for release lease operation.
     */
    async releaseLease(options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-releaseLease", options);
        try {
            return await this.fileOrShare.releaseLease(this._leaseId, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * To force end the lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for break lease operation.
     */
    async breakLease(options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-breakLease", options);
        try {
            return await this.fileOrShare.breakLease(Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * To renew the lease. Only available for lease on share or share snapshot.
     * Note that the lease may be renewed even if it has expired as long as the share has not been leased again since the expiration of that lease.
     * When you renew a lease, the lease duration clock resets.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for renew lease operation.
     */
    async renewLease(options = {}) {
        const { span, updatedOptions } = createSpan("ShareLeaseClient-renewLease", options);
        if (!this.isShare) {
            throw new RangeError("The renewLease operation is not available for lease on file.");
        }
        try {
            return await this.fileOrShare.renewLease(this._leaseId, Object.assign({ abortSignal: options.abortSignal }, convertTracingToRequestOptionsBase(updatedOptions)));
        }
        catch (e) {
            span.setStatus({
                code: SpanStatusCode.ERROR,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
}
//# sourceMappingURL=Clients.js.map