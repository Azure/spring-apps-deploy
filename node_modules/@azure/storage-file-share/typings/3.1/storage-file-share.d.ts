/// <reference types="node" />
import { AbortSignalLike } from '@azure/abort-controller';
import { BaseRequestPolicy } from '@azure/core-http';
import * as coreHttp from '@azure/core-http';
import { deserializationPolicy } from '@azure/core-http';
import { HttpHeaders } from '@azure/core-http';
import { HttpOperationResponse } from '@azure/core-http';
import { HttpRequestBody } from '@azure/core-http';
import { HttpResponse } from '@azure/core-http';
import { HttpClient as IHttpClient } from '@azure/core-http';
import { KeepAliveOptions } from '@azure/core-http';
import { OperationTracingOptions } from '@azure/core-tracing';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { ProxyOptions } from '@azure/core-http';
import { Readable } from 'stream';
import { RequestPolicy } from '@azure/core-http';
import { RequestPolicyFactory } from '@azure/core-http';
import { RequestPolicyOptions } from '@azure/core-http';
import { RestError } from '@azure/core-http';
import { ServiceClientOptions } from '@azure/core-http';
import { TransferProgressEvent } from '@azure/core-http';
import { UserAgentOptions } from '@azure/core-http';
import { WebResource } from '@azure/core-http';
/** An Access policy. */
export declare interface AccessPolicy {
    /** The date-time the policy is active. */
    startsOn?: string;
    /** The date-time the policy expires. */
    expiresOn?: string;
    /** The permissions for the ACL policy. */
    permissions?: string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant permissions for that operation. Once all the
 * values are set, this should be serialized with toString and set as the permissions field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */
export declare class AccountSASPermissions {
    /**
     * Parse initializes the AccountSASPermissions fields from a string.
     *
     * @param permissions -
     */
    static parse(permissions: string): AccountSASPermissions;
    /**
     * Permission to read resources and list queues and tables granted.
     */
    read: boolean;
    /**
     * Permission to write resources granted.
     */
    write: boolean;
    /**
     * Permission to delete blobs and files granted.
     */
    delete: boolean;
    /**
     * Permission to list blob containers, blobs, shares, directories, and files granted.
     */
    list: boolean;
    /**
     * Permission to add messages, table entities, and append to blobs granted.
     */
    add: boolean;
    /**
     * Permission to create blobs and files granted.
     */
    create: boolean;
    /**
     * Permissions to update messages and table entities granted.
     */
    update: boolean;
    /**
     * Permission to get and delete messages granted.
     */
    process: boolean;
    /**
     * Produces the SAS permissions string for an Azure Storage account.
     * Call this method to set AccountSASSignatureValues Permissions field.
     *
     * Using this method will guarantee the resource types are in
     * an order accepted by the service.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     */
    toString(): string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the resources accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that resource type. Once all the
 * values are set, this should be serialized with toString and set as the resources field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the resources string without this class, but
 * the order of the resources is particular and this class guarantees correctness.
 */
export declare class AccountSASResourceTypes {
    /**
     * Creates an {@link AccountSASResourceTypes} from the specified resource types string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid resource type.
     *
     * @param resourceTypes -
     */
    static parse(resourceTypes: string): AccountSASResourceTypes;
    /**
     * Permission to access service level APIs granted.
     */
    service: boolean;
    /**
     * Permission to access container level APIs (Blob Containers, Tables, Queues, File Shares) granted.
     */
    container: boolean;
    /**
     * Permission to access object level APIs (Blobs, Table Entities, Queue Messages, Files) granted.
     */
    object: boolean;
    /**
     * Converts the given resource types to a string.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
     *
     */
    toString(): string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the services accessible by an AccountSAS. Setting a value
 * to true means that any SAS which uses these permissions will grant access to that service. Once all the
 * values are set, this should be serialized with toString and set as the services field on an
 * {@link AccountSASSignatureValues} object. It is possible to construct the services string without this class, but
 * the order of the services is particular and this class guarantees correctness.
 */
export declare class AccountSASServices {
    /**
     * Creates an {@link AccountSASServices} from the specified services string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid service.
     *
     * @param services -
     */
    static parse(services: string): AccountSASServices;
    /**
     * Permission to access blob resources granted.
     */
    blob: boolean;
    /**
     * Permission to access file resources granted.
     */
    file: boolean;
    /**
     * Permission to access queue resources granted.
     */
    queue: boolean;
    /**
     * Permission to access table resources granted.
     */
    table: boolean;
    /**
     * Converts the given services to a string.
     *
     */
    toString(): string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * AccountSASSignatureValues is used to generate a Shared Access Signature (SAS) for an Azure Storage account. Once
 * all the values here are set appropriately, call {@link generateAccountSASQueryParameters} to obtain a representation of the SAS
 * which can actually be applied to file urls. Note: that both this class and {@link SASQueryParameters} exist because
 * the former is mutable and a logical representation while the latter is immutable and used to generate actual REST
 * requests.
 *
 * @see https://docs.microsoft.com/en-us/azure/storage/common/storage-dotnet-shared-access-signature-part-1
 * for more conceptual information on SAS
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
 * for descriptions of the parameters, including which are required
 */
export declare interface AccountSASSignatureValues {
    /**
     * If not provided, this defaults to the service version targeted by this version of the library.
     */
    version?: string;
    /**
     * Optional. SAS protocols allowed.
     */
    protocol?: SASProtocol;
    /**
     * Optional. When the SAS will take effect.
     */
    startsOn?: Date;
    /**
     * The time after which the SAS will no longer work.
     */
    expiresOn: Date;
    /**
     * Specifies which operations the SAS user may perform. Please refer to {@link AccountSASPermissions} for help
     * constructing the permissions string.
     */
    permissions: AccountSASPermissions;
    /**
     * Optional. IP range allowed.
     */
    ipRange?: SasIPRange;
    /**
     * The values that indicate the services accessible with this SAS. Please refer to {@link AccountSASServices} to
     * construct this value.
     */
    services: string;
    /**
     * The values that indicate the resource types accessible with this SAS. Please refer
     * to {@link AccountSASResourceTypes} to construct this value.
     */
    resourceTypes: string;
}
/**
 * AnonymousCredential provides a credentialPolicyCreator member used to create
 * {@link AnonymousCredentialPolicy} objects. AnonymousCredentialPolicy is used with
 * HTTP(S) requests that read public resources or for use with Shared Access
 * Signatures (SAS).
 */
export declare class AnonymousCredential extends Credential {
    /**
     * Creates an {@link AnonymousCredentialPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): AnonymousCredentialPolicy;
}
/**
 * AnonymousCredentialPolicy is used with HTTP(S) requests that read public resources
 * or for use with Shared Access Signatures (SAS).
 */
export declare class AnonymousCredentialPolicy extends CredentialPolicy {
    /**
     * Creates an instance of AnonymousCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     */
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
}
export { BaseRequestPolicy };
export declare interface ClearRange {
    start: number;
    end: number;
}
/**
 * Close handles result information.
 */
export declare interface CloseHandlesInfo {
    closedHandlesCount: number;
    /**
     * Contains count of number of handles that failed to close.
     */
    closeFailureCount?: number;
}
/**
 * Common options of the {@link ShareGenerateSasUrlOptions} and {@link FileGenerateSasUrlOptions}.
 */
export declare interface CommonGenerateSasUrlOptions {
    /**
     * The version of the service this SAS will target. If not specified, it will default to the version targeted by the
     * library.
     */
    version?: string;
    /**
     * Optional. SAS protocols, HTTPS only or HTTPSandHTTP
     */
    protocol?: SASProtocol;
    /**
     * Optional. When the SAS will take effect.
     */
    startsOn?: Date;
    /**
     * Optional only when identifier is provided. The time after which the SAS will no longer work.
     */
    expiresOn?: Date;
    /**
     * Optional. IP ranges allowed in this SAS.
     */
    ipRange?: SasIPRange;
    /**
     * Optional. The name of the access policy on the share this SAS references if any.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy
     */
    identifier?: string;
    /**
     * Optional. The cache-control header for the SAS.
     */
    cacheControl?: string;
    /**
     * Optional. The content-disposition header for the SAS.
     */
    contentDisposition?: string;
    /**
     * Optional. The content-encoding header for the SAS.
     */
    contentEncoding?: string;
    /**
     * Optional. The content-language header for the SAS.
     */
    contentLanguage?: string;
    /**
     * Optional. The content-type header for the SAS.
     */
    contentType?: string;
}
/**
 * An interface for options common to every remote operation.
 */
export declare interface CommonOptions {
    tracingOptions?: OperationTracingOptions;
}
/** Parameter group */
export declare interface CopyFileSmbInfo {
    /** Specifies the option to copy file security descriptor from source file or to set it using the value which is defined by the header value of x-ms-file-permission or x-ms-file-permission-key. */
    filePermissionCopyMode?: PermissionCopyModeType;
    /** Specifies the option to overwrite the target file if it already exists and has read-only attribute set. */
    ignoreReadOnly?: boolean;
    /** Specifies either the option to copy file attributes from a source file(source) to a target file or a list of attributes to set on a target file. */
    fileAttributes?: string;
    /** Specifies either the option to copy file creation time from a source file(source) to a target file or a time value in ISO 8601 format to set as creation time on a target file. */
    fileCreationTime?: string;
    /** Specifies either the option to copy file last write time from a source file(source) to a target file or a time value in ISO 8601 format to set as last write time on a target file. */
    fileLastWriteTime?: string;
    /** Specifies the option to set archive attribute on a target file. True means archive attribute will be set on a target file despite attribute overrides or a source file state. */
    setArchiveAttribute?: boolean;
}
/** Defines values for CopyStatusType. */
export declare type CopyStatusType = "pending" | "success" | "aborted" | "failed";
/** CORS is an HTTP feature that enables a web application running under one domain to access resources in another domain. Web browsers implement a security restriction known as same-origin policy that prevents a web page from calling APIs in a different domain; CORS provides a secure way to allow one domain (the origin domain) to call APIs in another domain. */
export declare interface CorsRule {
    /** The origin domains that are permitted to make a request against the storage service via CORS. The origin domain is the domain from which the request originates. Note that the origin must be an exact case-sensitive match with the origin that the user age sends to the service. You can also use the wildcard character '*' to allow all origin domains to make requests via CORS. */
    allowedOrigins: string;
    /** The methods (HTTP request verbs) that the origin domain may use for a CORS request. (comma separated) */
    allowedMethods: string;
    /** The request headers that the origin domain may specify on the CORS request. */
    allowedHeaders: string;
    /** The response headers that may be sent in the response to the CORS request and exposed by the browser to the request issuer. */
    exposedHeaders: string;
    /** The maximum amount time that a browser should cache the preflight OPTIONS request. */
    maxAgeInSeconds: number;
}
/**
 * Credential is an abstract class for Azure Storage HTTP requests signing. This
 * class will host an credentialPolicyCreator factory which generates CredentialPolicy.
 */
export declare abstract class Credential implements RequestPolicyFactory {
    /**
     * Creates a RequestPolicy object.
     *
     * @param _nextPolicy -
     * @param _options -
     */
    create(_nextPolicy: RequestPolicy, _options: RequestPolicyOptions): RequestPolicy;
}
/**
 * Credential policy used to sign HTTP(S) requests before sending. This is an
 * abstract class.
 */
export declare abstract class CredentialPolicy extends BaseRequestPolicy {
    /**
     * Sends out request.
     *
     * @param request -
     */
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    /**
     * Child classes must implement this method with request signing. This method
     * will be executed in {@link sendRequest}.
     *
     * @param request -
     */
    protected signRequest(request: WebResource): WebResource;
}
/**
 * A factory function that creates a new CredentialPolicy that uses the provided nextPolicy.
 */
export declare type CredentialPolicyCreator = (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => CredentialPolicy;
/** Defines values for DeleteSnapshotsOptionType. */
export declare type DeleteSnapshotsOptionType = "include" | "include-leased";
export { deserializationPolicy };
/**
 * Additional response header values for close handles request.
 */
export declare interface DirectoryCloseHandlesHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * A string describing next handle to be closed. It is returned when more handles need to be
     * closed to complete the request.
     */
    marker?: string;
}
/** Defines headers for Directory_create operation. */
export declare interface DirectoryCreateHeaders {
    /** The ETag contains a value which represents the version of the directory, in quotes. */
    etag?: string;
    /** Returns the date and time the share was last modified. Any operation that modifies the directory or its properties updates the last modified time. Operations on files do not affect the last modified time of the directory. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise. */
    isServerEncrypted?: boolean;
    /** Key of the permission set for the directory. */
    filePermissionKey?: string;
    /** Attributes set for the directory. */
    fileAttributes?: string;
    /** Creation time for the directory. */
    fileCreatedOn?: Date;
    /** Last write time for the directory. */
    fileLastWriteOn?: Date;
    /** Change time for the directory. */
    fileChangeOn?: Date;
    /** The fileId of the directory. */
    fileId?: string;
    /** The parent fileId of the directory. */
    fileParentId?: string;
    /** Error Code */
    errorCode?: string;
}
/**
 * Contains response data for the {@link DirectoryClient.createIfNotExists} operation.
 */
export declare interface DirectoryCreateIfNotExistsResponse extends DirectoryCreateResponse {
    /**
     * Indicate whether the directory is successfully created. Is false when the directory is not changed as it already exists.
     */
    succeeded: boolean;
}
/**
 * Options to configure {@link ShareDirectoryClient.create} operation.
 */
export declare interface DirectoryCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * A collection of key-value string pair to associate with the file storage object.
     */
    metadata?: Metadata;
}
/** Contains response data for the create operation. */
export declare type DirectoryCreateResponse = DirectoryCreateHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: DirectoryCreateHeaders;
    };
};
/** Defines headers for Directory_delete operation. */
export declare interface DirectoryDeleteHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Contains response data for the {@link DirectoryClient.deleteIfExists} operation.
 */
export declare interface DirectoryDeleteIfExistsResponse extends DirectoryDeleteResponse {
    /**
     * Indicate whether the directory is successfully deleted. Is false if the directory does not exist in the first place.
     */
    succeeded: boolean;
}
/**
 * Options to configure the {@link ShareDirectoryClient.delete} operation.
 */
export declare interface DirectoryDeleteOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Contains response data for the delete operation. */
export declare type DirectoryDeleteResponse = DirectoryDeleteHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: DirectoryDeleteHeaders;
    };
};
/**
 * Options to configure the {@link ShareDirectoryClient.exists} operation.
 */
export declare interface DirectoryExistsOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Defines headers for Directory_forceCloseHandles operation. */
export declare interface DirectoryForceCloseHandlesHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** A string describing next handle to be closed. It is returned when more handles need to be closed to complete the request. */
    marker?: string;
    /** Contains count of number of handles closed. */
    numberOfHandlesClosed?: number;
    /** Contains count of number of handles that failed to close. */
    numberOfHandlesFailedToClose?: number;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure {@link ShareDirectoryClient.forceCloseHandle}.
 */
export declare interface DirectoryForceCloseHandlesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Response type for {@link ShareDirectoryClient.forceCloseHandle}.
 */
export declare type DirectoryForceCloseHandlesResponse = CloseHandlesInfo & DirectoryCloseHandlesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: DirectoryForceCloseHandlesHeaders;
    };
};
/**
 * Options to configure Directory - Force Close Handles Segment operations.
 *
 * See:
 * - {@link ShareDirectoryClient.forceCloseHandlesSegment}
 * - {@link ShareDirectoryClient.forceCloseAllHandles}
 */
export declare interface DirectoryForceCloseHandlesSegmentOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies operation should apply to the directory specified in the URI, its files, its
     * subdirectories and their files.
     */
    recursive?: boolean;
}
/** Defines headers for Directory_getProperties operation. */
export declare interface DirectoryGetPropertiesHeaders {
    /** A set of name-value pairs that contain metadata for the directory. */
    metadata?: {
        [propertyName: string]: string;
    };
    /** The ETag contains a value that you can use to perform operations conditionally, in quotes. */
    etag?: string;
    /** Returns the date and time the Directory was last modified. Operations on files within the directory do not affect the last modified time of the directory. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** The value of this header is set to true if the directory metadata is completely encrypted using the specified algorithm. Otherwise, the value is set to false. */
    isServerEncrypted?: boolean;
    /** Attributes set for the directory. */
    fileAttributes?: string;
    /** Creation time for the directory. */
    fileCreatedOn?: Date;
    /** Last write time for the directory. */
    fileLastWriteOn?: Date;
    /** Change time for the directory. */
    fileChangeOn?: Date;
    /** Key of the permission set for the directory. */
    filePermissionKey?: string;
    /** The fileId of the directory. */
    fileId?: string;
    /** The parent fileId of the directory. */
    fileParentId?: string;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareDirectoryClient.getProperties} operation.
 */
export declare interface DirectoryGetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Contains response data for the getProperties operation. */
export declare type DirectoryGetPropertiesResponse = DirectoryGetPropertiesHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: DirectoryGetPropertiesHeaders;
    };
};
/** A listed directory item. */
export declare interface DirectoryItem {
    name: string;
    fileId?: string;
    /** File properties. */
    properties?: FileProperty;
    attributes?: string;
    permissionKey?: string;
}
/**
 * Options to configure {@link ShareDirectoryClient.listFilesAndDirectories} operation.
 */
export declare interface DirectoryListFilesAndDirectoriesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Filters the results to return only entries whose
     * name begins with the specified prefix.
     */
    prefix?: string;
    includeTimestamps?: boolean;
    includeEtag?: boolean;
    includeAttributes?: boolean;
    includePermissionKey?: boolean;
    /**
     * Optional. Specified that extended info should be included in the returned {@link FileItem} or {@link DirectoryItem}.
     * If true, the Content-Length property will be up-to-date, FileId will be returned in response.
     */
    includeExtendedInfo?: boolean;
}
/** Defines headers for Directory_listFilesAndDirectoriesSegment operation. */
export declare interface DirectoryListFilesAndDirectoriesSegmentHeaders {
    /** Specifies the format in which the results are returned. Currently this value is 'application/xml'. */
    contentType?: string;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/** Contains response data for the listFilesAndDirectoriesSegment operation. */
export declare type DirectoryListFilesAndDirectoriesSegmentResponse = DirectoryListFilesAndDirectoriesSegmentHeaders & ListFilesAndDirectoriesSegmentResponse & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: ListFilesAndDirectoriesSegmentResponse;
        /** The parsed HTTP response headers. */
        parsedHeaders: DirectoryListFilesAndDirectoriesSegmentHeaders;
    };
};
/** Defines headers for Directory_listHandles operation. */
export declare interface DirectoryListHandlesHeaders {
    /** Specifies the format in which the results are returned. Currently this value is 'application/xml'. */
    contentType?: string;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareDirectoryClient.listHandles} operation.
 */
export declare interface DirectoryListHandlesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies whether operation should apply to the directory specified in the URI, its files, its
     * subdirectories and their files.
     */
    recursive?: boolean;
}
/** Contains response data for the listHandles operation. */
export declare type DirectoryListHandlesResponse = DirectoryListHandlesHeaders & ListHandlesResponse & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: ListHandlesResponse;
        /** The parsed HTTP response headers. */
        parsedHeaders: DirectoryListHandlesHeaders;
    };
};
/**
 * Options to configure Directory - List Handles Segment operations.
 *
 * See:
 * - {@link ShareDirectoryClient.listHandlesSegment}
 * - {@link ShareDirectoryClient.iterateHandleSegments}
 * - {@link ShareDirectoryClient.listHandleItems}
 *
 */
export declare interface DirectoryListHandlesSegmentOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies the maximum number of entries to return. If the request does not specify maxResults,
     * or specifies a value greater than 5,000, the server will return up to 5,000 items.
     */
    maxResults?: number;
    /**
     * Specifies operation should apply to the directory specified in the URI, its files, its
     * subdirectories and their files.
     */
    recursive?: boolean;
}
export declare interface DirectoryProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Defines headers for Directory_setMetadata operation. */
export declare interface DirectorySetMetadataHeaders {
    /** The ETag contains a value which represents the version of the directory, in quotes. */
    etag?: string;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise. */
    isServerEncrypted?: boolean;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareDirectoryClient.setMetadata} operation.
 */
export declare interface DirectorySetMetadataOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Contains response data for the setMetadata operation. */
export declare type DirectorySetMetadataResponse = DirectorySetMetadataHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: DirectorySetMetadataHeaders;
    };
};
/** Defines headers for Directory_setProperties operation. */
export declare interface DirectorySetPropertiesHeaders {
    /** The ETag contains a value which represents the version of the file, in quotes. */
    etag?: string;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Returns the date and time the directory was last modified. Any operation that modifies the directory or its properties updates the last modified time. Operations on files do not affect the last modified time of the directory. */
    lastModified?: Date;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise. */
    isServerEncrypted?: boolean;
    /** Key of the permission set for the directory. */
    filePermissionKey?: string;
    /** Attributes set for the directory. */
    fileAttributes?: string;
    /** Creation time for the directory. */
    fileCreatedOn?: Date;
    /** Last write time for the directory. */
    fileLastWriteOn?: Date;
    /** Change time for the directory. */
    fileChangeOn?: Date;
    /** The fileId of the directory. */
    fileId?: string;
    /** The parent fileId of the directory. */
    fileParentId?: string;
    /** Error Code */
    errorCode?: string;
}
/** Contains response data for the setProperties operation. */
export declare type DirectorySetPropertiesResponse = DirectorySetPropertiesHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: DirectorySetPropertiesHeaders;
    };
};
/**
 * Options to configure the {@link ShareFileClient.abortCopyFromURL} operation.
 */
export declare interface FileAbortCopyFromURLOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Defines headers for File_abortCopy operation. */
export declare interface FileAbortCopyHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/** Contains response data for the abortCopy operation. */
export declare type FileAbortCopyResponse = FileAbortCopyHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileAbortCopyHeaders;
    };
};
export declare interface FileAndDirectoryCreateCommonOptions {
    /**
     * The permission(security descriptor) to be set for the file or directory in the
     * Security Descriptor Definition Language (SDDL). If specified, it must have an owner, group, and discretionary access control list (DACL).
     * A value of inherit may be passed to inherit from the parent directory.
     *
     * Note that only one of filePermission or filePermissionKey can be specified.
     * And if both are not specified, inherit will be set to filePermission as default value by client library.
     */
    filePermission?: string | FilePermissionInheritType;
    /**
     * The key of the permission to be set for the file or directory. This can be created using the Create-Permission API.
     *
     * Note that only one of filePermission or filePermissionKey can be specified.
     */
    filePermissionKey?: string;
    /**
     * The file system attributes to be set on the file or directory.
     */
    fileAttributes?: FileSystemAttributes;
    /**
     * The Coordinated Universal Time (UTC) creation time property for the directory.
     * A value of now may be used to indicate the time of the request.
     * By default, the value will be set as now.
     */
    creationTime?: Date | TimeNowType;
    /**
     * The Coordinated Universal Time (UTC) last write property for the directory.
     * A value of now may be used to indicate the time of the request.
     * By default, the value will be set as now.
     */
    lastWriteTime?: Date | TimeNowType;
}
export declare interface FileAndDirectorySetPropertiesCommonOptions {
    /**
     * The permission(security descriptor) to be set for the file or directory in the
     * Security Descriptor Definition Language (SDDL). If specified, it must have an owner, group, and discretionary access control list (DACL).
     * A value of inherit may be passed to inherit from the parent directory.
     * A value of preserve may be passed to keep the value unchanged.
     *
     * Note that only one of filePermission or filePermissionKey can be specified.
     * And if both are not specified, preserve will be set to filePermission as default value by client library.
     */
    filePermission?: string | FilePermissionInheritType | FilePermissionPreserveType;
    /**
     * The key of the permission to be set for the file or directory. This can be created using the Create-Permission API.
     *
     * Note that only one of filePermission or filePermissionKey can be specified.
     */
    filePermissionKey?: string;
    /**
     * The file system attributes to be set on the file or directory.
     */
    fileAttributes?: FileSystemAttributes | FileAttributesPreserveType;
    /**
     * The Coordinated Universal Time (UTC) creation time property for the directory.
     * A value of now may be used to indicate the time of the request.
     * A value of preserve may be passed to keep an existing value unchanged.
     * By default, the value will be set as preserve.
     */
    creationTime?: Date | TimeNowType | TimePreserveType;
    /**
     * The Coordinated Universal Time (UTC) last write property for the directory.
     * A value of now may be used to indicate the time of the request.
     * A value of preserve may be passed to keep an existing value unchanged.
     * By default, the value will be set as preserve.
     */
    lastWriteTime?: Date | TimeNowType | TimePreserveType;
}
/**
 * Indicates keep existing file attributes unchanged.
 */
export declare type FileAttributesPreserveType = "preserve";
/**
 * Options to configure the {@link ShareFileClient.clearRange} operation.
 */
export declare interface FileClearRangeOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Additional response header values for close handles request.
 */
export declare interface FileCloseHandlesHeaders {
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the File service used to execute the request.
     */
    version?: string;
    /**
     * A UTC date/time value generated by the service that indicates the time at which the response
     * was initiated.
     */
    date?: Date;
    /**
     * A string describing next handle to be closed. It is returned when more handles need to be
     * closed to complete the request.
     */
    marker?: string;
}
/** Defines headers for File_create operation. */
export declare interface FileCreateHeaders {
    /** The ETag contains a value which represents the version of the file, in quotes. */
    etag?: string;
    /** Returns the date and time the share was last modified. Any operation that modifies the directory or its properties updates the last modified time. Operations on files do not affect the last modified time of the directory. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise. */
    isServerEncrypted?: boolean;
    /** Key of the permission set for the file. */
    filePermissionKey?: string;
    /** Attributes set for the file. */
    fileAttributes?: string;
    /** Creation time for the file. */
    fileCreatedOn?: Date;
    /** Last write time for the file. */
    fileLastWriteOn?: Date;
    /** Change time for the file. */
    fileChangeOn?: Date;
    /** The fileId of the file. */
    fileId?: string;
    /** The parent fileId of the file. */
    fileParentId?: string;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.create} operation.
 */
export declare interface FileCreateOptions extends FileAndDirectoryCreateCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * File HTTP headers like Content-Type.
     */
    fileHttpHeaders?: FileHttpHeaders;
    /**
     * A collection of key-value string pair to associate with the file storage object.
     */
    metadata?: Metadata;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the create operation. */
export declare type FileCreateResponse = FileCreateHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileCreateHeaders;
    };
};
/** Defines headers for File_delete operation. */
export declare interface FileDeleteHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Contains response data for the {@link ShareFileClient.deleteIfExists} operation.
 */
export declare interface FileDeleteIfExistsResponse extends FileDeleteResponse {
    /**
     * Indicate whether the file is successfully deleted. Is false if the file does not exist in the first place.
     */
    succeeded: boolean;
}
/**
 * Options to configure the {@link ShareFileClient.delete} operation.
 */
export declare interface FileDeleteOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the delete operation. */
export declare type FileDeleteResponse = FileDeleteHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileDeleteHeaders;
    };
};
/** Defines headers for File_download operation. */
export declare interface FileDownloadHeaders {
    /** Returns the date and time the file was last modified. Any operation that modifies the file or its properties updates the last modified time. */
    lastModified?: Date;
    /** A set of name-value pairs associated with this file as user-defined metadata. */
    metadata?: {
        [propertyName: string]: string;
    };
    /** The number of bytes present in the response body. */
    contentLength?: number;
    /** The content type specified for the file. The default content type is 'application/octet-stream' */
    contentType?: string;
    /** Indicates the range of bytes returned if the client requested a subset of the file by setting the Range request header. */
    contentRange?: string;
    /** The ETag contains a value that you can use to perform operations conditionally, in quotes. */
    etag?: string;
    /** If the file has an MD5 hash and the request is to read the full file, this response header is returned so that the client can check for message content integrity. If the request is to read a specified range and the 'x-ms-range-get-content-md5' is set to true, then the request returns an MD5 hash for the range, as long as the range size is less than or equal to 4 MB. If neither of these sets of conditions is true, then no value is returned for the 'Content-MD5' header. */
    contentMD5?: Uint8Array;
    /** Returns the value that was specified for the Content-Encoding request header. */
    contentEncoding?: string;
    /** Returned if it was previously specified for the file. */
    cacheControl?: string;
    /** Returns the value that was specified for the 'x-ms-content-disposition' header and specifies how to process the response. */
    contentDisposition?: string;
    /** Returns the value that was specified for the Content-Language request header. */
    contentLanguage?: string;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** Indicates that the service supports requests for partial file content. */
    acceptRanges?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Conclusion time of the last attempted Copy File operation where this file was the destination file. This value can specify the time of a completed, aborted, or failed copy attempt. */
    copyCompletedOn?: Date;
    /** Only appears when x-ms-copy-status is failed or pending. Describes cause of fatal or non-fatal copy operation failure. */
    copyStatusDescription?: string;
    /** String identifier for the last attempted Copy File operation where this file was the destination file. */
    copyId?: string;
    /** Contains the number of bytes copied and the total bytes in the source in the last attempted Copy File operation where this file was the destination file. Can show between 0 and Content-Length bytes copied. */
    copyProgress?: string;
    /** URL up to 2KB in length that specifies the source file used in the last attempted Copy File operation where this file was the destination file. */
    copySource?: string;
    /** State of the copy operation identified by 'x-ms-copy-id'. */
    copyStatus?: CopyStatusType;
    /** If the file has a MD5 hash, and if request contains range header (Range or x-ms-range), this response header is returned with the value of the whole file's MD5 value. This value may or may not be equal to the value returned in Content-MD5 header, with the latter calculated from the requested range. */
    fileContentMD5?: Uint8Array;
    /** The value of this header is set to true if the file data and application metadata are completely encrypted using the specified algorithm. Otherwise, the value is set to false (when the file is unencrypted, or if only parts of the file/application metadata are encrypted). */
    isServerEncrypted?: boolean;
    /** Attributes set for the file. */
    fileAttributes?: string;
    /** Creation time for the file. */
    fileCreatedOn?: Date;
    /** Last write time for the file. */
    fileLastWriteOn?: Date;
    /** Change time for the file. */
    fileChangeOn?: Date;
    /** Key of the permission set for the file. */
    filePermissionKey?: string;
    /** The fileId of the file. */
    fileId?: string;
    /** The parent fileId of the file. */
    fileParentId?: string;
    /** When a file is leased, specifies whether the lease is of infinite or fixed duration. */
    leaseDuration?: LeaseDurationType;
    /** Lease state of the file. */
    leaseState?: LeaseStateType;
    /** The current lease status of the file. */
    leaseStatus?: LeaseStatusType;
    /** Error Code */
    errorCode?: string;
}
/** Optional parameters. */
export declare interface FileDownloadOptionalParams extends coreHttp.OperationOptions {
    /** Parameter group */
    leaseAccessConditions?: LeaseAccessConditions;
    /** The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting Timeouts for File Service Operations.</a> */
    timeoutInSeconds?: number;
    /** Return file data only from the specified byte range. */
    range?: string;
    /** When this header is set to true and specified together with the Range header, the service returns the MD5 hash for the range, as long as the range is less than or equal to 4 MB in size. */
    rangeGetContentMD5?: boolean;
}
/**
 * Options to configure File - Download operations.
 *
 * See:
 * - {@link ShareFileClient.download}
 * - {@link ShareFileClient.downloadToFile}
 */
export declare interface FileDownloadOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Optional. ONLY AVAILABLE IN NODE.JS.
     *
     * How many retries will perform when original body download stream unexpected ends.
     * Above kind of ends will not trigger retry policy defined in a pipeline,
     * because they doesn't emit network errors.
     *
     * With this option, every additional retry means an additional ShareFileClient.download() request will be made
     * from the broken point, until the requested range has been successfully downloaded or maxRetryRequests is reached.
     *
     * Default value is 5, please set a larger value when loading large files in poor network.
     */
    maxRetryRequests?: number;
    /**
     * When this header is set to true and
     * specified together with the Range header, the service returns the MD5 hash
     * for the range, as long as the range is less than or equal to 4 MB in size.
     */
    rangeGetContentMD5?: boolean;
    /**
     * Download progress updating event handler.
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the download operation. */
export declare type FileDownloadResponseModel = FileDownloadHeaders & {
    /**
     * BROWSER ONLY
     *
     * The response body as a browser Blob.
     * Always `undefined` in node.js.
     */
    blobBody?: Promise<Blob>;
    /**
     * NODEJS ONLY
     *
     * The response body as a node.js Readable stream.
     * Always `undefined` in the browser.
     */
    readableStreamBody?: NodeJS.ReadableStream;
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileDownloadHeaders;
    };
};
/**
 * Option interface for the {@link ShareFileClient.downloadToBuffer} operation.
 */
export declare interface FileDownloadToBufferOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * When downloading Azure files, download method will try to split large file into small ranges.
     * Every small range will be downloaded via a separate request.
     * This option defines size data every small request trying to download.
     * Must be greater than 0, will use the default value if undefined,
     */
    rangeSize?: number;
    /**
     * Optional. ONLY AVAILABLE IN NODE.JS.
     *
     * How many retries will perform when original range download stream unexpected ends.
     * Above kind of ends will not trigger retry policy defined in a pipeline,
     * because they doesn't emit network errors.
     *
     * With this option, every additional retry means an additional ShareFileClient.download() request will be made
     * from the broken point, until the requested range has been successfully downloaded or
     * maxRetryRequestsPerRange is reached.
     *
     * Default value is 5, please set a larger value when in poor network.
     */
    maxRetryRequestsPerRange?: number;
    /**
     * Progress updater.
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Concurrency indicates the maximum number of ranges to download in parallel.
     * If not provided, 5 concurrency will be used by default.
     */
    concurrency?: number;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Options to configure the {@link ShareFileClient.exists} operation.
 */
export declare interface FileExistsOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Defines headers for File_forceCloseHandles operation. */
export declare interface FileForceCloseHandlesHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** A string describing next handle to be closed. It is returned when more handles need to be closed to complete the request. */
    marker?: string;
    /** Contains count of number of handles closed. */
    numberOfHandlesClosed?: number;
    /** Contains count of number of handles that failed to close. */
    numberOfHandlesFailedToClose?: number;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure File - Force Close Handles operations.
 *
 * See:
 * - {@link ShareFileClient.forceCloseHandlesSegment}
 * - {@link ShareFileClient.forceCloseAllHandles}
 * - {@link ShareFileClient.forceCloseHandle}
 */
export declare interface FileForceCloseHandlesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Response type for {@link ShareFileClient.forceCloseHandle}.
 */
export declare type FileForceCloseHandlesResponse = CloseHandlesInfo & FileCloseHandlesHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileForceCloseHandlesHeaders;
    };
};
/**
 * Options to configure {@link ShareFileClient.generateSasUrl} operation.
 */
export declare interface FileGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    /**
     * Optional only when identifier is provided. Specifies the list of permissions to be associated with the SAS.
     */
    permissions?: FileSASPermissions;
}
/** Defines headers for File_getProperties operation. */
export declare interface FileGetPropertiesHeaders {
    /** Returns the date and time the file was last modified. The date format follows RFC 1123. Any operation that modifies the file or its properties updates the last modified time. */
    lastModified?: Date;
    /** A set of name-value pairs associated with this file as user-defined metadata. */
    metadata?: {
        [propertyName: string]: string;
    };
    /** Returns the type File. Reserved for future use. */
    fileType?: FileType;
    /** The size of the file in bytes. This header returns the value of the 'x-ms-content-length' header that is stored with the file. */
    contentLength?: number;
    /** The content type specified for the file. The default content type is 'application/octet-stream' */
    contentType?: string;
    /** The ETag contains a value that you can use to perform operations conditionally, in quotes. */
    etag?: string;
    /** If the Content-MD5 header has been set for the file, the Content-MD5 response header is returned so that the client can check for message content integrity. */
    contentMD5?: Uint8Array;
    /** If the Content-Encoding request header has previously been set for the file, the Content-Encoding value is returned in this header. */
    contentEncoding?: string;
    /** If the Cache-Control request header has previously been set for the file, the Cache-Control value is returned in this header. */
    cacheControl?: string;
    /** Returns the value that was specified for the 'x-ms-content-disposition' header and specifies how to process the response. */
    contentDisposition?: string;
    /** Returns the value that was specified for the Content-Language request header. */
    contentLanguage?: string;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Conclusion time of the last attempted Copy File operation where this file was the destination file. This value can specify the time of a completed, aborted, or failed copy attempt. */
    copyCompletedOn?: Date;
    /** Only appears when x-ms-copy-status is failed or pending. Describes cause of fatal or non-fatal copy operation failure. */
    copyStatusDescription?: string;
    /** String identifier for the last attempted Copy File operation where this file was the destination file. */
    copyId?: string;
    /** Contains the number of bytes copied and the total bytes in the source in the last attempted Copy File operation where this file was the destination file. Can show between 0 and Content-Length bytes copied. */
    copyProgress?: string;
    /** URL up to 2KB in length that specifies the source file used in the last attempted Copy File operation where this file was the destination file. */
    copySource?: string;
    /** State of the copy operation identified by 'x-ms-copy-id'. */
    copyStatus?: CopyStatusType;
    /** The value of this header is set to true if the file data and application metadata are completely encrypted using the specified algorithm. Otherwise, the value is set to false (when the file is unencrypted, or if only parts of the file/application metadata are encrypted). */
    isServerEncrypted?: boolean;
    /** Attributes set for the file. */
    fileAttributes?: string;
    /** Creation time for the file. */
    fileCreatedOn?: Date;
    /** Last write time for the file. */
    fileLastWriteOn?: Date;
    /** Change time for the file. */
    fileChangeOn?: Date;
    /** Key of the permission set for the file. */
    filePermissionKey?: string;
    /** The fileId of the file. */
    fileId?: string;
    /** The parent fileId of the file. */
    fileParentId?: string;
    /** When a file is leased, specifies whether the lease is of infinite or fixed duration. */
    leaseDuration?: LeaseDurationType;
    /** Lease state of the file. */
    leaseState?: LeaseStateType;
    /** The current lease status of the file. */
    leaseStatus?: LeaseStatusType;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.getProperties} operation.
 */
export declare interface FileGetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the getProperties operation. */
export declare type FileGetPropertiesResponse = FileGetPropertiesHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileGetPropertiesHeaders;
    };
};
/** Contains response data for the getRangeList operation. */
export declare type FileGetRangeListDiffResponse = FileGetRangeListHeaders & ShareFileRangeList & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: ShareFileRangeList;
        /** The parsed HTTP response headers. */
        parsedHeaders: FileGetRangeListHeaders;
    };
};
/** Defines headers for File_getRangeList operation. */
export declare interface FileGetRangeListHeaders {
    /** The date/time that the file was last modified. Any operation that modifies the file, including an update of the file's metadata or properties, changes the file's last modified time. */
    lastModified?: Date;
    /** The ETag contains a value which represents the version of the file, in quotes. */
    etag?: string;
    /** The size of the file in bytes. */
    fileContentLength?: number;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * The option is defined as parity to REST definition.
 * While it's not ready to be used now, considering Crc64 of source content is
 * not accessible.
 */
/**
 * Options to configure the {@link ShareFileClient.getRangeList} operation.
 */
export declare interface FileGetRangeListOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Optional. Specifies the range of bytes over which to list ranges, inclusively.
     */
    range?: Range;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the {@link ShareFileClient.getRangeList} operation.
 */
export declare type FileGetRangeListResponse = FileGetRangeListHeaders & {
    /**
     * Range list for an Azure file.
     */
    rangeList: RangeModel[];
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: FileGetRangeListHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: RangeModel[];
    };
};
export declare interface FileHttpHeaders {
    /**
     * Optional. Sets the file's cache
     * control. If specified, this property is stored with the file and returned
     * with a read request.
     */
    fileCacheControl?: string;
    /**
     * Optional. Sets the file's content type.
     * If specified, this property is stored with the file and returned with a
     * read request.
     */
    fileContentType?: string;
    /**
     * Optional. An MD5 hash of the file
     * content. Note that this hash is not validated, as the hashes for the
     * individual blocks were validated when each was uploaded.
     */
    fileContentMD5?: Uint8Array;
    /**
     * Optional. Sets the file's content
     * encoding. If specified, this property is stored with the file and returned
     * with a read request.
     */
    fileContentEncoding?: string;
    /**
     * Optional. Set the file's content
     * language. If specified, this property is stored with the file and returned
     * with a read request.
     */
    fileContentLanguage?: string;
    /**
     * Optional. Sets the file's
     * Content-Disposition header.
     */
    fileContentDisposition?: string;
}
/** A listed file item. */
export declare interface FileItem {
    name: string;
    fileId?: string;
    /** File properties. */
    properties: FileProperty;
    attributes?: string;
    permissionKey?: string;
}
/** Defines headers for File_listHandles operation. */
export declare interface FileListHandlesHeaders {
    /** Specifies the format in which the results are returned. Currently this value is 'application/xml'. */
    contentType?: string;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
export declare interface FileListHandlesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Contains response data for the listHandles operation. */
export declare type FileListHandlesResponse = FileListHandlesHeaders & ListHandlesResponse & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: ListHandlesResponse;
        /** The parsed HTTP response headers. */
        parsedHeaders: FileListHandlesHeaders;
    };
};
/**
 * Options to configure File - List Handles Segment operations.
 *
 * See:
 * - {@link ShareFileClient.listHandlesSegment}
 * - {@link ShareFileClient.iterateHandleSegments}
 * - {@link ShareFileClient.listHandleItems}
 */
export declare interface FileListHandlesSegmentOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies the maximum number of entries to return. If the request does not specify maxResults,
     * or specifies a value greater than 5,000, the server will return up to 5,000 items.
     */
    maxPageSize?: number;
}
/**
 * Option interface for File - Upload operations
 *
 * See:
 * - {@link ShareFileClient.uploadFile}
 * - {@link ShareFileClient.uploadSeekableStream}
 */
export declare interface FileParallelUploadOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * RangeSize specifies the range size to use in each parallel upload,
     * the default (and maximum size) is FILE_RANGE_MAX_SIZE_BYTES.
     */
    rangeSize?: number;
    /**
     * Progress updater.
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * File HTTP Headers.
     */
    fileHttpHeaders?: FileHttpHeaders;
    /**
     * Metadata of an Azure file.
     */
    metadata?: Metadata;
    /**
     * Concurrency indicates the maximum number of ranges to upload in parallel.
     * If not provided, 5 concurrency will be used by default.
     */
    concurrency?: number;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Indicates inherit file permission from the parent directory.
 */
export declare type FilePermissionInheritType = "inherit";
/**
 * Indicates keep existing file permission value unchanged.
 */
export declare type FilePermissionPreserveType = "preserve";
export declare interface FileProperties extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * File HTTP headers like Content-Type.
     */
    fileHttpHeaders?: FileHttpHeaders;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** File properties. */
export declare interface FileProperty {
    /** Content length of the file. This value may not be up-to-date since an SMB client may have modified the file locally. The value of Content-Length may not reflect that fact until the handle is closed or the op-lock is broken. To retrieve current property values, call Get File Properties. */
    contentLength: number;
    creationTime?: Date;
    lastAccessTime?: Date;
    lastWriteTime?: Date;
    changeTime?: Date;
    lastModified?: Date;
    etag?: string;
}
/**
 * Options to configure the {@link ShareFileClient.resize} operation.
 */
export declare interface FileResizeOptions extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Abstract for entries that can be listed from Directory. */
export declare interface FilesAndDirectoriesListSegment {
    directoryItems: DirectoryItem[];
    fileItems: FileItem[];
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a file. Setting
 * a value to true means that any SAS which uses these permissions will grant permissions for that operation. Once all
 * the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */
export declare class FileSASPermissions {
    /**
     * Creates a FileSASPermissions from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */
    static parse(permissions: string): FileSASPermissions;
    /**
     * Specifies Read access granted.
     */
    read: boolean;
    /**
     * Specifies Create access granted.
     */
    create: boolean;
    /**
     * Specifies Write access granted.
     */
    write: boolean;
    /**
     * Specifies Delete access granted.
     */
    delete: boolean;
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * @returns A string which represents the FileSASPermissions
     */
    toString(): string;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * FileSASSignatureValues is used to help generating File service SAS tokens for shares or files.
 */
export declare interface FileSASSignatureValues {
    /**
     * The version of the service this SAS will target. If not specified, it will default to the version targeted by the
     * library.
     */
    version?: string;
    /**
     * Optional. SAS protocols, HTTPS only or HTTPSandHTTP
     */
    protocol?: SASProtocol;
    /**
     * Optional. When the SAS will take effect.
     */
    startsOn?: Date;
    /**
     * Optional only when identifier is provided. The time after which the SAS will no longer work.
     */
    expiresOn?: Date;
    /**
     * Optional only when identifier is provided.
     * Please refer to either {@link ShareSASPermissions} or {@link FileSASPermissions} depending on the resource
     * being accessed for help constructing the permissions string.
     */
    permissions?: FileSASPermissions | ShareSASPermissions;
    /**
     * Optional. IP ranges allowed in this SAS.
     */
    ipRange?: SasIPRange;
    /**
     * The name of the share the SAS user may access.
     */
    shareName: string;
    /**
     * Optional. The path of the file like, "directory/FileName" or "FileName".
     */
    filePath?: string;
    /**
     * Optional. The name of the access policy on the share this SAS references if any.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy
     */
    identifier?: string;
    /**
     * Optional. The cache-control header for the SAS.
     */
    cacheControl?: string;
    /**
     * Optional. The content-disposition header for the SAS.
     */
    contentDisposition?: string;
    /**
     * Optional. The content-encoding header for the SAS.
     */
    contentEncoding?: string;
    /**
     * Optional. The content-language header for the SAS.
     */
    contentLanguage?: string;
    /**
     * Optional. The content-type header for the SAS.
     */
    contentType?: string;
}
/** Storage service properties. */
export declare interface FileServiceProperties {
    /** A summary of request statistics grouped by API in hourly aggregates for files. */
    hourMetrics?: Metrics;
    /** A summary of request statistics grouped by API in minute aggregates for files. */
    minuteMetrics?: Metrics;
    /** The set of CORS rules. */
    cors?: CorsRule[];
    /** Protocol settings */
    protocol?: ShareProtocolSettings;
}
/** Defines headers for File_setHttpHeaders operation. */
export declare interface FileSetHTTPHeadersHeaders {
    /** The ETag contains a value which represents the version of the file, in quotes. */
    etag?: string;
    /** Returns the date and time the directory was last modified. Any operation that modifies the directory or its properties updates the last modified time. Operations on files do not affect the last modified time of the directory. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise. */
    isServerEncrypted?: boolean;
    /** Key of the permission set for the file. */
    filePermissionKey?: string;
    /** Attributes set for the file. */
    fileAttributes?: string;
    /** Creation time for the file. */
    fileCreatedOn?: Date;
    /** Last write time for the file. */
    fileLastWriteOn?: Date;
    /** Change time for the file. */
    fileChangeOn?: Date;
    /** The fileId of the directory. */
    fileId?: string;
    /** The parent fileId of the directory. */
    fileParentId?: string;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.setHttpHeaders} operation.
 */
export declare interface FileSetHttpHeadersOptions extends FileAndDirectorySetPropertiesCommonOptions, CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the setHttpHeaders operation. */
export declare type FileSetHTTPHeadersResponse = FileSetHTTPHeadersHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileSetHTTPHeadersHeaders;
    };
};
/** Defines headers for File_setMetadata operation. */
export declare interface FileSetMetadataHeaders {
    /** The ETag contains a value which represents the version of the file, in quotes. */
    etag?: string;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise. */
    isServerEncrypted?: boolean;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.setMetadata} operation.
 */
export declare interface FileSetMetadataOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the setMetadata operation. */
export declare type FileSetMetadataResponse = FileSetMetadataHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileSetMetadataHeaders;
    };
};
/** Defines headers for File_startCopy operation. */
export declare interface FileStartCopyHeaders {
    /** If the copy is completed, contains the ETag of the destination file. If the copy is not complete, contains the ETag of the empty file created at the start of the copy. */
    etag?: string;
    /** Returns the date/time that the copy operation to the destination file completed. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** String identifier for this copy operation. Use with Get File or Get File Properties to check the status of this copy operation, or pass to Abort Copy File to abort a pending copy. */
    copyId?: string;
    /** State of the copy operation identified by x-ms-copy-id. */
    copyStatus?: CopyStatusType;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.startCopyFromURL} operation.
 */
export declare interface FileStartCopyOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * A collection of key-value string pair to associate with the file storage object.
     */
    metadata?: Metadata;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
    /**
     * If specified the permission (security descriptor) shall be set for the directory/file. This
     * header can be used if Permission size is lesser than or equal to 8KB, else x-ms-file-permission-key header shall be
     * used. Default value: Inherit. If SDDL is specified as input, it must have owner, group and
     * dacl. Note: Only one of the x-ms-file-permission or x-ms-file-permission-key should be
     * specified.
     */
    filePermission?: string;
    /**
     * Key of the permission to be set for the directory/file. Note: Only one of the
     * x-ms-file-permission or x-ms-file-permission-key should be specified.
     */
    filePermissionKey?: string;
    /**
     * SMB info.
     */
    copyFileSmbInfo?: CopyFileSmbInfo;
}
/** Contains response data for the startCopy operation. */
export declare type FileStartCopyResponse = FileStartCopyHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileStartCopyHeaders;
    };
};
/**
 * This is a helper class to construct a string representing the NTFS attributes to a file or directory.
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file#file-system-attributes
 */
export declare class FileSystemAttributes {
    /**
     * Creates a FileSystemAttributes from the specified attributes string. This method will throw an
     * Error if it encounters a string that does not correspond to a valid attributes.
     *
     * @param fileAttributes - The value of header x-ms-file-attributes.
     */
    static parse(fileAttributes: string): FileSystemAttributes;
    /**
     * Specifies a directory or file that is read-only.
     */
    readonly: boolean;
    /**
     * Specifies a directory or file is hidden.
     */
    hidden: boolean;
    /**
     * Specifies a directory or file that the operating system uses a part of, or uses exclusively.
     */
    system: boolean;
    /**
     * Specifies a directory or file that does not have other attributes set. This attribute is valid only when used alone.
     */
    none: boolean;
    /**
     * Specifies the handle identifies a directory.
     */
    directory: boolean;
    /**
     * Specifies a directory or file is an archive. Applications typically use this attribute to mark files for backup or removal.
     */
    archive: boolean;
    /**
     * Specifies if a file is temporary.
     */
    temporary: boolean;
    /**
     * Specifies the data of a directory or file is not available immediately.
     * This file system attribute is presented primarily to provide compatibility with Windows - Azure Files does not support with offline storage options.
     */
    offline: boolean;
    /**
     * Specifies the directory or file is not to be indexed by the content indexing service.
     */
    notContentIndexed: boolean;
    /**
     * Specifies the user data stream not to be read by the background data integrity scanner.
     * This file system attribute is presented primarily to provide compatibility with Windows.
     * Applicable to directory or file.
     */
    noScrubData: boolean;
    /**
     * Converts the given attributes to a string.
     *
     * @returns A string which represents the FileSystemAttributes
     */
    toString(): string;
}
/**
 * Defines values for FileType.
 * Possible values include: 'File'
 * @readonly
 * @enum {string}
 */
export declare type FileType = "File";
/** Defines headers for File_uploadRangeFromURL operation. */
export declare interface FileUploadRangeFromURLHeaders {
    /** The ETag contains a value which represents the version of the file, in quotes. */
    etag?: string;
    /** Returns the date and time the directory was last modified. Any operation that modifies the share or its properties or metadata updates the last modified time. Operations on files do not affect the last modified time of the share. */
    lastModified?: Date;
    /** This header is returned so that the client can check for message content integrity. The value of this header is computed by the File service; it is not necessarily the same value as may have been specified in the request headers. */
    xMsContentCrc64?: Uint8Array;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise. */
    isServerEncrypted?: boolean;
    /** Error Code */
    errorCode?: string;
}
/** Optional parameters. */
export declare interface FileUploadRangeFromURLOptionalParams extends coreHttp.OperationOptions {
    /** Parameter group */
    leaseAccessConditions?: LeaseAccessConditions;
    /** Parameter group */
    sourceModifiedAccessConditions?: SourceModifiedAccessConditions;
    /** The timeout parameter is expressed in seconds. For more information, see <a href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting Timeouts for File Service Operations.</a> */
    timeoutInSeconds?: number;
    /** Bytes of source data in the specified range. */
    sourceRange?: string;
    /** Specify the crc64 calculated for the range of bytes that must be read from the copy source. */
    sourceContentCrc64?: Uint8Array;
    /** Only Bearer type is supported. Credentials should be a valid OAuth access token to copy source. */
    copySourceAuthorization?: string;
}
/**
 * Options to configure the {@link ShareFileClient.uploadRangeFromURL} operation.
 */
export declare interface FileUploadRangeFromURLOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * The timeout parameter is expressed in seconds. For more information, see <a
     * href="https://docs.microsoft.com/en-us/rest/api/storageservices/Setting-Timeouts-for-File-Service-Operations?redirectedfrom=MSDN">Setting
     * Timeouts for File Service Operations.</a>
     */
    timeoutInSeconds?: number;
    /**
     * Specify the crc64 calculated for the range of bytes that must be read from the copy source.
     */
    sourceContentCrc64?: Uint8Array;
    /**
     * Additional parameters for the operation
     */
    sourceConditions?: SourceModifiedAccessConditions;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
    /**
     * Only Bearer type is supported. Credentials should be a valid OAuth access token to copy source.
     */
    sourceAuthorization?: HttpAuthorization;
}
/** Contains response data for the uploadRangeFromURL operation. */
export declare type FileUploadRangeFromURLResponse = FileUploadRangeFromURLHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileUploadRangeFromURLHeaders;
    };
};
/** Defines headers for File_uploadRange operation. */
export declare interface FileUploadRangeHeaders {
    /** The ETag contains a value which represents the version of the file, in quotes. */
    etag?: string;
    /** Returns the date and time the directory was last modified. Any operation that modifies the share or its properties or metadata updates the last modified time. Operations on files do not affect the last modified time of the share. */
    lastModified?: Date;
    /** This header is returned so that the client can check for message content integrity. The value of this header is computed by the File service; it is not necessarily the same value as may have been specified in the request headers. */
    contentMD5?: Uint8Array;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** The value of this header is set to true if the contents of the request are successfully encrypted using the specified algorithm, and false otherwise. */
    isServerEncrypted?: boolean;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareFileClient.uploadRange} operation.
 */
export declare interface FileUploadRangeOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * An MD5 hash of the content. This hash is
     * used to verify the integrity of the data during transport. When the
     * Content-MD5 header is specified, the File service compares the hash of the
     * content that has arrived with the header value that was sent. If the two
     * hashes do not match, the operation will fail with error code 400 (Bad
     * Request).
     */
    contentMD5?: Uint8Array;
    /**
     * Progress updating event handler.
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the uploadRange operation. */
export declare type FileUploadRangeResponse = FileUploadRangeHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: FileUploadRangeHeaders;
    };
};
/**
 * Option interface for ShareFileClient.uploadStream().
 */
export declare interface FileUploadStreamOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Azure File HTTP Headers.
     */
    fileHttpHeaders?: FileHttpHeaders;
    /**
     * Metadata of the Azure file.
     */
    metadata?: Metadata;
    /**
     * Progress updater.
     */
    onProgress?: (progress: TransferProgressEvent) => void;
    /**
     * Lease access conditions.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Generates a {@link SASQueryParameters} object which contains all SAS query parameters needed to make an actual
 * REST request.
 *
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-an-account-sas
 *
 * @param sharedKeyCredential -
 */
export declare function generateAccountSASQueryParameters(accountSASSignatureValues: AccountSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * Creates an instance of SASQueryParameters.
 *
 * Only accepts required settings needed to create a SAS. For optional settings please
 * set corresponding properties directly, such as permissions, startsOn and identifier.
 *
 * WARNING: When identifier is not provided, permissions and expiresOn are required.
 * You MUST assign value to identifier or expiresOn & permissions manually if you initial with
 * this constructor.
 *
 * @param fileSASSignatureValues -
 * @param sharedKeyCredential -
 */
export declare function generateFileSASQueryParameters(fileSASSignatureValues: FileSASSignatureValues, sharedKeyCredential: StorageSharedKeyCredential): SASQueryParameters;
/** A listed Azure Storage handle item. */
export declare interface HandleItem {
    /** XSMB service handle ID */
    handleId: string;
    /** File or directory name including full path starting from share root */
    path: string;
    /** FileId uniquely identifies the file or directory. */
    fileId: string;
    /** ParentId uniquely identifies the parent directory of the object. */
    parentId?: string;
    /** SMB session ID in context of which the file handle was opened */
    sessionId: string;
    /** Client IP that opened the handle */
    clientIp: string;
    /** Time when the session that previously opened the handle has last been reconnected. (UTC) */
    openTime: Date;
    /** Time handle was last connected to (UTC) */
    lastReconnectTime?: Date;
}
/**
 * Represents authentication information in Authorization, ProxyAuthorization,
 * WWW-Authenticate, and Proxy-Authenticate header values.
 */
export declare interface HttpAuthorization {
    /**
     * The scheme to use for authorization.
     */
    scheme: string;
    /**
     * the credentials containing the authentication information of the user agent for the resource being requested.
     */
    value: string;
}
export { HttpHeaders };
export { HttpOperationResponse };
export { HttpRequestBody };
export { IHttpClient };
/** Parameter group */
export declare interface LeaseAccessConditions {
    /** If specified, the operation only succeeds if the resource's lease is active and matches this ID. */
    leaseId?: string;
}
/** Defines values for LeaseDurationType. */
export declare type LeaseDurationType = "infinite" | "fixed";
/**
 * lease operations options.
 */
export declare interface LeaseOperationOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/**
 * Contains the response data for operations that acquire, change, break or release a lease.
 *
 * See {@link ShareLeaseClient}.
 */
export declare type LeaseOperationResponse = LeaseOperationResponseHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: LeaseOperationResponseHeaders;
    };
};
/**
 * The details of the response for a specific lease operation.
 */
export declare interface LeaseOperationResponseHeaders {
    /**
     * The ETag contains a value that you can use to perform operations conditionally. If the request
     * version is 2011-08-18 or newer, the ETag value will be in quotes.
     */
    etag?: string;
    /**
     * Returns the date and time the file was last modified. Any operation that modifies the file,
     * including an update of the file's metadata or properties, changes the last-modified time of
     * the file.
     */
    lastModified?: Date;
    /**
     * Approximate time remaining in the lease period, in seconds. Only availabe for {@link ShareLeaseClient.breakLease} for share lease.
     */
    leaseTimeInSeconds?: number;
    /**
     * Uniquely identifies a file's lease, won't be set when returned by releaseLease.
     */
    leaseId?: string;
    /**
     * This header uniquely identifies the request that was made and can be used for troubleshooting
     * the request.
     */
    requestId?: string;
    /**
     * Indicates the version of the Blob service used to execute the request. This header is returned
     * for requests made against version 2009-09-19 and above.
     */
    version?: string;
    /**
     * UTC date/time value generated by the service that indicates the time at which the response was
     * initiated
     */
    date?: Date;
    errorCode?: string;
}
/** Defines values for LeaseStateType. */
export declare type LeaseStateType = "available" | "leased" | "expired" | "breaking" | "broken";
/** Defines values for LeaseStatusType. */
export declare type LeaseStatusType = "locked" | "unlocked";
/** An enumeration of directories and files. */
export declare interface ListFilesAndDirectoriesSegmentResponse {
    serviceEndpoint: string;
    shareName: string;
    shareSnapshot?: string;
    directoryPath: string;
    prefix: string;
    marker?: string;
    maxResults?: number;
    /** Abstract for entries that can be listed from Directory. */
    segment: FilesAndDirectoriesListSegment;
    continuationToken: string;
    directoryId?: string;
}
/** An enumeration of handles. */
export declare interface ListHandlesResponse {
    handleList?: HandleItem[];
    continuationToken: string;
}
/** Defines values for ListSharesIncludeType. */
export declare type ListSharesIncludeType = "snapshots" | "metadata" | "deleted";
/**
 * An enumeration of shares.
 */
export declare interface ListSharesResponse {
    serviceEndpoint: string;
    prefix?: string;
    marker?: string;
    maxResults?: number;
    shareItems?: ShareItem[];
    continuationToken: string;
}
/** An enumeration of shares. */
export declare interface ListSharesResponseModel {
    serviceEndpoint: string;
    prefix?: string;
    marker?: string;
    maxResults?: number;
    shareItems?: ShareItemInternal[];
    continuationToken: string;
}
/**
 * The `@azure/logger` configuration for this package.
 */
export declare const logger: import("@azure/logger").AzureLogger;
export declare interface Metadata {
    [propertyName: string]: string;
}
/** Storage Analytics metrics for file service. */
export declare interface Metrics {
    /** The version of Storage Analytics to configure. */
    version: string;
    /** Indicates whether metrics are enabled for the File service. */
    enabled: boolean;
    /** Indicates whether metrics should generate summary statistics for called API operations. */
    includeAPIs?: boolean;
    /** The retention policy. */
    retentionPolicy?: RetentionPolicy;
}
/**
 * Creates a new {@link Pipeline} object with {@link Credential} provided.
 *
 * @param credential - Such as AnonymousCredential, StorageSharedKeyCredential.
 * @param pipelineOptions - Optional. Options.
 * @returns A new Pipeline object.
 */
export declare function newPipeline(credential?: Credential, pipelineOptions?: StoragePipelineOptions): Pipeline;
/** Defines values for PermissionCopyModeType. */
export declare type PermissionCopyModeType = "source" | "override";
/**
 * A Pipeline class containing HTTP request policies.
 * You can create a default Pipeline by calling {@link newPipeline}.
 * Or you can create a Pipeline with your own policies by the constructor of Pipeline.
 *
 * Refer to {@link newPipeline} and provided policies as reference before
 * implementing your customized Pipeline.
 */
export declare class Pipeline {
    /**
     * A list of chained request policy factories.
     */
    readonly factories: RequestPolicyFactory[];
    /**
     * Configures pipeline logger and HTTP client.
     */
    readonly options: PipelineOptions;
    /**
     * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.
     *
     * @param factories -
     * @param options -
     */
    constructor(factories: RequestPolicyFactory[], options?: PipelineOptions);
    /**
     * Transfer Pipeline object to ServiceClientOptions object which required by
     * ServiceClient constructor.
     *
     * @returns The ServiceClientOptions object from this Pipeline.
     */
    toServiceClientOptions(): ServiceClientOptions;
}
/**
 * Option interface for Pipeline constructor.
 */
export declare interface PipelineOptions {
    /**
     * Optional. Configures the HTTP client to send requests and receive responses.
     */
    httpClient?: IHttpClient;
}
/**
 * Range for Service Operations.
 * @see https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-the-range-header-for-file-service-operations
 */
export declare interface Range {
    /**
     * StartByte, larger than or equal 0.
     */
    offset: number;
    /**
     * Optional. Count of bytes, larger than 0.
     * If not provided, will return bytes from offset to the end.
     */
    count?: number;
}
/** An Azure Storage file range. */
export declare interface RangeModel {
    /** Start of the range. */
    start: number;
    /** End of the range. */
    end: number;
}
export { RequestPolicy };
export { RequestPolicyFactory };
export { RequestPolicyOptions };
export { RestError };
/** The retention policy. */
export declare interface RetentionPolicy {
    /** Indicates whether a retention policy is enabled for the File service. If false, metrics data is retained, and the user is responsible for deleting it. */
    enabled: boolean;
    /** Indicates the number of days that metrics data should be retained. All data older than this value will be deleted. Metrics data is deleted on a best-effort basis after the retention period expires. */
    days?: number;
}
/**
 * Allowed IP range for a SAS.
 */
export declare interface SasIPRange {
    /**
     * Starting IP address in the IP range.
     * If end IP doesn't provide, start IP will the only IP allowed.
     */
    start: string;
    /**
     * Optional. IP address that ends the IP range.
     * If not provided, start IP will the only IP allowed.
     */
    end?: string;
}
/**
 * Protocols for generated SAS.
 */
export declare enum SASProtocol {
    /**
     * Protocol that allows HTTPS only
     */
    Https = "https",
    /**
     * Protocol that allows both HTTPS and HTTP
     */
    HttpsAndHttp = "https,http"
}
/**
 * Represents the components that make up an Azure Storage SAS' query parameters. This type is not constructed directly
 * by the user; it is only generated by the {@link AccountSASSignatureValues} and {@link FileSASSignatureValues}
 * types. Once generated, it can be encoded into a {@link String} and appended to a URL directly (though caution should
 * be taken here in case there are existing query parameters, which might affect the appropriate means of appending
 * these query parameters).
 *
 * NOTE: Instances of this class are immutable.
 */
export declare class SASQueryParameters {
    /**
     * The storage API version.
     */
    readonly version: string;
    /**
     * Optional. The allowed HTTP protocol(s).
     */
    readonly protocol?: SASProtocol;
    /**
     * Optional. The start time for this SAS token.
     */
    readonly startsOn?: Date;
    /**
     * Optional only when identifier is provided. The expiry time for this SAS token.
     */
    readonly expiresOn?: Date;
    /**
     * Optional only when identifier is provided.
     * Please refer to {@link AccountSASPermissions}, {@link FileSASPermissions}, or {@link ShareSASPermissions} for
     * more details.
     */
    readonly permissions?: string;
    /**
     * Optional. The storage services being accessed (only for Account SAS). Please refer to {@link AccountSASServices}
     * for more details.
     */
    readonly services?: string;
    /**
     * Optional. The storage resource types being accessed (only for Account SAS). Please refer to
     * {@link AccountSASResourceTypes} for more details.
     */
    readonly resourceTypes?: string;
    /**
     * Optional. The signed identifier (only for {@link FileSASSignatureValues}).
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy
     */
    readonly identifier?: string;
    /**
     * Optional. The storage share or file path (only for {@link FileSASSignatureValues}).
     */
    readonly resource?: string;
    /**
     * The signature for the SAS token.
     */
    readonly signature: string;
    /**
     * Value for cache-control header in Blob/File Service SAS.
     */
    readonly cacheControl?: string;
    /**
     * Value for content-disposition header in Blob/File Service SAS.
     */
    readonly contentDisposition?: string;
    /**
     * Value for content-encoding header in Blob/File Service SAS.
     */
    readonly contentEncoding?: string;
    /**
     * Value for content-length header in Blob/File Service SAS.
     */
    readonly contentLanguage?: string;
    /**
     * Value for content-type header in Blob/File Service SAS.
     */
    readonly contentType?: string;
    /**
     * Inner value of getter ipRange.
     */
    private readonly ipRangeInner?;
    readonly ipRange: SasIPRange | undefined;
    /**
     * Creates an instance of SASQueryParameters.
     *
     * @param version - Representing the storage version
     * @param signature - Representing the signature for the SAS token
     * @param permissions - Representing the storage permissions
     * @param services - Representing the storage services being accessed (only for Account SAS)
     * @param resourceTypes - Representing the storage resource types being accessed (only for Account SAS)
     * @param protocol - Representing the allowed HTTP protocol(s)
     * @param startsOn - Representing the start time for this SAS token
     * @param expiresOn - Representing the expiry time for this SAS token
     * @param ipRange - Representing the range of valid IP addresses for this SAS token
     * @param identifier - Representing the signed identifier (only for Service SAS)
     * @param resource - Representing the storage container or blob (only for Service SAS)
     * @param cacheControl - Representing the cache-control header (only for Blob/File Service SAS)
     * @param contentDisposition - Representing the content-disposition header (only for Blob/File Service SAS)
     * @param contentEncoding - Representing the content-encoding header (only for Blob/File Service SAS)
     * @param contentLanguage - Representing the content-language header (only for Blob/File Service SAS)
     * @param contentType - Representing the content-type header (only for Blob/File Service SAS)
     */
    constructor(version: string, signature: string, permissions?: string, services?: string, resourceTypes?: string, protocol?: SASProtocol, startsOn?: Date, expiresOn?: Date, ipRange?: SasIPRange, identifier?: string, resource?: string, cacheControl?: string, contentDisposition?: string, contentEncoding?: string, contentLanguage?: string, contentType?: string);
    /**
     * Encodes all SAS query parameters into a string that can be appended to a URL.
     *
     */
    toString(): string;
    /**
     * A private helper method used to filter and append query key/value pairs into an array.
     *
     * @param queries -
     * @param key -
     * @param value -
     */
    private tryAppendQueryParameter;
}
/**
 * Options to configure {@link ShareServiceClient.generateAccountSasUrl} operation.
 */
export declare interface ServiceGenerateAccountSasUrlOptions {
    /**
     * The version of the service this SAS will target. If not specified, it will default to the version targeted by the
     * library.
     */
    version?: string;
    /**
     * Optional. SAS protocols allowed.
     */
    protocol?: SASProtocol;
    /**
     * Optional. When the SAS will take effect.
     */
    startsOn?: Date;
    /**
     * Optional. IP range allowed.
     */
    ipRange?: SasIPRange;
}
/** Defines headers for Service_getProperties operation. */
export declare interface ServiceGetPropertiesHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareServiceClient.getProperties} operation.
 */
export declare interface ServiceGetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Contains response data for the getProperties operation. */
export declare type ServiceGetPropertiesResponse = ServiceGetPropertiesHeaders & FileServiceProperties & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: FileServiceProperties;
        /** The parsed HTTP response headers. */
        parsedHeaders: ServiceGetPropertiesHeaders;
    };
};
/**
 * Options to configure the {@link ShareServiceClient.listShares} operation.
 */
export declare interface ServiceListSharesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Filters the results to return only entries whose
     * name begins with the specified prefix.
     */
    prefix?: string;
    /**
     * Specifies that share snapshots should be included in the enumeration. Share Snapshots are listed from oldest to newest in the response.
     */
    includeMetadata?: boolean;
    /**
     * Specifies that share snapshot should be returned in the response.
     */
    includeSnapshots?: boolean;
    /**
     * Specifies that share soft deleted should be returned in the response.
     */
    includeDeleted?: boolean;
}
/** Defines headers for Service_listSharesSegment operation. */
export declare interface ServiceListSharesSegmentHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** Error Code */
    errorCode?: string;
}
/**
 * Contains response data for the {@link ShareServiceClient.listShares} operation.
 */
export declare type ServiceListSharesSegmentResponse = ListSharesResponse & ServiceListSharesSegmentHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ServiceListSharesSegmentHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: ListSharesResponseModel;
    };
};
/** Defines headers for Service_setProperties operation. */
export declare interface ServiceSetPropertiesHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareServiceClient.setProperties} operation.
 */
export declare interface ServiceSetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Contains response data for the setProperties operation. */
export declare type ServiceSetPropertiesResponse = ServiceSetPropertiesHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: ServiceSetPropertiesHeaders;
    };
};
/**
 * Options to configure the {@link ShareServiceClient.undelete} operation.
 */
export declare interface ServiceUndeleteShareOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
export declare interface SetPropertiesResponse extends FileSetHTTPHeadersResponse {
}
/** Defines values for ShareAccessTier. */
export declare type ShareAccessTier = "TransactionOptimized" | "Hot" | "Cool";
/**
 * A ShareClient represents a URL to the Azure Storage share allowing you to manipulate its directories and files.
 */
export declare class ShareClient extends StorageClient {
    /**
     * Share operation context provided by protocol layer.
     */
    private context;
    private _name;
    readonly name: string;
    /**
     * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param name - Share name.
     * @param options - Optional. Options to configure the HTTP pipeline.
     */
    constructor(connectionString: string, name: string, options?: StoragePipelineOptions);
    /**
     * Creates an instance of ShareClient.
     *
     * @param url - A URL string pointing to Azure Storage file share, such as
     *                     "https://myaccount.file.core.windows.net/share". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/share?sasString".
     * @param credential - Such as AnonymousCredential or StorageSharedKeyCredential.
     *                                  If not specified, AnonymousCredential is used.
     * @param options - Optional. Options to configure the HTTP pipeline.
     */
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    /**
     * Creates an instance of ShareClient.
     *
     * @param url - A URL string pointing to Azure Storage file share, such as
     *                     "https://myaccount.file.core.windows.net/share". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/share?sasString".
     * @param pipeline - Call newPipeline() to create a default
     *                            pipeline, or provide a customized pipeline.
     */
    constructor(url: string, pipeline: Pipeline);
    /**
     * Creates a new ShareClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base share.
     *
     * @param snapshot - The snapshot timestamp.
     * @returns A new ShareClient object identical to the source but with the specified snapshot timestamp
     */
    withSnapshot(snapshot: string): ShareClient;
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, the operation fails.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options - Options to Share Create operation.
     * @returns Response data for the Share Create operation.
     */
    create(options?: ShareCreateOptions): Promise<ShareCreateResponse>;
    /**
     * Creates a new share under the specified account. If the share with
     * the same name already exists, it is not changed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-share
     *
     * @param options -
     */
    createIfNotExists(options?: ShareCreateOptions): Promise<ShareCreateIfNotExistsResponse>;
    /**
     * Creates a {@link ShareDirectoryClient} object.
     *
     * @param directoryName - A directory name
     * @returns The ShareDirectoryClient object for the given directory name.
     */
    getDirectoryClient(directoryName: string): ShareDirectoryClient;
    readonly rootDirectoryClient: ShareDirectoryClient;
    /**
     * Creates a new subdirectory under this share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory creation response data and the corresponding directory client.
     */
    createDirectory(directoryName: string, options?: DirectoryCreateOptions): Promise<{
        directoryClient: ShareDirectoryClient;
        directoryCreateResponse: DirectoryCreateResponse;
    }>;
    /**
     * Removes the specified empty sub directory under this share.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    deleteDirectory(directoryName: string, options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    /**
     * Creates a new file or replaces a file under the root directory of this share.
     * Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    createFile(fileName: string, size: number, options?: FileCreateOptions): Promise<{
        fileClient: ShareFileClient;
        fileCreateResponse: FileCreateResponse;
    }>;
    /**
     * Removes a file under the root directory of this share from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code `SharingViolation`
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400
     * (`InvalidQueryParameterValue`)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param directoryName -
     * @param fileName -
     * @param options - Options to File Delete operation.
     * @returns Promise<FileDeleteResponse> File Delete response data.
     */
    deleteFile(fileName: string, options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    /**
     * Returns true if the Azrue share resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing share might be deleted by other clients or
     * applications. Vice versa new shares might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    exists(options?: ShareExistsOptions): Promise<boolean>;
    /**
     * Returns all user-defined metadata and system properties for the specified
     * share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-properties
     *
     * WARNING: The `metadata` object returned in the response will have its keys in lowercase, even if
     * they originally contained uppercase characters. This differs from the metadata keys returned by
     * the `listShares` method of {@link ShareServiceClient} using the `includeMetadata` option, which
     * will retain their original casing.
     *
     * @returns Response data for the Share Get Properties operation.
     */
    getProperties(options?: ShareGetPropertiesOptions): Promise<ShareGetPropertiesResponse>;
    /**
     * Marks the specified share for deletion. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options - Options to Share Delete operation.
     * @returns Response data for the Share Delete operation.
     */
    delete(options?: ShareDeleteMethodOptions): Promise<ShareDeleteResponse>;
    /**
     * Marks the specified share for deletion if it exists. The share and any directories or files
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-share
     *
     * @param options -
     */
    deleteIfExists(options?: ShareDeleteMethodOptions): Promise<ShareDeleteIfExistsResponse>;
    /**
     * Sets one or more user-defined name-value pairs for the specified share.
     *
     * If no option provided, or no metadata defined in the option parameter, the share
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed.
     * @param option - Options to Share Set Metadata operation.
     * @returns Response data for the Share Set Metadata operation.
     */
    setMetadata(metadata?: Metadata, options?: ShareSetMetadataOptions): Promise<ShareSetMetadataResponse>;
    /**
     * Gets the permissions for the specified share. The permissions indicate
     * whether share data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potential lost precision when parsing start and expiry string.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-share-acl
     *
     * @param option - Options to Share Get Access Policy operation.
     * @returns Response data for the Share Get Access Policy operation.
     */
    getAccessPolicy(options?: ShareGetAccessPolicyOptions): Promise<ShareGetAccessPolicyResponse>;
    /**
     * Sets the permissions for the specified share. The permissions indicate
     * whether directories or files in a share may be accessed publicly.
     *
     * When you set permissions for a share, the existing permissions are replaced.
     * If no shareAcl provided, the existing share ACL will be
     * removed.
     *
     * When you establish a stored access policy on a share, it may take up to 30 seconds to take effect.
     * During this interval, a shared access signature that is associated with the stored access policy will
     * fail with status code 403 (Forbidden), until the access policy becomes active.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
     *
     * @param shareAcl - Array of signed identifiers, each having a unique Id and details of access policy.
     * @param option - Options to Share Set Access Policy operation.
     * @returns Response data for the Share Set Access Policy operation.
     */
    setAccessPolicy(shareAcl?: SignedIdentifier[], options?: ShareSetAccessPolicyOptions): Promise<ShareSetAccessPolicyResponse>;
    /**
     * Creates a read-only snapshot of a share.
     *
     * @param options - Options to Share Create Snapshot operation.
     * @returns Response data for the Share Create Snapshot operation.
     */
    createSnapshot(options?: ShareCreateSnapshotOptions): Promise<ShareCreateSnapshotResponse>;
    /**
     * Sets quota for the specified share.
     *
     * @deprecated Use {@link ShareClient.setProperties} instead.
     *
     * @param quotaInGB - Specifies the maximum size of the share in gigabytes
     * @param option - Options to Share Set Quota operation.
     * @returns Response data for the Share Get Quota operation.
     */
    setQuota(quotaInGB: number, options?: ShareSetQuotaOptions): Promise<ShareSetQuotaResponse>;
    /**
     * Sets properties of the share.
     *
     * @param option - Options to Share Set Properties operation.
     * @returns Response data for the Share Set Properties operation.
     */
    setProperties(options?: ShareSetPropertiesOptions): Promise<ShareSetPropertiesResponse>;
    /**
     * Retrieves statistics related to the share.
     *
     * @param option - Options to Share Get Statistics operation.
     * @returns Response data for the Share Get Statistics operation.
     */
    getStatistics(options?: ShareGetStatisticsOptions): Promise<ShareGetStatisticsResponse>;
    /**
     * Creates a file permission (a security descriptor) at the share level.
     * The created security descriptor can be used for the files/directories in the share.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermission - File permission described in the SDDL
     */
    createPermission(filePermission: string, options?: ShareCreatePermissionOptions): Promise<ShareCreatePermissionResponse>;
    /**
     * Gets the Security Descriptor Definition Language (SDDL) for a given file permission key
     * which indicates a security descriptor.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-permission
     *
     * @param options - Options to Share Create Permission operation.
     * @param filePermissionKey - File permission key which indicates the security descriptor of the permission.
     */
    getPermission(filePermissionKey: string, options?: ShareGetPermissionOptions): Promise<ShareGetPermissionResponse>;
    /**
     * Only available for ShareClient constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateSasUrl(options: ShareGenerateSasUrlOptions): string;
}
/** Defines headers for Share_create operation. */
export declare interface ShareCreateHeaders {
    /** The ETag contains a value which represents the version of the share, in quotes. */
    etag?: string;
    /** Returns the date and time the share was last modified. Any operation that modifies the share or its properties or metadata updates the last modified time. Operations on files do not affect the last modified time of the share. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Contains response data for the {@link ShareClient.createIfNotExists} operation.
 */
export declare interface ShareCreateIfNotExistsResponse extends ShareCreateResponse {
    /**
     * Indicate whether the share is successfully created. Is false when the share is not changed as it already exists.
     */
    succeeded: boolean;
}
/**
 * Options to configure the {@link ShareClient.create} operation.
 */
export declare interface ShareCreateOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * A name-value pair to associate with a file storage object.
     */
    metadata?: {
        [propertyName: string]: string;
    };
    /**
     * Specifies the maximum size of the share, in
     * gigabytes.
     */
    quota?: number;
    /**
     * Specifies the access tier of the share. Possible values include: 'TransactionOptimized',
     * 'Hot', 'Cool'
     */
    accessTier?: ShareAccessTier;
    /**
     * Supported in version 2020-02-10 and above. Specifies the enabled protocols on the share. If not specified, the default is SMB.
     */
    protocols?: ShareProtocols;
    /**
     * Root squash to set on the share.  Only valid for NFS shares. Possible values include:
     * 'NoRootSquash', 'RootSquash', 'AllSquash'.
     */
    rootSquash?: ShareRootSquash;
}
/** Defines headers for Share_createPermission operation. */
export declare interface ShareCreatePermissionHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Key of the permission set for the directory/file. */
    filePermissionKey?: string;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.createPermission} operation.
 */
export declare interface ShareCreatePermissionOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Contains response data for the createPermission operation. */
export declare type ShareCreatePermissionResponse = ShareCreatePermissionHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareCreatePermissionHeaders;
    };
};
/** Contains response data for the create operation. */
export declare type ShareCreateResponse = ShareCreateHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareCreateHeaders;
    };
};
/** Defines headers for Share_createSnapshot operation. */
export declare interface ShareCreateSnapshotHeaders {
    /** This header is a DateTime value that uniquely identifies the share snapshot. The value of this header may be used in subsequent requests to access the share snapshot. This value is opaque. */
    snapshot?: string;
    /** The ETag contains a value which represents the version of the share snapshot, in quotes. A share snapshot cannot be modified, so the ETag of a given share snapshot never changes. However, if new metadata was supplied with the Snapshot Share request then the ETag of the share snapshot differs from that of the base share. If no metadata was specified with the request, the ETag of the share snapshot is identical to that of the base share at the time the share snapshot was taken. */
    etag?: string;
    /** Returns the date and time the share was last modified. A share snapshot cannot be modified, so the last modified time of a given share snapshot never changes. However, if new metadata was supplied with the Snapshot Share request then the last modified time of the share snapshot differs from that of the base share. If no metadata was specified with the request, the last modified time of the share snapshot is identical to that of the base share at the time the share snapshot was taken. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.createSnapshot} operation.
 */
export declare interface ShareCreateSnapshotOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * A name-value pair to associate with a file storage object.
     */
    metadata?: {
        [propertyName: string]: string;
    };
}
/** Contains response data for the createSnapshot operation. */
export declare type ShareCreateSnapshotResponse = ShareCreateSnapshotHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareCreateSnapshotHeaders;
    };
};
/** Defines headers for Share_delete operation. */
export declare interface ShareDeleteHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Contains response data for the {@link ShareClient.deleteIfExists} operation.
 */
export declare interface ShareDeleteIfExistsResponse extends ShareDeleteResponse {
    /**
     * Indicate whether the share is successfully deleted. Is false if the share does not exist in the first place.
     */
    succeeded: boolean;
}
/**
 * Options to configure the {@link ShareClient.delete} operation.
 */
export declare interface ShareDeleteMethodOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies the option
     * include to delete the base share and all of its snapshots. Possible values
     * include: 'include'
     */
    deleteSnapshots?: DeleteSnapshotsOptionType;
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this ID.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the delete operation. */
export declare type ShareDeleteResponse = ShareDeleteHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareDeleteHeaders;
    };
};
/**
 * A ShareDirectoryClient represents a URL to the Azure Storage directory allowing you to manipulate its files and directories.
 */
export declare class ShareDirectoryClient extends StorageClient {
    /**
     * context provided by protocol layer.
     */
    private context;
    private _shareName;
    private _path;
    private _name;
    readonly shareName: string;
    readonly path: string;
    readonly name: string;
    /**
     * Creates an instance of DirectoryClient.
     *
     * @param url - A URL string pointing to Azure Storage file directory, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory?sasString".
     *                     This method accepts an encoded URL or non-encoded URL pointing to a directory.
     *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.
     *                     However, if a directory name includes %, directory name must be encoded in the URL.
     *                     Such as a directory named "mydir%", the URL should be "https://myaccount.file.core.windows.net/myshare/mydir%25".
     * @param credential - Such as AnonymousCredential or StorageSharedKeyCredential.
     *                                  If not specified, AnonymousCredential is used.
     * @param options - Optional. Options to configure the HTTP pipeline.
     */
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    /**
     * Creates an instance of DirectoryClient.
     *
     * @param url - A URL string pointing to Azure Storage file directory, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory?sasString".
     *                     This method accepts an encoded URL or non-encoded URL pointing to a directory.
     *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.
     *                     However, if a directory name includes %, directory name must be encoded in the URL.
     *                     Such as a directory named "mydir%", the URL should be "https://myaccount.file.core.windows.net/myshare/mydir%25".
     * @param pipeline - Call newPipeline() to create a default
     *                            pipeline, or provide a customized pipeline.
     */
    constructor(url: string, pipeline: Pipeline);
    /**
     * Creates a new directory under the specified share or parent directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options - Options to Directory Create operation.
     * @returns Response data for the Directory  operation.
     */
    create(options?: DirectoryCreateOptions): Promise<DirectoryCreateResponse>;
    /**
     * Creates a new directory under the specified share or parent directory if it does not already exists.
     * If the directory already exists, it is not modified.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param options -
     */
    createIfNotExists(options?: DirectoryCreateOptions): Promise<DirectoryCreateIfNotExistsResponse>;
    /**
     * Sets properties on the directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-properties
     *
     * @param DirectoryProperties - Directory properties. If no values are provided,
     *                                            existing values will be preserved.
     */
    setProperties(properties?: DirectoryProperties): Promise<DirectorySetPropertiesResponse>;
    /**
     * Creates a ShareDirectoryClient object for a sub directory.
     *
     * @param subDirectoryName - A subdirectory name
     * @returns The ShareDirectoryClient object for the given subdirectory name.
     *
     * Example usage:
     *
     * ```js
     * const directoryClient = shareClient.getDirectoryClient("<directory name>");
     * await directoryClient.create();
     * console.log("Created directory successfully");
     * ```
     */
    getDirectoryClient(subDirectoryName: string): ShareDirectoryClient;
    /**
     * Creates a new subdirectory under this directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Create operation.
     * @returns Directory create response data and the corresponding DirectoryClient instance.
     */
    createSubdirectory(directoryName: string, options?: DirectoryCreateOptions): Promise<{
        directoryClient: ShareDirectoryClient;
        directoryCreateResponse: DirectoryCreateResponse;
    }>;
    /**
     * Removes the specified empty sub directory under this directory.
     * Note that the directory must be empty before it can be deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param directoryName -
     * @param options - Options to Directory Delete operation.
     * @returns Directory deletion response data.
     */
    deleteSubdirectory(directoryName: string, options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    /**
     * Creates a new file or replaces a file under this directory. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param fileName -
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns File creation response data and the corresponding file client.
     */
    createFile(fileName: string, size: number, options?: FileCreateOptions): Promise<{
        fileClient: ShareFileClient;
        fileCreateResponse: FileCreateResponse;
    }>;
    /**
     * Removes the specified file under this directory from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param fileName - Name of the file to delete
     * @param options - Options to File Delete operation.
     * @returns File deletion response data.
     */
    deleteFile(fileName: string, options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    /**
     * Creates a {@link ShareFileClient} object.
     *
     * @param fileName - A file name.
     * @returns A new ShareFileClient object for the given file name.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!"
     *
     * const fileClient = directoryClient.getFileClient("<file name>");
     *
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    getFileClient(fileName: string): ShareFileClient;
    /**
     * Returns true if the specified directory exists; false otherwise.
     *
     * NOTE: use this function with care since an existing directory might be deleted by other clients or
     * applications. Vice versa new directories might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    exists(options?: DirectoryExistsOptions): Promise<boolean>;
    /**
     * Returns all system properties for the specified directory, and can also be used to check the
     * existence of a directory. The data returned does not include the files in the directory or any
     * subdirectories.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-directory-properties
     *
     * @param options - Options to Directory Get Properties operation.
     * @returns Response data for the Directory Get Properties operation.
     */
    getProperties(options?: DirectoryGetPropertiesOptions): Promise<DirectoryGetPropertiesResponse>;
    /**
     * Removes the specified empty directory. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options - Options to Directory Delete operation.
     * @returns Response data for the Directory Delete operation.
     */
    delete(options?: DirectoryDeleteOptions): Promise<DirectoryDeleteResponse>;
    /**
     * Removes the specified empty directory if it exists. Note that the directory must be empty before it can be
     * deleted.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-directory
     *
     * @param options -
     */
    deleteIfExists(options?: DirectoryDeleteOptions): Promise<DirectoryDeleteIfExistsResponse>;
    /**
     * Updates user defined metadata for the specified directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-directory-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to Directory Set Metadata operation.
     * @returns Response data for the Directory Set Metadata operation.
     */
    setMetadata(metadata?: Metadata, options?: DirectorySetMetadataOptions): Promise<DirectorySetMetadataResponse>;
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListFilesAndDirectoriesSegmentResponse} objects
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of files and directories to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all files and directories remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list files and directories operation.
     */
    private iterateFilesAndDirectoriesSegments;
    /**
     * Returns an AsyncIterableIterator for file and directory items
     *
     * @param options - Options to list files and directories operation.
     */
    private listFilesAndDirectoriesItems;
    /**
     * Returns an async iterable iterator to list all the files and directories
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the files and directories in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const entity of directoryClient.listFilesAndDirectories()) {
     *   if (entity.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.name}`);
     *   }
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = directoryClient.listFilesAndDirectories();
     * let entity = await iter.next();
     * while (!entity.done) {
     *   if (entity.value.kind === "directory") {
     *     console.log(`${i++} - directory\t: ${entity.value.name}`);
     *   } else {
     *     console.log(`${i++} - file\t: ${entity.value.name}`);
     *   }
     *   entity = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ maxPageSize: 20 })) {
     *   for (const fileItem of response.segment.fileItems) {
     *     console.log(`${i++} - file\t: ${fileItem.name}`);
     *   }
     *   for (const dirItem of response.segment.directoryItems) {
     *     console.log(`${i++} - directory\t: ${dirItem.name}`);
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = directoryClient.listFilesAndDirectories().byPage({ maxPageSize: 3 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 3 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     *
     * // Gets next marker
     * let dirMarker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = directoryClient
     *   .listFilesAndDirectories()
     *   .byPage({ continuationToken: dirMarker, maxPageSize: 4 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 file and directory names
     * for (const fileItem of response.segment.fileItems) {
     *   console.log(`${i++} - file\t: ${fileItem.name}`);
     * }
     *
     * for (const dirItem of response.segment.directoryItems) {
     *   console.log(`${i++} - directory\t: ${dirItem.name}`);
     * }
     * ```
     *
     * @param options - Options to list files and directories operation.
     * @returns An asyncIterableIterator that supports paging.
     */
    listFilesAndDirectories(options?: DirectoryListFilesAndDirectoriesOptions): PagedAsyncIterableIterator<({
        kind: "file";
    } & FileItem) | ({
        kind: "directory";
    } & DirectoryItem), DirectoryListFilesAndDirectoriesSegmentResponse>;
    /**
     * Returns a list of files or directories under the specified share or directory. It lists the
     * contents only for a single level of the directory hierarchy.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-directories-and-files
     *
     * @param marker - A string value that identifies the portion of the list to be returned with the next list operation.
     * @param options - Options to Directory List Files and Directories Segment operation.
     * @returns Response data for the Directory List Files and Directories operation.
     */
    private listFilesAndDirectoriesSegment;
    /**
     * Returns an AsyncIterableIterator for {@link DirectoryListHandlesResponse}
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    private iterateHandleSegments;
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    private listHandleItems;
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * for await (const handle of iter) {
     *   console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = dirClient.listHandles();
     * let handleItem = await iter.next();
     * while (!handleItem.done) {
     *   console.log(`Handle ${i++}: ${handleItem.value.path}, opened time ${handleItem.value.openTime}, clientIp ${handleItem.value.clientIp}`);
     *   handleItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of dirClient.listHandles({ recursive: true }).byPage({ maxPageSize: 20 })) {
     *   if (response.handleList) {
     *     for (const handle of response.handleList) {
     *       console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = dirClient.listHandles().byPage({ maxPageSize: 2 });
     * let response = await iterator.next();
     *
     * // Prints 2 handles
     * if (response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.value.continuationToken;
     *
     * // Passing next marker as continuationToken
     * console.log(`    continuation`);
     * iterator = dirClient.listHandles().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = await iterator.next();
     *
     * // Prints 2 more handles assuming you have more than four directory/files opened
     * if (!response.done && response.value.handleList) {
     *   for (const handle of response.value.handleList) {
     *     console.log(`Handle ${i++}: ${handle.path}, opened time ${handle.openTime}, clientIp ${handle.clientIp}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    listHandles(options?: DirectoryListHandlesOptions): PagedAsyncIterableIterator<HandleItem, DirectoryListHandlesResponse>;
    /**
     * Lists handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    private listHandlesSegment;
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options -
     */
    private forceCloseHandlesSegment;
    /**
     * Force close all handles for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options -
     */
    forceCloseAllHandles(options?: DirectoryForceCloseHandlesSegmentOptions): Promise<CloseHandlesInfo>;
    /**
     * Force close a specific handle for a directory.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param aborter - Create a new Aborter instance with Aborter.none or Aborter.timeout(),
     *                          goto documents of Aborter for more examples about request cancellation
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseHandlesSegment() to close all handles.
     * @param options -
     */
    forceCloseHandle(handleId: string, options?: DirectoryForceCloseHandlesOptions): Promise<DirectoryForceCloseHandlesResponse>;
}
/**
 * Options to configure the {@link ShareClient.exists} operation.
 */
export declare interface ShareExistsOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this ID.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * A ShareFileClient represents a URL to an Azure Storage file.
 */
export declare class ShareFileClient extends StorageClient {
    /**
     * context provided by protocol layer.
     */
    private context;
    private _shareName;
    private _path;
    private _name;
    readonly shareName: string;
    readonly path: string;
    readonly name: string;
    /**
     * Creates an instance of ShareFileClient.
     *
     * @param url - A URL string pointing to Azure Storage file, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory/file". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString".
     *                     This method accepts an encoded URL or non-encoded URL pointing to a file.
     *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.
     *                     However, if a file or directory name includes %, file or directory name must be encoded in the URL.
     *                     Such as a file named "myfile%", the URL should be "https://myaccount.file.core.windows.net/myshare/mydirectory/myfile%25".
     * @param credential - Such as AnonymousCredential or StorageSharedKeyCredential.
     *                                  If not specified, AnonymousCredential is used.
     * @param options - Optional. Options to configure the HTTP pipeline.
     */
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    /**
     * Creates an instance of ShareFileClient.
     *
     * @param url - A URL string pointing to Azure Storage file, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory/file". You can
     *                     append a SAS if using AnonymousCredential, such as
     *                     "https://myaccount.file.core.windows.net/myshare/mydirectory/file?sasString".
     *                     This method accepts an encoded URL or non-encoded URL pointing to a file.
     *                     Encoded URL string will NOT be escaped twice, only special characters in URL path will be escaped.
     *                     However, if a file or directory name includes %, file or directory name must be encoded in the URL.
     *                     Such as a file named "myfile%", the URL should be "https://myaccount.file.core.windows.net/myshare/mydirectory/myfile%25".
     * @param pipeline - Call newPipeline() to create a default
     *                            pipeline, or provide a customized pipeline.
     */
    constructor(url: string, pipeline: Pipeline);
    /**
     * Creates a new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base ShareFileClient.
     *
     * @param shareSnapshot - The share snapshot timestamp.
     * @returns A new ShareFileClient object identical to the source but with the specified share snapshot timestamp.
     */
    withShareSnapshot(shareSnapshot: string): ShareFileClient;
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param size - Specifies the maximum size in bytes for the file, up to 4 TB.
     * @param options - Options to File Create operation.
     * @returns Response data for the File Create  operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    create(size: number, options?: FileCreateOptions): Promise<FileCreateResponse>;
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream `readableStreamBody`
     * * In browsers, data returns in a promise `contentAsBlob`
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file
     *
     * @param offset - From which position of the file to download, greater than or equal to 0
     * @param count - How much data to be downloaded, greater than 0. Will download to the end when undefined
     * @param options - Options to File Download operation.
     * @returns Response data for the File Download operation.
     *
     * Example usage (Node.js):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download();
     * console.log(
     *   "Downloaded file content:",
     *   (await streamToBuffer(downloadFileResponse.readableStreamBody)).toString()}
     * );
     *
     * // A helper method used to read a Node.js readable stream into string
     * async function streamToBuffer(readableStream) {
     *   return new Promise((resolve, reject) => {
     *     const chunks = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data instanceof Buffer ? data : Buffer.from(data));
     *     });
     *     readableStream.on("end", () => {
     *       resolve(Buffer.concat(chunks));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * Example usage (browsers):
     *
     * ```js
     * // Download a file to a string
     * const downloadFileResponse = await fileClient.download(0);
     * console.log(
     *   "Downloaded file content:",
     *   await blobToString(await downloadFileResponse.blobBody)}
     * );
     *
     * // A helper method used to convert a browser Blob into string.
     * export async function blobToString(blob: Blob): Promise<string> {
     *   const fileReader = new FileReader();
     *   return new Promise<string>((resolve, reject) => {
     *     fileReader.onloadend = (ev: any) => {
     *       resolve(ev.target!.result);
     *     };
     *     fileReader.onerror = reject;
     *     fileReader.readAsText(blob);
     *   });
     * }
     * ```
     */
    download(offset?: number, count?: number, options?: FileDownloadOptions): Promise<FileDownloadResponseModel>;
    /**
     * Returns true if the specified file exists; false otherwise.
     *
     * NOTE: use this function with care since an existing file might be deleted by other clients or
     * applications. Vice versa new files might be added by other clients or applications after this
     * function completes.
     *
     * @param options - options to Exists operation.
     */
    exists(options?: FileExistsOptions): Promise<boolean>;
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the file. It does not return the content of the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties
     *
     * @param options - Options to File Get Properties operation.
     * @returns Response data for the File Get Properties operation.
     */
    getProperties(options?: FileGetPropertiesOptions): Promise<FileGetPropertiesResponse>;
    /**
     * Sets properties on the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param properties - File properties. For file HTTP headers(e.g. Content-Type),
     *                                       if no values are provided, existing HTTP headers will be removed.
     *                                       For other file properties(e.g. fileAttributes), if no values are provided,
     *                                       existing values will be preserved.
     */
    setProperties(properties?: FileProperties): Promise<SetPropertiesResponse>;
    /**
     * Removes the file from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options - Options to File Delete operation.
     * @returns Response data for the File Delete operation.
     */
    delete(options?: FileDeleteOptions): Promise<FileDeleteResponse>;
    /**
     * Removes the file from the storage account if it exists.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param options -
     */
    deleteIfExists(options?: FileDeleteOptions): Promise<FileDeleteIfExistsResponse>;
    /**
     * Sets HTTP headers on the file.
     *
     * If no option provided, or no value provided for the file HTTP headers in the options,
     * these file HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param FileHttpHeaders - File HTTP headers like Content-Type.
     *                                             Provide undefined will remove existing HTTP headers.
     * @param options - Options to File Set HTTP Headers operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    setHttpHeaders(fileHttpHeaders?: FileHttpHeaders, options?: FileSetHttpHeadersOptions): Promise<FileSetHTTPHeadersResponse>;
    /**
     * Resize file.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param length - Resizes a file to the specified size in bytes.
     *                        If the specified byte value is less than the current size of the file,
     *                        then all ranges above the specified byte value are cleared.
     * @param options - Options to File Resize operation.
     * @returns Response data for the File Set HTTP Headers operation.
     */
    resize(length: number, options?: FileResizeOptions): Promise<FileSetHTTPHeadersResponse>;
    /**
     * Updates user-defined metadata for the specified file.
     *
     * If no metadata defined in the option parameter, the file
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata
     *
     * @param metadata - If no metadata provided, all existing directory metadata will be removed
     * @param options - Options to File Set Metadata operation.
     * @returns Response data for the File Set Metadata operation.
     */
    setMetadata(metadata?: Metadata, options?: FileSetMetadataOptions): Promise<FileSetMetadataResponse>;
    /**
     * Upload a range of bytes to a file. This operation can only be called on an existing file.
     * It won't change the size, properties or metadata of the file.
     * Both the start and count of the range must be specified. The range can be up to 4 MB in size.
     *
     * @param body - Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param offset - Offset position of the destination Azure File to upload.
     * @param contentLength - Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param options - Options to File Upload Range operation.
     * @returns Response data for the File Upload Range operation.
     *
     * Example usage:
     *
     * ```js
     * const content = "Hello world!";
     *
     * // Create the file
     * await fileClient.create(content.length);
     * console.log("Created file successfully!");
     *
     * // Then upload data to the file
     * await fileClient.uploadRange(content, 0, content.length);
     * console.log("Updated file successfully!")
     * ```
     */
    uploadRange(body: HttpRequestBody, offset: number, contentLength: number, options?: FileUploadRangeOptions): Promise<FileUploadRangeResponse>;
    /**
     * Upload a range of bytes to a file where the contents are read from a another file's URL.
     * The range can be up to 4 MB in size.
     *
     * @param sourceURL - Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.
     * @param sourceOffset - The source offset to copy from. Pass 0 to copy from the beginning of source file.
     * @param destOffset - Offset of destination file.
     * @param count - Number of bytes to be uploaded from source file.
     * @param options - Options to configure File - Upload Range from URL operation.
     */
    uploadRangeFromURL(sourceURL: string, sourceOffset: number, destOffset: number, count: number, options?: FileUploadRangeFromURLOptions): Promise<FileUploadRangeFromURLResponse>;
    /**
     * Clears the specified range and
     * releases the space used in storage for that range.
     *
     * @param offset -
     * @param contentLength -
     * @param options - Options to File Clear Range operation.
     */
    clearRange(offset: number, contentLength: number, options?: FileClearRangeOptions): Promise<FileUploadRangeResponse>;
    /**
     * Returns the list of valid ranges for a file.
     *
     * @param options - Options to File Get range List operation.
     */
    getRangeList(options?: FileGetRangeListOptions): Promise<FileGetRangeListResponse>;
    /**
     * Returns the list of ranges that differ between a previous share snapshot and this file.
     *
     * @param prevShareSnapshot - The previous snapshot parameter is an opaque DateTime value that specifies the previous share snapshot to compare with.
     * @param options -
     */
    getRangeListDiff(prevShareSnapshot: string, options?: FileGetRangeListOptions): Promise<FileGetRangeListDiffResponse>;
    /**
     * Copies a blob or file to a destination file within the storage account.
     *
     * @param copySource - Specifies the URL of the source file or blob, up to 2 KB in length.
     * To copy a file to another file within the same storage account, you may use Shared Key to
     * authenticate the source file. If you are copying a file from another storage account, or if you
     * are copying a blob from the same storage account or another storage account, then you must
     * authenticate the source file or blob using a shared access signature. If the source is a public
     * blob, no authentication is required to perform the copy operation. A file in a share snapshot
     * can also be specified as a copy source.
     * @param options - Options to File Start Copy operation.
     */
    startCopyFromURL(copySource: string, options?: FileStartCopyOptions): Promise<FileStartCopyResponse>;
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file
     *
     * @param copyId - Id of the Copy File operation to abort.
     * @param options - Options to File Abort Copy From URL operation.
     */
    abortCopyFromURL(copyId: string, options?: FileAbortCopyFromURLOptions): Promise<FileAbortCopyResponse>;
    /**
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Buffer(Node)/Blob/ArrayBuffer/ArrayBufferView to it.
     *
     * @param data - Buffer(Node), Blob, ArrayBuffer or ArrayBufferView
     * @param options -
     */
    uploadData(data: Buffer | Blob | ArrayBuffer | ArrayBufferView, options?: FileParallelUploadOptions): Promise<void>;
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,
     * which need to return a Blob object with the offset and size provided.
     *
     * @param blobFactory -
     * @param size -
     * @param options -
     */
    uploadSeekableBlob(blobFactory: (offset: number, size: number) => Blob, size: number, options?: FileParallelUploadOptions): Promise<void>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a local file to it.
     *
     * @param filePath - Full path of local file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    uploadFile(filePath: string, options?: FileParallelUploadOptions): Promise<void>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.
     * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset
     * is the offset in the Azure file to be uploaded.
     *
     * @param streamFactory - Returns a Node.js Readable stream starting
     *                                                                  from the offset defined
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    uploadResetableStream(streamFactory: (offset: number, count?: number) => NodeJS.ReadableStream, size: number, options?: FileParallelUploadOptions): Promise<void>;
    /**
     *
     * @param bodyFactory -
     * @param size - Size of the Azure file
     * @param fileClient - ShareFileClient
     * @param options -
     */
    private uploadSeekableInternal;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure file in parallel to a buffer.
     * Offset and count are optional, pass 0 for both to download the entire file.
     *
     * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two
     * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,
     * consider {@link downloadToFile}.
     *
     * @param buffer - Buffer to be fill, must have length larger than count
     * @param offset - From which position of the Azure File to download
     * @param count - How much data to be downloaded. Will download to the end when passing undefined
     * @param options -
     */
    downloadToBuffer(buffer: Buffer, offset?: number, count?: number, options?: FileDownloadToBufferOptions): Promise<Buffer>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME
     *
     * Downloads an Azure file in parallel to a buffer.
     * Offset and count are optional, pass 0 for both to download the entire file
     *
     * Warning: Buffers can only support files up to about one gigabyte on 32-bit systems or about two
     * gigabytes on 64-bit systems due to limitations of Node.js/V8. For files larger than this size,
     * consider {@link downloadToFile}.
     *
     * @param offset - From which position of the Azure file to download
     * @param count - How much data to be downloaded. Will download to the end when passing undefined
     * @param options -
     */
    downloadToBuffer(offset?: number, count?: number, options?: FileDownloadToBufferOptions): Promise<Buffer>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Creates a new Azure File or replaces an existing Azure File, and then uploads a Node.js Readable stream into it.
     * This method will try to create an Azure File, then starts uploading chunk by chunk.
     * Size of chunk is defined by `bufferSize` parameter.
     * Please make sure potential size of stream doesn't exceed file size.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *   parameter, which will avoid Buffer.concat() operations.
     *
     * @param stream - Node.js Readable stream. Must be less or equal than file size.
     * @param size - Size of file to be created. Maximum size allowed is 4 TB.
     *                      If this value is larger than stream size, there will be empty bytes in file tail.
     * @param bufferSize - Size of every buffer allocated in bytes, also the chunk/range size during
     *                            the uploaded file. Size must be greater than 0 and lesser than or equal to 4 * 1024 * 1024 (4MB)
     * @param maxBuffers - Max buffers will allocate during uploading, positive correlation
     *                            with max uploading concurrency
     * @param options -
     */
    uploadStream(stream: Readable, size: number, bufferSize: number, maxBuffers: number, options?: FileUploadStreamOptions): Promise<void>;
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param filePath -
     * @param offset - From which position of the block blob to download.
     * @param count - How much data to be downloaded. Will download to the end when passing undefined.
     * @param options - Options to Blob download options.
     * @returns The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     */
    downloadToFile(filePath: string, offset?: number, count?: number, options?: FileDownloadOptions): Promise<FileDownloadResponseModel>;
    /**
     * Lists handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param marker - Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options -
     */
    private listHandlesSegment;
    /**
     * Returns an AsyncIterableIterator for FileListHandlesResponse
     *
     * @param marker - A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param options - Options to list handles operation.
     */
    private iterateHandleSegments;
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @param options - Options to list handles operation.
     */
    private listHandleItems;
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * @param options - Options to list handles operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    listHandles(options?: FileListHandlesOptions): PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse>;
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param marker - Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param options - Options to force close handles operation.
     */
    private forceCloseHandlesSegment;
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param options - Options to force close handles operation.
     */
    forceCloseAllHandles(options?: FileForceCloseHandlesOptions): Promise<CloseHandlesInfo>;
    /**
     * Force close a specific handle for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param handleId - Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseAllHandles() to close all handles.
     * @param FileForceCloseHandlesOptions - Options to force close handles operation.
     */
    forceCloseHandle(handleId: string, options?: FileForceCloseHandlesOptions): Promise<FileForceCloseHandlesResponse>;
    /**
     * Get a {@link ShareLeaseClient} that manages leases on the file.
     *
     * @param proposeLeaseId - Initial proposed lease Id.
     * @returns A new ShareLeaseClient object for managing leases on the file.
     */
    getShareLeaseClient(proposeLeaseId?: string): ShareLeaseClient;
    /**
     * Only available for clients constructed with a shared key credential.
     *
     * Generates a Service Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     * @param options - Optional parameters.
     * @returns The SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateSasUrl(options: FileGenerateSasUrlOptions): string;
}
/** The list of file ranges */
export declare interface ShareFileRangeList {
    ranges?: RangeModel[];
    clearRanges?: ClearRange[];
}
/**
 * Options to configure {@link ShareClient.generateSasUrl} operation.
 */
export declare interface ShareGenerateSasUrlOptions extends CommonGenerateSasUrlOptions {
    /**
     * Optional only when identifier is provided. Specifies the list of permissions to be associated with the SAS.
     */
    permissions?: ShareSASPermissions;
}
/** Defines headers for Share_getAccessPolicy operation. */
export declare interface ShareGetAccessPolicyHeaders {
    /** The ETag contains a value that you can use to perform operations conditionally, in quotes. */
    etag?: string;
    /** Returns the date and time the share was last modified. Any operation that modifies the share or its properties updates the last modified time. Operations on files do not affect the last modified time of the share. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.getAccessPolicy} operation.
 */
export declare interface ShareGetAccessPolicyOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this ID.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
export declare type ShareGetAccessPolicyResponse = {
    signedIdentifiers: SignedIdentifier[];
} & ShareGetAccessPolicyHeaders & {
    /**
     * The underlying HTTP response.
     */
    _response: HttpResponse & {
        /**
         * The parsed HTTP response headers.
         */
        parsedHeaders: ShareGetAccessPolicyHeaders;
        /**
         * The response body as text (string format)
         */
        bodyAsText: string;
        /**
         * The response body as parsed JSON or XML
         */
        parsedBody: SignedIdentifierModel[];
    };
};
/** Defines headers for Share_getPermission operation. */
export declare interface ShareGetPermissionHeaders {
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.getPermission} operation.
 */
export declare interface ShareGetPermissionOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
}
/** Contains response data for the getPermission operation. */
export declare type ShareGetPermissionResponse = ShareGetPermissionHeaders & SharePermission & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: SharePermission;
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareGetPermissionHeaders;
    };
};
/** Defines headers for Share_getProperties operation. */
export declare interface ShareGetPropertiesHeaders {
    /** A set of name-value pairs that contain the user-defined metadata of the share. */
    metadata?: {
        [propertyName: string]: string;
    };
    /** The ETag contains a value that you can use to perform operations conditionally, in quotes. */
    etag?: string;
    /** Returns the date and time the share was last modified. Any operation that modifies the share or its properties updates the last modified time. Operations on files do not affect the last modified time of the share. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Returns the current share quota in GB. */
    quota?: number;
    /** Returns the current share provisioned ipos. */
    provisionedIops?: number;
    /** Returns the current share provisioned ingress in megabytes per second. */
    provisionedIngressMBps?: number;
    /** Returns the current share provisioned egress in megabytes per second. */
    provisionedEgressMBps?: number;
    /** Returns the current share next allowed quota downgrade time. */
    nextAllowedQuotaDowngradeTime?: Date;
    /** When a share is leased, specifies whether the lease is of infinite or fixed duration. */
    leaseDuration?: LeaseDurationType;
    /** Lease state of the share. */
    leaseState?: LeaseStateType;
    /** The current lease status of the share. */
    leaseStatus?: LeaseStatusType;
    /** Returns the access tier set on the share. */
    accessTier?: string;
    /** Returns the last modified time (in UTC) of the access tier of the share. */
    accessTierChangeTime?: Date;
    /** Returns the transition state between access tiers, when present. */
    accessTierTransitionState?: string;
    /** The protocols that have been enabled on the share. */
    enabledProtocols?: string;
    /** Valid for NFS shares only. */
    rootSquash?: ShareRootSquash;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.getProperties} operation.
 */
export declare interface ShareGetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this ID.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the {@link ShareClient.getProperties} operation.
 */
export declare type ShareGetPropertiesResponse = ShareGetPropertiesResponseModel & {
    /**
     * The protocols that have been enabled on the share.
     */
    protocols?: ShareProtocols;
};
/** Contains response data for the getProperties operation. */
export declare type ShareGetPropertiesResponseModel = ShareGetPropertiesHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareGetPropertiesHeaders;
    };
};
/** Defines headers for Share_getStatistics operation. */
export declare interface ShareGetStatisticsHeaders {
    /** The ETag contains a value that you can use to perform operations conditionally, in quotes. */
    etag?: string;
    /** Returns the date and time the share was last modified. Any operation that modifies the share or its properties updates the last modified time. Operations on files do not affect the last modified time of the share. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.getStatistics} operation.
 */
export declare interface ShareGetStatisticsOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this ID.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Response data for the {@link ShareClient.getStatistics} Operation.
 */
export declare type ShareGetStatisticsResponse = ShareGetStatisticsResponseModel & {
    /**
     * @deprecated shareUsage is going to be deprecated. Please use ShareUsageBytes instead.
     *
     * The approximate size of the data stored on the share, rounded up to the nearest gigabyte. Note
     * that this value may not include all recently created or recently resized files.
     */
    shareUsage: number;
};
/** Contains response data for the getStatistics operation. */
export declare type ShareGetStatisticsResponseModel = ShareGetStatisticsHeaders & ShareStats & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: ShareStats;
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareGetStatisticsHeaders;
    };
};
/**
 * A listed Azure Storage share item.
 */
export declare interface ShareItem {
    name: string;
    snapshot?: string;
    deleted?: boolean;
    version?: string;
    properties: ShareProperties;
    metadata?: {
        [propertyName: string]: string;
    };
}
/** A listed Azure Storage share item. */
export declare interface ShareItemInternal {
    name: string;
    snapshot?: string;
    deleted?: boolean;
    version?: string;
    /** Properties of a share. */
    properties: SharePropertiesInternal;
    /** Dictionary of <string> */
    metadata?: {
        [propertyName: string]: string;
    };
}
/**
 * A client that manages leases for a {@link ShareFileClient} or {@link ShareClient}.
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-file
 * and
 * @see https://docs.microsoft.com/rest/api/storageservices/lease-share
 */
export declare class ShareLeaseClient {
    private _leaseId;
    private _url;
    private fileOrShare;
    private isShare;
    readonly leaseId: string;
    readonly url: string;
    /**
     * Creates an instance of ShareLeaseClient.
     * @param client - The client to make the lease operation requests.
     * @param leaseId - Initial proposed lease id.
     */
    constructor(client: ShareFileClient, leaseId?: string);
    /**
     * Establishes and manages a lock on a file, share or share snapshot for write and delete operations.
     *
     * @param duration - Specifies the duration of lease in seconds. For file, the only allowed value is -1 for a lease that never expires. For share, must be -1 or between 15 to 60.
     * @param options - Options for the lease management operation.
     * @returns Response data for acquire lease operation.
     */
    acquireLease(duration?: number, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    /**
     * To change the ID of an existing lease.
     *
     * @param proposedLeaseId - the proposed new lease Id.
     * @param options - Options for the lease management operation.
     * @returns Response data for change lease operation.
     */
    changeLease(proposedLeaseId: string, options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    /**
     * To free the lease if it is no longer needed so that another client may
     * immediately acquire a lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for release lease operation.
     */
    releaseLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    /**
     * To force end the lease.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for break lease operation.
     */
    breakLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
    /**
     * To renew the lease. Only available for lease on share or share snapshot.
     * Note that the lease may be renewed even if it has expired as long as the share has not been leased again since the expiration of that lease.
     * When you renew a lease, the lease duration clock resets.
     *
     * @param options - Options for the lease management operation.
     * @returns Response data for renew lease operation.
     */
    renewLease(options?: LeaseOperationOptions): Promise<LeaseOperationResponse>;
}
/** A permission (a security descriptor) at the share level. */
export declare interface SharePermission {
    /** The permission in the Security Descriptor Definition Language (SDDL). */
    permission: string;
}
/**
 * Properties of a share.
 */
export declare type ShareProperties = SharePropertiesInternal & {
    /**
     * The protocols that have been enabled on the share.
     */
    protocols?: ShareProtocols;
};
/** Properties of a share. */
export declare interface SharePropertiesInternal {
    lastModified: Date;
    etag: string;
    quota: number;
    provisionedIops?: number;
    provisionedIngressMBps?: number;
    provisionedEgressMBps?: number;
    nextAllowedQuotaDowngradeTime?: Date;
    deletedTime?: Date;
    remainingRetentionDays?: number;
    accessTier?: string;
    accessTierChangeTime?: Date;
    accessTierTransitionState?: string;
    /** The current lease status of the share. */
    leaseStatus?: LeaseStatusType;
    /** Lease state of the share. */
    leaseState?: LeaseStateType;
    /** When a share is leased, specifies whether the lease is of infinite or fixed duration. */
    leaseDuration?: LeaseDurationType;
    enabledProtocols?: string;
    rootSquash?: ShareRootSquash;
}
/**
 * Protocols to enable on the share. For now, only support SMB or NFS.
 */
export declare interface ShareProtocols {
    /**
     * The share can be accessed by SMBv3.0, SMBv2.1 and REST.
     */
    smbEnabled?: boolean;
    /**
     * The share can be accessed by NFSv4.1.
     */
    nfsEnabled?: boolean;
}
/** Protocol settings */
export declare interface ShareProtocolSettings {
    /** Settings for SMB protocol. */
    smb?: ShareSmbSettings;
}
/** Defines values for ShareRootSquash. */
export declare type ShareRootSquash = "NoRootSquash" | "RootSquash" | "AllSquash";
/**
 * This is a helper class to construct a string representing the permissions granted by a ServiceSAS to a share.
 * Setting a value to true means that any SAS which uses these permissions will grant permissions for that operation.
 * Once all the values are set, this should be serialized with toString and set as the permissions field on a
 * {@link FileSASSignatureValues} object. It is possible to construct the permissions string without this class, but
 * the order of the permissions is particular and this class guarantees correctness.
 */
export declare class ShareSASPermissions {
    /**
     * Creates an {@link ShareSASPermissions} from the specified permissions string. This method will throw an
     * Error if it encounters a character that does not correspond to a valid permission.
     *
     * @param permissions -
     */
    static parse(permissions: string): ShareSASPermissions;
    /**
     * Specifies Read access granted.
     */
    read: boolean;
    /**
     * Specifies Create access granted.
     */
    create: boolean;
    /**
     * Specifies Write access granted.
     */
    write: boolean;
    /**
     * Specifies Delete access granted.
     */
    delete: boolean;
    /**
     * Specifies List access granted.
     */
    list: boolean;
    /**
     * Converts the given permissions to a string. Using this method will guarantee the permissions are in an
     * order accepted by the service.
     *
     * The order of the characters should be as specified here to ensure correctness.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas
     *
     */
    toString(): string;
}
/**
 * A ShareServiceClient represents a URL to the Azure Storage File service allowing you
 * to manipulate file shares.
 */
export declare class ShareServiceClient extends StorageClient {
    /**
     * serviceContext provided by protocol layer.
     */
    private serviceContext;
    /**
     *
     * Creates an instance of ShareServiceClient from connection string.
     *
     * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
     *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                                  Account connection string example -
     *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                                  SAS connection string example -
     *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param options - Options to configure the HTTP pipeline.
     * @returns A new ShareServiceClient from the given connection string.
     */
    static fromConnectionString(connectionString: string, options?: StoragePipelineOptions): ShareServiceClient;
    /**
     * Creates an instance of ShareServiceClient.
     *
     * @param url - A URL string pointing to Azure Storage file service, such as
     *                     "https://myaccount.file.core.windows.net". You can Append a SAS
     *                     if using AnonymousCredential, such as "https://myaccount.file.core.windows.net?sasString".
     * @param credential - Such as AnonymousCredential or StorageSharedKeyCredential.
     *                                  If not specified, AnonymousCredential is used.
     * @param options - Optional. Options to configure the HTTP pipeline.
     */
    constructor(url: string, credential?: Credential, options?: StoragePipelineOptions);
    /**
     * Creates an instance of ShareServiceClient.
     *
     * @param url - A URL string pointing to Azure Storage file service, such as
     *                     "https://myaccount.file.core.windows.net". You can Append a SAS
     *                     if using AnonymousCredential, such as "https://myaccount.file.core.windows.net?sasString".
     * @param pipeline - Call newPipeline() to create a default
     *                            pipeline, or provide a customized pipeline.
     */
    constructor(url: string, pipeline: Pipeline);
    /**
     * Creates a ShareClient object.
     *
     * @param shareName - Name of a share.
     * @returns The ShareClient object for the given share name.
     *
     * Example usage:
     *
     * ```js
     * const shareClient = serviceClient.getShareClient("<share name>");
     * await shareClient.create();
     * console.log("Created share successfully!");
     * ```
     */
    getShareClient(shareName: string): ShareClient;
    /**
     * Creates a Share.
     *
     * @param shareName -
     * @param options -
     * @returns Share creation response and the corresponding share client.
     */
    createShare(shareName: string, options?: ShareCreateOptions): Promise<{
        shareCreateResponse: ShareCreateResponse;
        shareClient: ShareClient;
    }>;
    /**
     * Deletes a Share.
     *
     * @param shareName -
     * @param options -
     * @returns Share deletion response and the corresponding share client.
     */
    deleteShare(shareName: string, options?: ShareDeleteMethodOptions): Promise<ShareDeleteResponse>;
    /**
     * Gets the properties of a storage accounts file service, including properties
     * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-service-properties
     *
     * @param options - Options to Get Properties operation.
     * @returns Response data for the Get Properties operation.
     */
    getProperties(options?: ServiceGetPropertiesOptions): Promise<ServiceGetPropertiesResponse>;
    /**
     * Sets properties for a storage accounts file service endpoint, including properties
     * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-service-properties
     *
     * @param properties -
     * @param options - Options to Set Properties operation.
     * @returns Response data for the Set Properties operation.
     */
    setProperties(properties: FileServiceProperties, options?: ServiceSetPropertiesOptions): Promise<ServiceSetPropertiesResponse>;
    /**
     * Returns an AsyncIterableIterator for {@link ServiceListSharesSegmentResponse} objects
     *
     * @param marker - A string value that identifies the portion of
     *                          the list of shares to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all shares remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param options - Options to list shares operation.
     */
    private listSegments;
    /**
     * Returns an AsyncIterableIterator for share items
     *
     * @param options - Options to list shares operation.
     */
    private listItems;
    /**
     * Returns an async iterable iterator to list all the shares
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the shares in pages.
     *
     * Example using `for await` syntax:
     *
     * ```js
     * let i = 1;
     * for await (const share of serviceClient.listShares()) {
     *   console.log(`Share ${i++}: ${share.name}`);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```js
     * let i = 1;
     * let iter = serviceClient.listShares();
     * let shareItem = await iter.next();
     * while (!shareItem.done) {
     *   console.log(`Share ${i++}: ${shareItem.value.name}`);
     *   shareItem = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```js
     * // passing optional maxPageSize in the page settings
     * let i = 1;
     * for await (const response of serviceClient.listShares().byPage({ maxPageSize: 20 })) {
     *   if (response.shareItems) {
     *    for (const share of response.shareItems) {
     *        console.log(`Share ${i++}: ${share.name}`);
     *     }
     *   }
     * }
     * ```
     *
     * Example using paging with a marker:
     *
     * ```js
     * let i = 1;
     * let iterator = serviceClient.listShares().byPage({ maxPageSize: 2 });
     * let response = (await iterator.next()).value;
     *
     * // Prints 2 share names
     * if (response.shareItems) {
     *   for (const share of response.shareItems) {
     *     console.log(`Share ${i++}: ${share.name}`);
     *   }
     * }
     *
     * // Gets next marker
     * let marker = response.continuationToken;
     *
     * // Passing next marker as continuationToken
     * iterator = serviceClient.listShares().byPage({ continuationToken: marker, maxPageSize: 10 });
     * response = (await iterator.next()).value;
     *
     * // Prints 10 share names
     * if (response.shareItems) {
     *   for (const share of response.shareItems) {
     *     console.log(`Share ${i++}: ${share.name}`);
     *   }
     * }
     * ```
     *
     * @param options - Options to list shares operation.
     *
     * An asyncIterableIterator that supports paging.
     */
    listShares(options?: ServiceListSharesOptions): PagedAsyncIterableIterator<ShareItem, ServiceListSharesSegmentResponse>;
    /**
     * Gets the properties of a storage account's File service, including properties for Storage
     * Analytics metrics and CORS (Cross-Origin Resource Sharing) rules.
     *
     * @param marker - A string value that identifies the portion of
     *                          the list to be returned with the next list operation. The operation
     *                          returns a marker value within the response body if the list returned was
     *                          not complete. The marker value may then be used in a subsequent call to
     *                          request the next set of list items. The marker value is opaque to the
     *                          client.
     * @param options - Options to List Shares Segment operation.
     * @returns Response data for the List Shares Segment operation.
     */
    private listSharesSegment;
    /**
     * Restores a previously deleted share.
     * This API is only functional if Share Soft Delete is enabled
     * for the storage account associated with the share.
     *
     * @param deletedShareName - The name of the previously deleted share.
     * @param deletedShareVersion - The version of the previously deleted share.
     * @param options - Options to Share undelete operation.
     * @returns Restored share.
     */
    undeleteShare(deletedShareName: string, deletedShareVersion: string, options?: ServiceUndeleteShareOptions): Promise<ShareClient>;
    /**
     * Only available for ShareServiceClient constructed with a shared key credential.
     *
     * Generates an account Shared Access Signature (SAS) URI based on the client properties
     * and parameters passed in. The SAS is signed by the shared key credential of the client.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-account-sas
     *
     * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not specified.
     * @param permissions - Specifies the list of permissions to be associated with the SAS.
     * @param resourceTypes - Specifies the resource types associated with the shared access signature.
     * @param options - Optional parameters.
     * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.
     */
    generateAccountSasUrl(expiresOn?: Date, permissions?: AccountSASPermissions, resourceTypes?: string, options?: ServiceGenerateAccountSasUrlOptions): string;
}
/** Defines headers for Share_setAccessPolicy operation. */
export declare interface ShareSetAccessPolicyHeaders {
    /** The ETag contains a value that you can use to perform operations conditionally, in quotes. */
    etag?: string;
    /** Returns the date and time the share was last modified. Any operation that modifies the share or its properties updates the last modified time. Operations on files do not affect the last modified time of the share. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.setAccessPolicy} operation.
 */
export declare interface ShareSetAccessPolicyOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this ID.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the setAccessPolicy operation. */
export declare type ShareSetAccessPolicyResponse = ShareSetAccessPolicyHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareSetAccessPolicyHeaders;
    };
};
/** Defines headers for Share_setMetadata operation. */
export declare interface ShareSetMetadataHeaders {
    /** The ETag contains a value that you can use to perform operations conditionally, in quotes. */
    etag?: string;
    /** Returns the date and time the share was last modified. Any operation that modifies the share or its properties updates the last modified time. Operations on files do not affect the last modified time of the share. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.setMetadata} operation.
 */
export declare interface ShareSetMetadataOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this ID.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the setMetadata operation. */
export declare type ShareSetMetadataResponse = ShareSetMetadataHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareSetMetadataHeaders;
    };
};
/** Defines headers for Share_setProperties operation. */
export declare interface ShareSetPropertiesHeaders {
    /** The ETag contains a value that you can use to perform operations conditionally, in quotes. */
    etag?: string;
    /** Returns the date and time the share was last modified. Any operation that modifies the share or its properties updates the last modified time. Operations on files do not affect the last modified time of the share. */
    lastModified?: Date;
    /** This header uniquely identifies the request that was made and can be used for troubleshooting the request. */
    requestId?: string;
    /** Indicates the version of the File service used to execute the request. */
    version?: string;
    /** A UTC date/time value generated by the service that indicates the time at which the response was initiated. */
    date?: Date;
    /** Error Code */
    errorCode?: string;
}
/**
 * Options to configure the {@link ShareClient.setProperties} operation.
 */
export declare interface ShareSetPropertiesOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * Specifies the access tier of the share. Possible values include: 'TransactionOptimized',
     * 'Hot', 'Cool'.
     */
    accessTier?: ShareAccessTier;
    /**
     * Specifies the maximum size of the share, in gigabytes.
     */
    quotaInGB?: number;
    /**
     * Root squash to set on the share.  Only valid for NFS shares. Possible values include:
     * 'NoRootSquash', 'RootSquash', 'AllSquash'.
     */
    rootSquash?: ShareRootSquash;
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this ID.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/** Contains response data for the setProperties operation. */
export declare type ShareSetPropertiesResponse = ShareSetPropertiesHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: ShareSetPropertiesHeaders;
    };
};
/**
 * Defines headers for setQuota operation.
 */
export declare type ShareSetQuotaHeaders = ShareSetPropertiesHeaders;
/**
 * Options to configure the {@link ShareClient.setQuota} operation.
 */
export declare interface ShareSetQuotaOptions extends CommonOptions {
    /**
     * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.
     * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.
     */
    abortSignal?: AbortSignalLike;
    /**
     * If specified, the operation only succeeds if the resource's lease is active and matches this ID.
     */
    leaseAccessConditions?: LeaseAccessConditions;
}
/**
 * Contains response data for the setQuota operation.
 */
export declare type ShareSetQuotaResponse = ShareSetPropertiesResponse;
/** Settings for SMB protocol. */
export declare interface ShareSmbSettings {
    /** Settings for SMB Multichannel. */
    multichannel?: SmbMultichannel;
}
/** Stats for the share. */
export declare interface ShareStats {
    /** The approximate size of the data stored in bytes. Note that this value may not include all recently created or recently resized files. */
    shareUsageBytes: number;
}
/**
 * Signed Identifier
 */
export declare interface SignedIdentifier {
    /**
     * a unique id
     */
    id: string;
    /**
     * Access Policy
     */
    accessPolicy: {
        /**
         * the date-time the policy is active.
         */
        startsOn: Date;
        /**
         * the date-time the policy expires.
         */
        expiresOn: Date;
        /**
         * the permissions for the acl policy
         * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-share-acl
         */
        permissions: string;
    };
}
/** Signed identifier. */
export declare interface SignedIdentifierModel {
    /** A unique id. */
    id: string;
    /** The access policy. */
    accessPolicy?: AccessPolicy;
}
/** Settings for SMB multichannel */
export declare interface SmbMultichannel {
    /** If SMB multichannel is enabled. */
    enabled?: boolean;
}
/** Parameter group */
export declare interface SourceModifiedAccessConditions {
    /** Specify the crc64 value to operate only on range with a matching crc64 checksum. */
    sourceIfMatchCrc64?: Uint8Array;
    /** Specify the crc64 value to operate only on range without a matching crc64 checksum. */
    sourceIfNoneMatchCrc64?: Uint8Array;
}
/**
 * StorageBrowserPolicy will handle differences between Node.js and browser runtime, including:
 *
 * 1. Browsers cache GET/HEAD requests by adding conditional headers such as 'IF_MODIFIED_SINCE'.
 * StorageBrowserPolicy is a policy used to add a timestamp query to GET/HEAD request URL
 * thus avoid the browser cache.
 *
 * 2. Remove cookie header for security
 *
 * 3. Remove content-length header to avoid browsers warning
 */
export declare class StorageBrowserPolicy extends BaseRequestPolicy {
    /**
     * Creates an instance of StorageBrowserPolicy.
     * @param nextPolicy -
     * @param options -
     */
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions);
    /**
     * Sends out request.
     *
     * @param request -
     */
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
}
/**
 * StorageBrowserPolicyFactory is a factory class helping generating BrowserPolicy objects.
 */
export declare class StorageBrowserPolicyFactory implements RequestPolicyFactory {
    /**
     * Creates a StorageBrowserPolicyFactory object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageBrowserPolicy;
}
/**
 * A StorageClient represents a base client class for ServiceClient, ContainerClient and etc.
 */
declare abstract class StorageClient {
    /**
     * URL string value.
     */
    readonly url: string;
    readonly accountName: string;
    /* Excluded from this release type: pipeline */
    /* Excluded from this release type: credential */
    /**
     * StorageClient is a reference to protocol layer operations entry, which is
     * generated by AutoRest generator.
     */
    protected readonly storageClientContext: StorageClientContext;
    /**
     * Creates an instance of StorageClient.
     * @param url -
     * @param pipeline -
     */
    protected constructor(url: string, pipeline: Pipeline);
}
declare class StorageClientContext extends coreHttp.ServiceClient {
    url: string;
    version: string;
    fileRangeWriteFromUrl: string;
    /**
     * Initializes a new instance of the StorageClientContext class.
     * @param url The URL of the service account, share, directory or file that is the target of the
     *            desired operation.
     * @param options The parameter options
     */
    constructor(url: string, options?: StorageClientOptionalParams);
}
/** Optional parameters. */
declare interface StorageClientOptionalParams extends coreHttp.ServiceClientOptions {
    /** Specifies the version of the operation to use for this request. */
    version?: string;
    /** Only update is supported: - Update: Writes the bytes downloaded from the source url into the specified range. */
    fileRangeWriteFromUrl?: string;
    /** Overrides client endpoint. */
    endpoint?: string;
}
/**
 * Option interface for {@link newPipeline} function.
 */
export declare interface StoragePipelineOptions {
    /**
     * Options to configure a proxy for outgoing requests.
     */
    proxyOptions?: ProxyOptions;
    /**
     * Options for adding user agent details to outgoing requests.
     */
    userAgentOptions?: UserAgentOptions;
    /**
     * Configures the built-in retry policy behavior.
     */
    retryOptions?: StorageRetryOptions;
    /**
     * Keep alive configurations. Default keep-alive is enabled.
     */
    keepAliveOptions?: KeepAliveOptions;
    /**
     * Configures the HTTP client to send requests and receive responses.
     */
    httpClient?: IHttpClient;
}
/**
 * Retry options interface.
 */
export declare interface StorageRetryOptions {
    /**
     * Optional. StorageRetryPolicyType, default is exponential retry policy.
     */
    readonly retryPolicyType?: StorageRetryPolicyType;
    /**
     * Optional. Max try number of attempts, default is 4.
     * A value of 1 means 1 try and no retries.
     * A value smaller than 1 means default retry number of attempts.
     */
    readonly maxTries?: number;
    /**
     * Optional. Indicates the maximum time in ms allowed for any single try of an HTTP request.
     * A value of zero or undefined means that you accept our default timeout, 60s or 60 * 1000ms.
     *
     * NOTE: When transferring large amounts of data, the default TryTimeout will probably
     * not be sufficient. You should override this value based on the bandwidth available to
     * the host machine and proximity to the Storage service. A good starting point may be something
     * like (60 seconds per MB of anticipated-payload-size)
     */
    readonly tryTimeoutInMs?: number;
    /**
     * Optional. Specifies the amount of delay to use before retrying an operation (default is 4s or 4 * 1000ms).
     * The delay increases (exponentially or linearly) with each retry up to a maximum specified by
     * maxRetryDelayInMs. If you specify 0, then you must also specify 0 for maxRetryDelayInMs.
     */
    readonly retryDelayInMs?: number;
    /**
     * Optional. Specifies the maximum delay allowed before retrying an operation (default is 120s or 120 * 1000ms).
     * If you specify 0, then you must also specify 0 for retryDelayInMs.
     */
    readonly maxRetryDelayInMs?: number;
}
/**
 * Retry policy with exponential retry and linear retry implemented.
 */
export declare class StorageRetryPolicy extends BaseRequestPolicy {
    /**
     * RetryOptions.
     */
    private readonly retryOptions;
    /**
     * Creates an instance of RetryPolicy.
     *
     * @param nextPolicy -
     * @param options -
     * @param retryOptions -
     */
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, retryOptions?: StorageRetryOptions);
    /**
     * Sends request.
     *
     * @param request -
     */
    sendRequest(request: WebResource): Promise<HttpOperationResponse>;
    /**
     * Decide and perform next retry. Won't mutate request parameter.
     *
     * @param request -
     * @param response -
     * @param secondaryHas404 -  If attempt was against the secondary & it returned a StatusNotFound (404), then
     *                                   the resource was not found. This may be due to replication delay. So, in this
     *                                   case, we'll never try the secondary again for this operation.
     * @param attempt -           How many retries has been attempted to performed, starting from 1, which includes
     *                                   the attempt will be performed by this method call.
     */
    protected attemptSendRequest(request: WebResource, secondaryHas404: boolean, attempt: number): Promise<HttpOperationResponse>;
    /**
     * Decide whether to retry according to last HTTP response and retry counters.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param response -
     * @param err -
     */
    protected shouldRetry(isPrimaryRetry: boolean, attempt: number, response?: HttpOperationResponse, err?: RestError): boolean;
    /**
     * Delay a calculated time between retries.
     *
     * @param isPrimaryRetry -
     * @param attempt -
     * @param abortSignal -
     */
    private delay;
}
/**
 * StorageRetryPolicyFactory is a factory class helping generating StorageRetryPolicy objects.
 */
export declare class StorageRetryPolicyFactory implements RequestPolicyFactory {
    private retryOptions?;
    /**
     * Creates an instance of StorageRetryPolicyFactory.
     * @param retryOptions -
     */
    constructor(retryOptions?: StorageRetryOptions);
    /**
     * Creates a StorageRetryPolicy object.
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageRetryPolicy;
}
/**
 * RetryPolicy types.
 */
export declare enum StorageRetryPolicyType {
    /**
     * Exponential retry. Retry time delay grows exponentially.
     */
    EXPONENTIAL = 0,
    /**
     * Linear retry. Retry time delay grows linearly.
     */
    FIXED = 1
}
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * StorageSharedKeyCredential for account key authorization of Azure Storage service.
 */
export declare class StorageSharedKeyCredential extends Credential {
    /**
     * Azure Storage account name; readonly.
     */
    readonly accountName: string;
    /**
     * Azure Storage account key; readonly.
     */
    private readonly accountKey;
    /**
     * Creates an instance of StorageSharedKeyCredential.
     * @param accountName -
     * @param accountKey -
     */
    constructor(accountName: string, accountKey: string);
    /**
     * Creates a {@link StorageSharedKeyCredentialPolicy} object.
     *
     * @param nextPolicy -
     * @param options -
     */
    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions): StorageSharedKeyCredentialPolicy;
    /**
     * Generates a hash signature for an HTTP request or for a SAS.
     *
     * @param stringToSign -
     */
    computeHMACSHA256(stringToSign: string): string;
}
/**
 * StorageSharedKeyCredentialPolicy is a policy used to sign HTTP request with a shared key.
 */
export declare class StorageSharedKeyCredentialPolicy extends CredentialPolicy {
    /**
     * Reference to {@link StorageSharedKeyCredential} which generates StorageSharedKeyCredentialPolicy
     */
    private readonly factory;
    /**
     * Creates an instance of StorageSharedKeyCredentialPolicy.
     * @param nextPolicy -
     * @param options -
     * @param factory -
     */
    constructor(nextPolicy: RequestPolicy, options: RequestPolicyOptions, factory: StorageSharedKeyCredential);
    /**
     * Signs request.
     *
     * @param request -
     */
    protected signRequest(request: WebResource): WebResource;
    /**
     * Retrieve header value according to shared key sign rules.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/authenticate-with-shared-key
     *
     * @param request -
     * @param headerName -
     */
    private getHeaderValueToSign;
    /**
     * To construct the CanonicalizedHeaders portion of the signature string, follow these steps:
     * 1. Retrieve all headers for the resource that begin with x-ms-, including the x-ms-date header.
     * 2. Convert each HTTP header name to lowercase.
     * 3. Sort the headers lexicographically by header name, in ascending order.
     *    Each header may appear only once in the string.
     * 4. Replace any linear whitespace in the header value with a single space.
     * 5. Trim any whitespace around the colon in the header.
     * 6. Finally, append a new-line character to each canonicalized header in the resulting list.
     *    Construct the CanonicalizedHeaders string by concatenating all headers in this list into a single string.
     *
     * @param request -
     */
    private getCanonicalizedHeadersString;
    /**
     * Retrieves the webResource canonicalized resource string.
     *
     * @param request -
     */
    private getCanonicalizedResourceString;
}
/**
 * Indicates setting as the time of the request.
 */
export declare type TimeNowType = "now";
/**
 * Indicates keep existing time value unchanged.
 */
export declare type TimePreserveType = "preserve";
export { WebResource };
export {};
