// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { logger } from "./logger";
export function throwIfUndefined(input, options = {}) {
    var _a;
    if (input === undefined) {
        throw new Error((_a = options.errorMessage) !== null && _a !== void 0 ? _a : "undefined variable");
    }
    return input;
}
export function updatePollingUrl(inputs) {
    var _a, _b;
    const { info, rawResponse } = inputs;
    switch (info.mode) {
        case "OperationLocation": {
            const operationLocation = getOperationLocation(rawResponse);
            const azureAsyncOperation = getAzureAsyncOperation(rawResponse);
            info.pollingUrl =
                (_a = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation })) !== null && _a !== void 0 ? _a : throwIfUndefined(info.pollingUrl);
            break;
        }
        case "ResourceLocation": {
            info.pollingUrl = (_b = getLocation(rawResponse)) !== null && _b !== void 0 ? _b : throwIfUndefined(info.pollingUrl);
            break;
        }
    }
}
function getOperationLocationPollingUrl(inputs) {
    const { azureAsyncOperation, operationLocation } = inputs;
    return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;
}
function getLocation(rawResponse) {
    return rawResponse.headers["location"];
}
function getOperationLocation(rawResponse) {
    return rawResponse.headers["operation-location"];
}
function getAzureAsyncOperation(rawResponse) {
    return rawResponse.headers["azure-asyncoperation"];
}
function findResourceLocation(inputs) {
    const { location, requestMethod, requestPath, lroResourceLocationConfig } = inputs;
    switch (requestMethod) {
        case "PUT": {
            return requestPath;
        }
        case "DELETE": {
            return undefined;
        }
        default: {
            switch (lroResourceLocationConfig) {
                case "azure-async-operation": {
                    return undefined;
                }
                case "original-uri": {
                    return requestPath;
                }
                case "location":
                default: {
                    return location;
                }
            }
        }
    }
}
function inferLroMode(inputs) {
    const { rawResponse, requestMethod, requestPath, lroResourceLocationConfig } = inputs;
    const operationLocation = getOperationLocation(rawResponse);
    const azureAsyncOperation = getAzureAsyncOperation(rawResponse);
    const location = getLocation(rawResponse);
    if (operationLocation !== undefined || azureAsyncOperation !== undefined) {
        return {
            mode: "OperationLocation",
            pollingUrl: operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation,
            resourceLocation: findResourceLocation({
                requestMethod,
                location,
                requestPath,
                lroResourceLocationConfig,
            }),
        };
    }
    else if (location !== undefined) {
        return {
            mode: "ResourceLocation",
            pollingUrl: location,
        };
    }
    else if (requestMethod === "PUT") {
        return {
            mode: "Body",
            pollingUrl: requestPath,
        };
    }
    else {
        return {
            mode: "None",
        };
    }
}
class SimpleRestError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = "RestError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, SimpleRestError.prototype);
    }
}
function throwIfError(rawResponse) {
    const code = rawResponse.statusCode;
    if (code >= 400) {
        throw new SimpleRestError(`Received unexpected HTTP status code ${code} while polling. This may indicate a server issue.`, code);
    }
}
function getStatus(rawResponse) {
    var _a;
    const { status } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
    return typeof status === "string" ? status.toLowerCase() : "succeeded";
}
function getProvisioningState(rawResponse) {
    var _a, _b;
    const { properties, provisioningState } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
    const state = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;
    return typeof state === "string" ? state.toLowerCase() : "succeeded";
}
function isCanceled(operation) {
    const { state, operationStatus } = operation;
    if (["canceled", "cancelled"].includes(operationStatus)) {
        state.isCancelled = true;
        return true;
    }
    return false;
}
function isTerminal(operation) {
    const { state, operationStatus } = operation;
    if (operationStatus === "failed") {
        throw new Error(`The long-running operation has failed.`);
    }
    return operationStatus === "succeeded" || isCanceled({ state, operationStatus });
}
function getOperationStatus(result) {
    const { rawResponse, state, info, responseKind = "Polling" } = result;
    throwIfError(rawResponse);
    switch (info.mode) {
        case "OperationLocation": {
            const operationStatus = getStatus(rawResponse);
            return {
                operationStatus,
                shouldStopPolling: responseKind === "Polling" && isTerminal({ state, operationStatus }),
            };
        }
        case "Body": {
            const operationStatus = getProvisioningState(rawResponse);
            return {
                operationStatus,
                shouldStopPolling: isTerminal({ state, operationStatus }),
            };
        }
        case "ResourceLocation": {
            const operationStatus = rawResponse.statusCode;
            return {
                operationStatus,
                shouldStopPolling: responseKind === "Polling" && operationStatus !== 202,
            };
        }
        case "None": {
            return {
                shouldStopPolling: true,
            };
        }
    }
}
function shouldStopPolling(result) {
    const { rawResponse, state, info, responseKind = "Polling" } = result;
    const { shouldStopPolling: isPollingStopped, operationStatus } = getOperationStatus({
        info,
        rawResponse,
        state,
        responseKind,
    });
    if (operationStatus) {
        logger.verbose(`LRO: Status:\n\tPolling from: ${info.pollingUrl}\n\tOperation status: ${operationStatus}\n\tPolling status: ${isPollingStopped ? "Stopped" : "Running"}`);
    }
    else {
        logger.verbose(`LRO: Status: Not an LRO`);
    }
    return isPollingStopped;
}
/**
 * Creates a polling operation.
 */
export function createPoll(lroPrimitives) {
    return async (path, pollerConfig, getLroStatusFromResponse) => {
        const response = await lroPrimitives.sendPollRequest(path);
        const retryAfter = response.rawResponse.headers["retry-after"];
        if (retryAfter !== undefined) {
            // Retry-After header value is either in HTTP date format, or in seconds
            const retryAfterInSeconds = parseInt(retryAfter);
            pollerConfig.intervalInMs = isNaN(retryAfterInSeconds)
                ? calculatePollingIntervalFromDate(new Date(retryAfter), pollerConfig.intervalInMs)
                : retryAfterInSeconds * 1000;
        }
        return getLroStatusFromResponse(response);
    };
}
function calculatePollingIntervalFromDate(retryAfterDate, defaultIntervalInMs) {
    const timeNow = Math.floor(new Date().getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
        return retryAfterTime - timeNow;
    }
    return defaultIntervalInMs;
}
export function buildResult(inputs) {
    const { processResult, response, state } = inputs;
    return processResult ? processResult(response, state) : response;
}
/**
 * Creates a callback to be used to initialize the polling operation state.
 */
export function createStateInitializer(inputs) {
    const { requestMethod, requestPath, state, lroResourceLocationConfig, processResult } = inputs;
    return (response) => {
        const { rawResponse } = response;
        state.isStarted = true;
        state.config = inferLroMode({
            rawResponse,
            requestPath,
            requestMethod,
            lroResourceLocationConfig,
        });
        logger.verbose(`LRO: Operation description:`, state.config);
        /** short circuit before polling */
        if (shouldStopPolling({
            rawResponse,
            state,
            info: state.config,
            responseKind: "Initial",
        })) {
            state.result = buildResult({
                response: response.flatResponse,
                state: state,
                processResult,
            });
            state.isCompleted = true;
        }
    };
}
export function createGetLroStatusFromResponse(inputs) {
    const { lro, state, info } = inputs;
    const location = info.resourceLocation;
    return (response) => {
        const isTerminalStatus = shouldStopPolling({
            info,
            rawResponse: response.rawResponse,
            state,
        });
        return Object.assign(Object.assign({}, response), { done: isTerminalStatus && !location, next: !(isTerminalStatus && location)
                ? undefined
                : () => lro.sendPollRequest(location).then((res) => (Object.assign(Object.assign({}, res), { done: true }))) });
    };
}
//# sourceMappingURL=impl.js.map