{"version":3,"file":"msal-node.cjs.production.min.js","sources":["../src/utils/Constants.ts","../src/network/HttpClient.ts","../src/config/Configuration.ts","../src/utils/NetworkUtils.ts","../src/utils/EncodingUtils.ts","../src/crypto/PkceGenerator.ts","../src/crypto/CryptoProvider.ts","../src/crypto/GuidGenerator.ts","../src/cache/serializer/Deserializer.ts","../src/cache/serializer/Serializer.ts","../src/cache/NodeStorage.ts","../src/cache/TokenCache.ts","../src/client/ClientApplication.ts","../src/packageMetadata.ts","../src/client/ClientAssertion.ts","../src/client/ConfidentialClientApplication.ts","../src/client/PublicClientApplication.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\n/**\r\n * http methods\r\n */\r\nexport enum HttpMethod {\r\n    GET = \"get\",\r\n    POST = \"post\",\r\n}\r\n\r\n/**\r\n * Constants used for region discovery\r\n */\r\nexport const REGION_ENVIRONMENT_VARIABLE = \"REGION_NAME\";\r\n\r\n/**\r\n * Constant used for PKCE\r\n */\r\nexport const RANDOM_OCTET_SIZE = 32;\r\n\r\n/**\r\n * Constants used in PKCE\r\n */\r\nexport const Hash = {\r\n    SHA256: \"sha256\",\r\n};\r\n\r\n/**\r\n * Constants for encoding schemes\r\n */\r\nexport const CharSet = {\r\n    CV_CHARSET:\r\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\",\r\n};\r\n\r\n/**\r\n * Cache Constants\r\n */\r\nexport const CACHE = {\r\n    FILE_CACHE: \"fileCache\",\r\n    EXTENSION_LIB: \"extenstion_library\",\r\n};\r\n\r\n/**\r\n * Constants\r\n */\r\nexport const Constants = {\r\n    MSAL_SKU: \"msal.js.node\",\r\n    JWT_BEARER_ASSERTION_TYPE: \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\"\r\n};\r\n\r\n/**\r\n * API Codes for Telemetry purposes.\r\n * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs\r\n * 0-99 Silent Flow\r\n * 600-699 Device Code Flow\r\n * 800-899 Auth Code Flow\r\n */\r\nexport enum ApiId {\r\n    acquireTokenSilent = 62,\r\n    acquireTokenByUsernamePassword = 371,\r\n    acquireTokenByDeviceCode = 671,\r\n    acquireTokenByClientCredential = 771,\r\n    acquireTokenByCode = 871,\r\n    acquireTokenByRefreshToken = 872\r\n}\r\n\r\n/**\r\n * JWT  constants\r\n */\r\nexport const JwtConstants = {\r\n    ALGORITHM: \"alg\",\r\n    RSA_256: \"RS256\",\r\n    X5T: \"x5t\", \r\n    X5C: \"x5c\",\r\n    AUDIENCE: \"aud\",\r\n    EXPIRATION_TIME: \"exp\",\r\n    ISSUER: \"iss\",\r\n    SUBJECT: \"sub\",\r\n    NOT_BEFORE: \"nbf\",\r\n    JWT_ID: \"jti\",\r\n};\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    INetworkModule,\r\n    NetworkRequestOptions,\r\n    NetworkResponse,\r\n} from \"@azure/msal-common\";\r\nimport { HttpMethod } from \"../utils/Constants\";\r\nimport axios, { AxiosRequestConfig } from \"axios\";\r\n\r\n/**\r\n * This class implements the API for network requests.\r\n */\r\nexport class HttpClient implements INetworkModule {\r\n\r\n    /**\r\n     * Http Get request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendGetRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions\r\n    ): Promise<NetworkResponse<T>> {\r\n        const request: AxiosRequestConfig = {\r\n            method: HttpMethod.GET,\r\n            url: url,\r\n            /* istanbul ignore next */\r\n            headers: options && options.headers,\r\n            /* istanbul ignore next */\r\n            validateStatus: () => true\r\n        };\r\n\r\n        const response = await axios(request);\r\n        return {\r\n            headers: response.headers,\r\n            body: response.data as T,\r\n            status: response.status,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Http Post request\r\n     * @param url\r\n     * @param options\r\n     */\r\n    async sendPostRequestAsync<T>(\r\n        url: string,\r\n        options?: NetworkRequestOptions,\r\n        cancellationToken?: number \r\n    ): Promise<NetworkResponse<T>> {\r\n        const request: AxiosRequestConfig = {\r\n            method: HttpMethod.POST,\r\n            url: url,\r\n            /* istanbul ignore next */\r\n            data: (options && options.body) || \"\",\r\n            timeout: cancellationToken,\r\n            /* istanbul ignore next */\r\n            headers: options && options.headers,\r\n            /* istanbul ignore next */\r\n            validateStatus: () => true\r\n        };\r\n\r\n        const response = await axios(request);\r\n        return {\r\n            headers: response.headers,\r\n            body: response.data as T,\r\n            status: response.status,\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    LoggerOptions,\r\n    INetworkModule,\r\n    LogLevel,\r\n    ProtocolMode,\r\n    ICachePlugin, Constants\r\n} from \"@azure/msal-common\";\r\nimport { NetworkUtils } from \"../utils/NetworkUtils\";\r\n\r\n/**\r\n * - clientId               - Client id of the application.\r\n * - authority              - Url of the authority. If no value is set, defaults to https://login.microsoftonline.com/common.\r\n * - knownAuthorities       - Needed for Azure B2C and ADFS. All authorities that will be used in the client application. Only the host of the authority should be passed in.\r\n * - clientSecret           - Secret string that the application uses when requesting a token. Only used in confidential client applications. Can be created in the Azure app registration portal.\r\n * - clientAssertion        - Assertion string that the application uses when requesting a token. Only used in confidential client applications. Assertion should be of type urn:ietf:params:oauth:client-assertion-type:jwt-bearer.\r\n * - clientCertificate      - Certificate that the application uses when requesting a token. Only used in confidential client applications. Requires hex encoded X.509 SHA-1 thumbprint of the certificiate, and the PEM encoded private key (string should contain -----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY----- )\r\n * - protocolMode           - Enum that represents the protocol that msal follows. Used for configuring proper endpoints.\r\n * @public\r\n */\r\nexport type NodeAuthOptions = {\r\n    clientId: string;\r\n    authority?: string;\r\n    clientSecret?: string;\r\n    clientAssertion?:string;\r\n    clientCertificate?: {\r\n        thumbprint: string,\r\n        privateKey: string,\r\n        x5c?: string\r\n    };\r\n    knownAuthorities?: Array<string>;\r\n    cloudDiscoveryMetadata?: string;\r\n    authorityMetadata?: string,\r\n    clientCapabilities?: Array<string>;\r\n    protocolMode?: ProtocolMode;\r\n};\r\n\r\n/**\r\n * Use this to configure the below cache configuration options:\r\n *\r\n * - cachePlugin   - Plugin for reading and writing token cache to disk.\r\n * @public\r\n */\r\nexport type CacheOptions = {\r\n    cachePlugin?: ICachePlugin;\r\n};\r\n\r\n/**\r\n * Type for configuring logger and http client options\r\n *\r\n * - logger                       - Used to initialize the Logger object; TODO: Expand on logger details or link to the documentation on logger\r\n * - networkClient                - Http client used for all http get and post calls. Defaults to using MSAL's default http client.\r\n * @public\r\n */\r\nexport type NodeSystemOptions = {\r\n    loggerOptions?: LoggerOptions;\r\n    networkClient?: INetworkModule;\r\n};\r\n\r\n/**\r\n * Use the configuration object to configure MSAL and initialize the client application object\r\n *\r\n * - auth: this is where you configure auth elements like clientID, authority used for authenticating against the Microsoft Identity Platform\r\n * - cache: this is where you configure cache location\r\n * - system: this is where you can configure the network client, logger\r\n * @public\r\n */\r\nexport type Configuration = {\r\n    auth: NodeAuthOptions;\r\n    cache?: CacheOptions;\r\n    system?: NodeSystemOptions;\r\n};\r\n\r\nconst DEFAULT_AUTH_OPTIONS: Required<NodeAuthOptions> = {\r\n    clientId: \"\",\r\n    authority: Constants.DEFAULT_AUTHORITY,\r\n    clientSecret: \"\",\r\n    clientAssertion: \"\",\r\n    clientCertificate: {\r\n        thumbprint: \"\",\r\n        privateKey: \"\",\r\n        x5c: \"\"\r\n    },\r\n    knownAuthorities: [],\r\n    cloudDiscoveryMetadata: \"\",\r\n    authorityMetadata: \"\",\r\n    clientCapabilities: [],\r\n    protocolMode: ProtocolMode.AAD\r\n};\r\n\r\nconst DEFAULT_CACHE_OPTIONS: CacheOptions = {};\r\n\r\nconst DEFAULT_LOGGER_OPTIONS: LoggerOptions = {\r\n    loggerCallback: (): void => {\r\n        // allow users to not set logger call back\r\n    },\r\n    piiLoggingEnabled: false,\r\n    logLevel: LogLevel.Info,\r\n};\r\n\r\nconst DEFAULT_SYSTEM_OPTIONS: Required<NodeSystemOptions> = {\r\n    loggerOptions: DEFAULT_LOGGER_OPTIONS,\r\n    networkClient: NetworkUtils.getNetworkClient(),\r\n};\r\n\r\nexport type NodeConfiguration = {\r\n    auth: Required<NodeAuthOptions>;\r\n    cache: CacheOptions;\r\n    system: Required<NodeSystemOptions>;\r\n};\r\n\r\n/**\r\n * Sets the default options when not explicitly configured from app developer\r\n *\r\n * @param auth - Authentication options\r\n * @param cache - Cache options\r\n * @param system - System options\r\n *\r\n * @returns Configuration\r\n * @public\r\n */\r\nexport function buildAppConfiguration({\r\n    auth,\r\n    cache,\r\n    system,\r\n}: Configuration): NodeConfiguration {\r\n    return {\r\n        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\r\n        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },\r\n        system: { ...DEFAULT_SYSTEM_OPTIONS, ...system },\r\n    };\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { INetworkModule } from \"@azure/msal-common\";\r\nimport { HttpClient } from \"../network/HttpClient\";\r\n\r\nexport class NetworkUtils {\r\n    /**\r\n     * Returns best compatible network client object.\r\n     */\r\n    static getNetworkClient(): INetworkModule {\r\n        return new HttpClient();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nexport class EncodingUtils {\r\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param str text\r\n     */\r\n    static base64Encode(str: string, encoding?: BufferEncoding): string {\r\n        return Buffer.from(str, encoding).toString(\"base64\");\r\n    }\r\n\r\n    /**\r\n     * encode a URL\r\n     * @param str\r\n     */\r\n    static base64EncodeUrl(str: string, encoding?: BufferEncoding): string {\r\n        return EncodingUtils.base64Encode(str, encoding)\r\n            .replace(/=/g, \"\")\r\n            .replace(/\\+/g, \"-\")\r\n            .replace(/\\//g, \"_\");\r\n    }\r\n\r\n    /**\r\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\r\n     * 'base64': Base64 encoding.\r\n     *\r\n     * @param base64Str Base64 encoded text\r\n     */\r\n    static base64Decode(base64Str: string): string {\r\n        return Buffer.from(base64Str, \"base64\").toString(\"utf8\");\r\n    }\r\n\r\n    /**\r\n     * @param base64Str Base64 encoded Url\r\n     */\r\n    static base64DecodeUrl(base64Str: string): string {\r\n        let str = base64Str.replace(/-/g, \"+\").replace(/_/g, \"/\");\r\n        while (str.length % 4) {\r\n            str += \"=\";\r\n        }\r\n        return EncodingUtils.base64Decode(str);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { PkceCodes } from \"@azure/msal-common\";\r\nimport { CharSet, Hash, RANDOM_OCTET_SIZE } from \"../utils/Constants\";\r\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\r\nimport crypto from \"crypto\";\r\n\r\n/**\r\n * https://tools.ietf.org/html/rfc7636#page-8\r\n */\r\nexport class PkceGenerator {\r\n    /**\r\n     * generates the codeVerfier and the challenge from the codeVerfier\r\n     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\r\n     */\r\n    async generatePkceCodes(): Promise<PkceCodes> {\r\n        const verifier = this.generateCodeVerifier();\r\n        const challenge = this.generateCodeChallengeFromVerifier(verifier);\r\n        return { verifier, challenge };\r\n    }\r\n\r\n    /**\r\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\r\n     */\r\n    private generateCodeVerifier(): string {\r\n        const charArr = [];\r\n        const maxNumber = 256 - (256 % CharSet.CV_CHARSET.length);\r\n        while (charArr.length <= RANDOM_OCTET_SIZE) {\r\n            const byte = crypto.randomBytes(1)[0];\r\n            if (byte >= maxNumber) {\r\n                /* \r\n                 * Ignore this number to maintain randomness.\r\n                 * Including it would result in an unequal distribution of characters after doing the modulo\r\n                 */\r\n                continue;\r\n            }\r\n            const index = byte % CharSet.CV_CHARSET.length;\r\n            charArr.push(CharSet.CV_CHARSET[index]);\r\n        }\r\n        const verifier: string = charArr.join(\"\");\r\n        return EncodingUtils.base64EncodeUrl(verifier);\r\n    }\r\n\r\n    /**\r\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\r\n     * @param codeVerifier\r\n     */\r\n    private generateCodeChallengeFromVerifier(codeVerifier: string): string {\r\n        return EncodingUtils.base64EncodeUrl(\r\n            this.sha256(codeVerifier).toString(\"base64\"), \r\n            \"base64\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * generate 'SHA256' hash\r\n     * @param buffer\r\n     */\r\n    private sha256(buffer: string): Buffer {\r\n        return crypto\r\n            .createHash(Hash.SHA256)\r\n            .update(buffer)\r\n            .digest();\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ICrypto, PkceCodes } from \"@azure/msal-common\";\r\nimport { GuidGenerator } from \"./GuidGenerator\";\r\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\r\nimport { PkceGenerator } from \"./PkceGenerator\";\r\n\r\n/**\r\n * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\r\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\r\n * @public\r\n */\r\nexport class CryptoProvider implements ICrypto {\r\n    private pkceGenerator: PkceGenerator;\r\n\r\n    constructor() {\r\n        // Browser crypto needs to be validated first before any other classes can be set.\r\n        this.pkceGenerator = new PkceGenerator();\r\n    }\r\n\r\n    /**\r\n     * Creates a new random GUID - used to populate state and nonce.\r\n     * @returns string (GUID)\r\n     */\r\n    createNewGuid(): string {\r\n        return GuidGenerator.generateGuid();\r\n    }\r\n\r\n    /**\r\n     * Encodes input string to base64.\r\n     * @param input - string to be encoded\r\n     */\r\n    base64Encode(input: string): string {\r\n        return EncodingUtils.base64Encode(input);\r\n    }\r\n\r\n    /**\r\n     * Decodes input string from base64.\r\n     * @param input - string to be decoded\r\n     */\r\n    base64Decode(input: string): string {\r\n        return EncodingUtils.base64Decode(input);\r\n    }\r\n\r\n    /**\r\n     * Generates PKCE codes used in Authorization Code Flow.\r\n     */\r\n    generatePkceCodes(): Promise<PkceCodes> {\r\n        return this.pkceGenerator.generatePkceCodes();\r\n    }\r\n\r\n    /**\r\n     * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node\r\n     */\r\n    getPublicKeyThumbprint(): Promise<string> {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Removes cryptographic keypair from key store matching the keyId passed in\r\n     * @param kid \r\n     */\r\n    removeTokenBindingKey(): Promise<boolean> {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Removes all cryptographic keys from Keystore\r\n     */\r\n    clearKeystore(): Promise<boolean> {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n\r\n    /**\r\n     * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node\r\n     */\r\n    signJwt(): Promise<string> {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\nexport class GuidGenerator {\r\n    /**\r\n     *\r\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\r\n     * uuidv4 generates guids from cryprtographically-string random\r\n     */\r\n    static generateGuid(): string {\r\n        return uuidv4();\r\n    }\r\n\r\n    /**\r\n     * verifies if a string is  GUID\r\n     * @param guid\r\n     */\r\n    static isGuid(guid: string): boolean {\r\n        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r\n        return regexGuid.test(guid);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { StringUtils, AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager } from \"@azure/msal-common\";\r\nimport { JsonCache, InMemoryCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\r\n\r\n/**\r\n * This class deserializes cache entities read from the file into in memory object types defined internally\r\n */\r\nexport class Deserializer {\r\n    /**\r\n     * Parse the JSON blob in memory and deserialize the content\r\n     * @param cachedJson\r\n     */\r\n    static deserializeJSONBlob(jsonFile: string): JsonCache {\r\n        const deserializedCache = StringUtils.isEmpty(jsonFile)\r\n            ? {}\r\n            : JSON.parse(jsonFile);\r\n        return deserializedCache;\r\n    }\r\n\r\n    /**\r\n     * Deserializes accounts to AccountEntity objects\r\n     * @param accounts\r\n     */\r\n    static deserializeAccounts(accounts: Record<string, SerializedAccountEntity>): AccountCache {\r\n        const accountObjects: AccountCache = {};\r\n        if (accounts) {\r\n            Object.keys(accounts).map(function (key) {\r\n                const serializedAcc = accounts[key];\r\n                const mappedAcc = {\r\n                    homeAccountId: serializedAcc.home_account_id,\r\n                    environment: serializedAcc.environment,\r\n                    realm: serializedAcc.realm,\r\n                    localAccountId: serializedAcc.local_account_id,\r\n                    username: serializedAcc.username,\r\n                    authorityType: serializedAcc.authority_type,\r\n                    name: serializedAcc.name,\r\n                    clientInfo: serializedAcc.client_info,\r\n                    lastModificationTime: serializedAcc.last_modification_time,\r\n                    lastModificationApp: serializedAcc.last_modification_app,\r\n                };\r\n                const account: AccountEntity = new AccountEntity();\r\n                CacheManager.toObject(account, mappedAcc);\r\n                accountObjects[key] = account;\r\n            });\r\n        }\r\n\r\n        return accountObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes id tokens to IdTokenEntity objects\r\n     * @param idTokens\r\n     */\r\n    static deserializeIdTokens(idTokens: Record<string, SerializedIdTokenEntity>): IdTokenCache {\r\n        const idObjects: IdTokenCache = {};\r\n        if (idTokens) {\r\n            Object.keys(idTokens).map(function (key) {\r\n                const serializedIdT = idTokens[key];\r\n                const mappedIdT = {\r\n                    homeAccountId: serializedIdT.home_account_id,\r\n                    environment: serializedIdT.environment,\r\n                    credentialType: serializedIdT.credential_type,\r\n                    clientId: serializedIdT.client_id,\r\n                    secret: serializedIdT.secret,\r\n                    realm: serializedIdT.realm,\r\n                };\r\n                const idToken: IdTokenEntity = new IdTokenEntity();\r\n                CacheManager.toObject(idToken, mappedIdT);\r\n                idObjects[key] = idToken;\r\n            });\r\n        }\r\n        return idObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes access tokens to AccessTokenEntity objects\r\n     * @param accessTokens\r\n     */\r\n    static deserializeAccessTokens(accessTokens: Record<string, SerializedAccessTokenEntity>): AccessTokenCache {\r\n        const atObjects: AccessTokenCache = {};\r\n        if (accessTokens) {\r\n            Object.keys(accessTokens).map(function (key) {\r\n                const serializedAT = accessTokens[key];\r\n                const mappedAT = {\r\n                    homeAccountId: serializedAT.home_account_id,\r\n                    environment: serializedAT.environment,\r\n                    credentialType: serializedAT.credential_type,\r\n                    clientId: serializedAT.client_id,\r\n                    secret: serializedAT.secret,\r\n                    realm: serializedAT.realm,\r\n                    target: serializedAT.target,\r\n                    cachedAt: serializedAT.cached_at,\r\n                    expiresOn: serializedAT.expires_on,\r\n                    extendedExpiresOn: serializedAT.extended_expires_on,\r\n                    refreshOn: serializedAT.refresh_on,\r\n                    keyId: serializedAT.key_id,\r\n                    tokenType: serializedAT.token_type,\r\n                };\r\n                const accessToken: AccessTokenEntity = new AccessTokenEntity();\r\n                CacheManager.toObject(accessToken, mappedAT);\r\n                atObjects[key] = accessToken;\r\n            });\r\n        }\r\n\r\n        return atObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes refresh tokens to RefreshTokenEntity objects\r\n     * @param refreshTokens\r\n     */\r\n    static deserializeRefreshTokens(refreshTokens: Record<string, SerializedRefreshTokenEntity>): RefreshTokenCache {\r\n        const rtObjects: RefreshTokenCache = {};\r\n        if (refreshTokens) {\r\n            Object.keys(refreshTokens).map(function (key) {\r\n                const serializedRT = refreshTokens[key];\r\n                const mappedRT = {\r\n                    homeAccountId: serializedRT.home_account_id,\r\n                    environment: serializedRT.environment,\r\n                    credentialType: serializedRT.credential_type,\r\n                    clientId: serializedRT.client_id,\r\n                    secret: serializedRT.secret,\r\n                    familyId: serializedRT.family_id,\r\n                    target: serializedRT.target,\r\n                    realm: serializedRT.realm,\r\n                };\r\n                const refreshToken: RefreshTokenEntity = new RefreshTokenEntity();\r\n                CacheManager.toObject(refreshToken, mappedRT);\r\n                rtObjects[key] = refreshToken;\r\n            });\r\n        }\r\n\r\n        return rtObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserializes appMetadata to AppMetaData objects\r\n     * @param appMetadata\r\n     */\r\n    static deserializeAppMetadata(appMetadata: Record<string, SerializedAppMetadataEntity>): AppMetadataCache {\r\n        const appMetadataObjects: AppMetadataCache = {};\r\n        if (appMetadata) {\r\n            Object.keys(appMetadata).map(function (key) {\r\n                const serializedAmdt = appMetadata[key];\r\n                const mappedAmd = {\r\n                    clientId: serializedAmdt.client_id,\r\n                    environment: serializedAmdt.environment,\r\n                    familyId: serializedAmdt.family_id,\r\n                };\r\n                const amd: AppMetadataEntity = new AppMetadataEntity();\r\n                CacheManager.toObject(amd, mappedAmd);\r\n                appMetadataObjects[key] = amd;\r\n            });\r\n        }\r\n\r\n        return appMetadataObjects;\r\n    }\r\n\r\n    /**\r\n     * Deserialize an inMemory Cache\r\n     * @param jsonCache\r\n     */\r\n    static deserializeAllCache(jsonCache: JsonCache): InMemoryCache {\r\n        return {\r\n            accounts: jsonCache.Account\r\n                ? this.deserializeAccounts(jsonCache.Account)\r\n                : {},\r\n            idTokens: jsonCache.IdToken\r\n                ? this.deserializeIdTokens(jsonCache.IdToken)\r\n                : {},\r\n            accessTokens: jsonCache.AccessToken\r\n                ? this.deserializeAccessTokens(jsonCache.AccessToken)\r\n                : {},\r\n            refreshTokens: jsonCache.RefreshToken\r\n                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)\r\n                : {},\r\n            appMetadata: jsonCache.AppMetadata\r\n                ? this.deserializeAppMetadata(jsonCache.AppMetadata)\r\n                : {},\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache } from \"@azure/msal-common\";\r\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\r\n\r\nexport class Serializer {\r\n    /**\r\n     * serialize the JSON blob\r\n     * @param data\r\n     */\r\n    static serializeJSONBlob(data: JsonCache): string {\r\n        return JSON.stringify(data);\r\n    }\r\n\r\n    /**\r\n     * Serialize Accounts\r\n     * @param accCache\r\n     */\r\n    static serializeAccounts(accCache: AccountCache): Record<string, SerializedAccountEntity> {\r\n        const accounts: Record<string, SerializedAccountEntity> = {};\r\n        Object.keys(accCache).map(function (key) {\r\n            const accountEntity = accCache[key];\r\n            accounts[key] = {\r\n                home_account_id: accountEntity.homeAccountId,\r\n                environment: accountEntity.environment,\r\n                realm: accountEntity.realm,\r\n                local_account_id: accountEntity.localAccountId,\r\n                username: accountEntity.username,\r\n                authority_type: accountEntity.authorityType,\r\n                name: accountEntity.name,\r\n                client_info: accountEntity.clientInfo,\r\n                last_modification_time: accountEntity.lastModificationTime,\r\n                last_modification_app: accountEntity.lastModificationApp,\r\n            };\r\n        });\r\n\r\n        return accounts;\r\n    }\r\n\r\n    /**\r\n     * Serialize IdTokens\r\n     * @param idTCache\r\n     */\r\n    static serializeIdTokens(idTCache: IdTokenCache): Record<string, SerializedIdTokenEntity> {\r\n        const idTokens: Record<string, SerializedIdTokenEntity> = {};\r\n        Object.keys(idTCache).map(function (key) {\r\n            const idTEntity = idTCache[key];\r\n            idTokens[key] = {\r\n                home_account_id: idTEntity.homeAccountId,\r\n                environment: idTEntity.environment,\r\n                credential_type: idTEntity.credentialType,\r\n                client_id: idTEntity.clientId,\r\n                secret: idTEntity.secret,\r\n                realm: idTEntity.realm,\r\n            };\r\n        });\r\n\r\n        return idTokens;\r\n    }\r\n\r\n    /**\r\n     * Serializes AccessTokens\r\n     * @param atCache\r\n     */\r\n    static serializeAccessTokens(atCache: AccessTokenCache): Record<string, SerializedAccessTokenEntity> {\r\n        const accessTokens: Record<string, SerializedAccessTokenEntity> = {};\r\n        Object.keys(atCache).map(function (key) {\r\n            const atEntity = atCache[key];\r\n            accessTokens[key] = {\r\n                home_account_id: atEntity.homeAccountId,\r\n                environment: atEntity.environment,\r\n                credential_type: atEntity.credentialType,\r\n                client_id: atEntity.clientId,\r\n                secret: atEntity.secret,\r\n                realm: atEntity.realm,\r\n                target: atEntity.target,\r\n                cached_at: atEntity.cachedAt,\r\n                expires_on: atEntity.expiresOn,\r\n                extended_expires_on: atEntity.extendedExpiresOn,\r\n                refresh_on: atEntity.refreshOn,\r\n                key_id: atEntity.keyId,\r\n                token_type: atEntity.tokenType,\r\n            };\r\n        });\r\n\r\n        return accessTokens;\r\n    }\r\n\r\n    /**\r\n     * Serialize refreshTokens\r\n     * @param rtCache\r\n     */\r\n    static serializeRefreshTokens(rtCache: RefreshTokenCache): Record<string, SerializedRefreshTokenEntity> {\r\n        const refreshTokens: Record<string, SerializedRefreshTokenEntity> = {};\r\n        Object.keys(rtCache).map(function (key) {\r\n            const rtEntity = rtCache[key];\r\n            refreshTokens[key] = {\r\n                home_account_id: rtEntity.homeAccountId,\r\n                environment: rtEntity.environment,\r\n                credential_type: rtEntity.credentialType,\r\n                client_id: rtEntity.clientId,\r\n                secret: rtEntity.secret,\r\n                family_id: rtEntity.familyId,\r\n                target: rtEntity.target,\r\n                realm: rtEntity.realm\r\n            };\r\n        });\r\n\r\n        return refreshTokens;\r\n    }\r\n\r\n    /**\r\n     * Serialize amdtCache\r\n     * @param amdtCache\r\n     */\r\n    static serializeAppMetadata(amdtCache: AppMetadataCache): Record<string, SerializedAppMetadataEntity> {\r\n        const appMetadata: Record<string, SerializedAppMetadataEntity> = {};\r\n        Object.keys(amdtCache).map(function (key) {\r\n            const amdtEntity = amdtCache[key];\r\n            appMetadata[key] = {\r\n                client_id: amdtEntity.clientId,\r\n                environment: amdtEntity.environment,\r\n                family_id: amdtEntity.familyId,\r\n            };\r\n        });\r\n\r\n        return appMetadata;\r\n    }\r\n\r\n    /**\r\n     * Serialize the cache\r\n     * @param jsonContent\r\n     */\r\n    static serializeAllCache(inMemCache: InMemoryCache): JsonCache {\r\n        return {\r\n            Account: this.serializeAccounts(inMemCache.accounts),\r\n            IdToken: this.serializeIdTokens(inMemCache.idTokens),\r\n            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\r\n            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\r\n            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    AccountEntity,\r\n    IdTokenEntity,\r\n    AccessTokenEntity,\r\n    RefreshTokenEntity,\r\n    AppMetadataEntity,\r\n    ServerTelemetryEntity,\r\n    ThrottlingEntity,\r\n    CacheManager,\r\n    Logger,\r\n    ValidCacheType,\r\n    ICrypto,\r\n    AuthorityMetadataEntity\r\n} from \"@azure/msal-common\";\r\nimport { Deserializer } from \"./serializer/Deserializer\";\r\nimport { Serializer } from \"./serializer/Serializer\";\r\nimport { InMemoryCache, JsonCache, CacheKVStore } from \"./serializer/SerializerTypes\";\r\n\r\n/**\r\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\r\n * @public\r\n */\r\nexport class NodeStorage extends CacheManager {\r\n    // Cache configuration, either set by user or default values.\r\n    private logger: Logger;\r\n    private cache: CacheKVStore = {};\r\n    private changeEmitters: Array<Function> = [];\r\n\r\n    constructor(logger: Logger, clientId: string, cryptoImpl: ICrypto) {\r\n        super(clientId, cryptoImpl);\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Queue up callbacks\r\n     * @param func - a callback function for cache change indication\r\n     */\r\n    registerChangeEmitter(func: () => void): void {\r\n        this.changeEmitters.push(func);\r\n    }\r\n\r\n    /**\r\n     * Invoke the callback when cache changes\r\n     */\r\n    emitChange(): void {\r\n        this.changeEmitters.forEach(func => func.call(null));\r\n    }\r\n\r\n    /**\r\n     * Converts cacheKVStore to InMemoryCache\r\n     * @param cache - key value store\r\n     */\r\n    cacheToInMemoryCache(cache: CacheKVStore): InMemoryCache {\r\n\r\n        const inMemoryCache: InMemoryCache = {\r\n            accounts: {},\r\n            idTokens: {},\r\n            accessTokens: {},\r\n            refreshTokens: {},\r\n            appMetadata: {},\r\n        };\r\n\r\n        for (const key in cache) {\r\n            if (cache[key as string] instanceof AccountEntity) {\r\n                inMemoryCache.accounts[key] = cache[key] as AccountEntity;\r\n            } else if (cache[key] instanceof IdTokenEntity) {\r\n                inMemoryCache.idTokens[key] = cache[key] as IdTokenEntity;\r\n            } else if (cache[key] instanceof AccessTokenEntity) {\r\n                inMemoryCache.accessTokens[key] = cache[key] as AccessTokenEntity;\r\n            } else if (cache[key] instanceof RefreshTokenEntity) {\r\n                inMemoryCache.refreshTokens[key] = cache[key] as RefreshTokenEntity;\r\n            } else if (cache[key] instanceof AppMetadataEntity) {\r\n                inMemoryCache.appMetadata[key] = cache[key] as AppMetadataEntity;\r\n            } else {\r\n                continue;\r\n            }\r\n        }\r\n\r\n        return inMemoryCache;\r\n    }\r\n\r\n    /**\r\n     * converts inMemoryCache to CacheKVStore\r\n     * @param inMemoryCache - kvstore map for inmemory\r\n     */\r\n    inMemoryCacheToCache(inMemoryCache: InMemoryCache): CacheKVStore {\r\n        // convert in memory cache to a flat Key-Value map\r\n        let cache = this.getCache();\r\n\r\n        cache = {\r\n            ...inMemoryCache.accounts,\r\n            ...inMemoryCache.idTokens,\r\n            ...inMemoryCache.accessTokens,\r\n            ...inMemoryCache.refreshTokens,\r\n            ...inMemoryCache.appMetadata\r\n        };\r\n        return cache;\r\n    }\r\n\r\n    /**\r\n     * gets the current in memory cache for the client\r\n     */\r\n    getInMemoryCache(): InMemoryCache {\r\n        this.logger.trace(\"Getting in-memory cache\");\r\n\r\n        // convert the cache key value store to inMemoryCache\r\n        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());\r\n        return inMemoryCache;\r\n    }\r\n\r\n    /**\r\n     * sets the current in memory cache for the client\r\n     * @param inMemoryCache - key value map in memory\r\n     */\r\n    setInMemoryCache(inMemoryCache: InMemoryCache): void{\r\n        this.logger.trace(\"Setting in-memory cache\");\r\n\r\n        // convert and append the inMemoryCache to cacheKVStore\r\n        const cache = this.inMemoryCacheToCache(inMemoryCache);\r\n        this.setCache(cache);\r\n\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * get the current cache key-value store\r\n     */\r\n    getCache(): CacheKVStore {\r\n        this.logger.trace(\"Getting cache key-value store\");\r\n        return this.cache;\r\n    }\r\n\r\n    /**\r\n     * sets the current cache (key value store)\r\n     * @param cacheMap - key value map\r\n     */\r\n    setCache(cache: CacheKVStore): void {\r\n        this.logger.trace(\"Setting cache key value store\");\r\n        this.cache = cache;\r\n\r\n        // mark change in cache\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key.\r\n     * @param key - lookup key for the cache entry\r\n     */\r\n    getItem(key: string): ValidCacheType {\r\n        this.logger.tracePii(`Item key: ${key}`);\r\n\r\n        // read cache\r\n        const cache = this.getCache();\r\n        return cache[key];\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key-value\r\n     * @param key - lookup key for the cache entry\r\n     * @param value - value of the cache entry\r\n     */\r\n    setItem(key: string, value: ValidCacheType): void {\r\n        this.logger.tracePii(`Item key: ${key}`);\r\n\r\n        // read cache\r\n        const cache = this.getCache();\r\n        cache[key] = value;\r\n\r\n        // write to cache\r\n        this.setCache(cache);\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity\r\n     * @param accountKey - lookup key to fetch cache type AccountEntity\r\n     */\r\n    getAccount(accountKey: string): AccountEntity | null {\r\n        const account = this.getItem(accountKey) as AccountEntity;\r\n        if (AccountEntity.isAccountEntity(account)) {\r\n            return account;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set account entity\r\n     * @param account - cache value to be set of type AccountEntity\r\n     */\r\n    setAccount(account: AccountEntity): void {\r\n        const accountKey = account.generateAccountKey();\r\n        this.setItem(accountKey, account);\r\n    }\r\n\r\n    /**\r\n     * fetch the idToken credential\r\n     * @param idTokenKey - lookup key to fetch cache type IdTokenEntity\r\n     */\r\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\r\n        const idToken = this.getItem(idTokenKey) as IdTokenEntity;\r\n        if (IdTokenEntity.isIdTokenEntity(idToken)) {\r\n            return idToken;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set idToken credential\r\n     * @param idToken - cache value to be set of type IdTokenEntity\r\n     */\r\n    setIdTokenCredential(idToken: IdTokenEntity): void {\r\n        const idTokenKey = idToken.generateCredentialKey();\r\n        this.setItem(idTokenKey, idToken);\r\n    }\r\n\r\n    /**\r\n     * fetch the accessToken credential\r\n     * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity\r\n     */\r\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\r\n        const accessToken = this.getItem(accessTokenKey) as AccessTokenEntity;\r\n        if (AccessTokenEntity.isAccessTokenEntity(accessToken)) {\r\n            return accessToken;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set accessToken credential\r\n     * @param accessToken -  cache value to be set of type AccessTokenEntity\r\n     */\r\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\r\n        const accessTokenKey = accessToken.generateCredentialKey();\r\n        this.setItem(accessTokenKey, accessToken);\r\n    }\r\n\r\n    /**\r\n     * fetch the refreshToken credential\r\n     * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity\r\n     */\r\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\r\n        const refreshToken = this.getItem(refreshTokenKey) as RefreshTokenEntity;\r\n        if (RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {\r\n            return refreshToken as RefreshTokenEntity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set refreshToken credential\r\n     * @param refreshToken - cache value to be set of type RefreshTokenEntity\r\n     */\r\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\r\n        const refreshTokenKey = refreshToken.generateCredentialKey();\r\n        this.setItem(refreshTokenKey, refreshToken);\r\n    }\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity\r\n     */\r\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\r\n        const appMetadata: AppMetadataEntity = this.getItem(appMetadataKey) as AppMetadataEntity;\r\n        if (AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {\r\n            return appMetadata;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata - cache value to be set of type AppMetadataEntity\r\n     */\r\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\r\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\r\n        this.setItem(appMetadataKey, appMetadata);\r\n    }\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity\r\n     */\r\n    getServerTelemetry(serverTelemetrykey: string): ServerTelemetryEntity | null {\r\n        const serverTelemetryEntity: ServerTelemetryEntity = this.getItem(serverTelemetrykey) as ServerTelemetryEntity;\r\n        if (serverTelemetryEntity && ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {\r\n            return serverTelemetryEntity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity\r\n     * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity\r\n     */\r\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\r\n        this.setItem(serverTelemetryKey, serverTelemetry);\r\n    }\r\n\r\n    /**\r\n     * fetch authority metadata entity from the platform cache\r\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\r\n     */\r\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\r\n        const authorityMetadataEntity: AuthorityMetadataEntity = this.getItem(key) as AuthorityMetadataEntity;\r\n        if (authorityMetadataEntity && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {\r\n            return authorityMetadataEntity;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all authority metadata keys\r\n     */\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        return this.getKeys().filter((key) => {\r\n            return this.isAuthorityMetadata(key);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * set authority metadata entity to the platform cache\r\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\r\n     * @param metadata - cache value to be set of type AuthorityMetadataEntity\r\n     */\r\n    setAuthorityMetadata(key: string, metadata: AuthorityMetadataEntity): void {\r\n        this.setItem(key, metadata);\r\n    }\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\r\n     */\r\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\r\n        const throttlingCache: ThrottlingEntity = this.getItem(throttlingCacheKey) as ThrottlingEntity;\r\n        if (throttlingCache && ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {\r\n            return throttlingCache;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\r\n     * @param throttlingCache - cache value to be set of type ThrottlingEntity\r\n     */\r\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\r\n        this.setItem(throttlingCacheKey, throttlingCache);\r\n    }\r\n\r\n    /**\r\n     * Removes the cache item from memory with the given key.\r\n     * @param key - lookup key to remove a cache entity\r\n     * @param inMemory - key value map of the cache\r\n     */\r\n    removeItem(key: string): boolean {\r\n        this.logger.tracePii(`Item key: ${key}`);\r\n\r\n        // read inMemoryCache\r\n        let result: boolean = false;\r\n        const cache = this.getCache();\r\n\r\n        if (!!cache[key]) {\r\n            delete cache[key];\r\n            result = true;\r\n        }\r\n\r\n        // write to the cache after removal\r\n        if (result) {\r\n            this.setCache(cache);\r\n            this.emitChange();\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key - look up key for a cache entity\r\n     */\r\n    containsKey(key: string): boolean {\r\n        return this.getKeys().includes(key);\r\n    }\r\n\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    getKeys(): string[] {\r\n        this.logger.trace(\"Retrieving all cache keys\");\r\n\r\n        // read cache\r\n        const cache = this.getCache();\r\n        return [ ...Object.keys(cache)];\r\n    }\r\n\r\n    /**\r\n     * Clears all cache entries created by MSAL (except tokens).\r\n     */\r\n    async clear(): Promise<void> {\r\n        this.logger.trace(\"Clearing cache entries created by MSAL\");\r\n\r\n        // read inMemoryCache\r\n        const cacheKeys = this.getKeys();\r\n\r\n        // delete each element\r\n        cacheKeys.forEach(key => {\r\n            this.removeItem(key);\r\n        });\r\n        this.emitChange();\r\n    }\r\n\r\n    /**\r\n     * Initialize in memory cache from an exisiting cache vault\r\n     * @param cache - blob formatted cache (JSON)\r\n     */\r\n    static generateInMemoryCache(cache: string): InMemoryCache {\r\n        return Deserializer.deserializeAllCache(\r\n            Deserializer.deserializeJSONBlob(cache)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * retrieves the final JSON\r\n     * @param inMemoryCache - itemised cache read from the JSON\r\n     */\r\n    static generateJsonCache(inMemoryCache: InMemoryCache): JsonCache {\r\n        return Serializer.serializeAllCache(inMemoryCache);\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { NodeStorage } from \"./NodeStorage\";\r\nimport { StringUtils, AccountEntity, AccountInfo, Logger, ISerializableTokenCache, ICachePlugin, TokenCacheContext } from \"@azure/msal-common\";\r\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedIdTokenEntity, SerializedAppMetadataEntity, CacheKVStore } from \"./serializer/SerializerTypes\";\r\nimport { Deserializer } from \"./serializer/Deserializer\";\r\nimport { Serializer } from \"./serializer/Serializer\";\r\nimport { ITokenCache } from \"./ITokenCache\";\r\n\r\nconst defaultSerializedCache: JsonCache = {\r\n    Account: {},\r\n    IdToken: {},\r\n    AccessToken: {},\r\n    RefreshToken: {},\r\n    AppMetadata: {},\r\n};\r\n\r\n/**\r\n * In-memory token cache manager\r\n * @public\r\n */\r\nexport class TokenCache implements ISerializableTokenCache, ITokenCache {\r\n\r\n    private storage: NodeStorage;\r\n    private cacheHasChanged: boolean;\r\n    private cacheSnapshot: string;\r\n    private readonly persistence: ICachePlugin;\r\n    private logger: Logger;\r\n\r\n    constructor(storage: NodeStorage, logger: Logger, cachePlugin?: ICachePlugin) {\r\n        this.cacheHasChanged = false;\r\n        this.storage = storage;\r\n        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\r\n        if (cachePlugin) {\r\n            this.persistence = cachePlugin;\r\n        }\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Set to true if cache state has changed since last time serialize or writeToPersistence was called\r\n     */\r\n    hasChanged(): boolean {\r\n        return this.cacheHasChanged;\r\n    }\r\n\r\n    /**\r\n     * Serializes in memory cache to JSON\r\n     */\r\n    serialize(): string {\r\n        this.logger.trace(\"Serializing in-memory cache\");\r\n        let finalState = Serializer.serializeAllCache(\r\n            this.storage.getInMemoryCache() as InMemoryCache\r\n        );\r\n\r\n        // if cacheSnapshot not null or empty, merge\r\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n            this.logger.trace(\"Reading cache snapshot from disk\");\r\n            finalState = this.mergeState(\r\n                JSON.parse(this.cacheSnapshot),\r\n                finalState\r\n            );\r\n        } else {\r\n            this.logger.trace(\"No cache snapshot to merge\");\r\n        }\r\n        this.cacheHasChanged = false;\r\n\r\n        return JSON.stringify(finalState);\r\n    }\r\n\r\n    /**\r\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\r\n     * @param cache - blob formatted cache\r\n     */\r\n    deserialize(cache: string): void {\r\n        this.logger.trace(\"Deserializing JSON to in-memory cache\");\r\n        this.cacheSnapshot = cache;\r\n\r\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\r\n            this.logger.trace(\"Reading cache snapshot from disk\");\r\n            const deserializedCache = Deserializer.deserializeAllCache(\r\n                this.overlayDefaults(JSON.parse(this.cacheSnapshot))\r\n            );\r\n            this.storage.setInMemoryCache(deserializedCache);\r\n        } else {\r\n            this.logger.trace(\"No cache snapshot to deserialize\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetches the cache key-value map\r\n     */\r\n    getKVStore(): CacheKVStore {\r\n        return this.storage.getCache();\r\n    }\r\n\r\n    /**\r\n     * API that retrieves all accounts currently in cache to the user\r\n     */\r\n    async getAllAccounts(): Promise<AccountInfo[]> {\r\n\r\n        this.logger.trace(\"getAllAccounts called\");\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistence) {\r\n                cacheContext = new TokenCacheContext(this, false);\r\n                await this.persistence.beforeCacheAccess(cacheContext);\r\n            }\r\n            return this.storage.getAllAccounts();\r\n        } finally {\r\n            if (this.persistence && cacheContext) {\r\n                await this.persistence.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching homeAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param homeAccountId - unique identifier for an account (uid.utid)\r\n     */\r\n    async getAccountByHomeId(homeAccountId: string): Promise<AccountInfo | null> {\r\n        const allAccounts = await this.getAllAccounts();\r\n        if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {\r\n            return allAccounts.filter(accountObj => accountObj.homeAccountId === homeAccountId)[0] || null;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching localAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)\r\n     */\r\n    async getAccountByLocalId(localAccountId: string): Promise<AccountInfo | null> {\r\n        const allAccounts = await this.getAllAccounts();\r\n        if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {\r\n            return allAccounts.filter(accountObj => accountObj.localAccountId === localAccountId)[0] || null;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * API to remove a specific account and the relevant data from cache\r\n     * @param account - AccountInfo passed by the user\r\n     */\r\n    async removeAccount(account: AccountInfo): Promise<void> {\r\n        this.logger.trace(\"removeAccount called\");\r\n        let cacheContext;\r\n        try {\r\n            if (this.persistence) {\r\n                cacheContext = new TokenCacheContext(this, true);\r\n                await this.persistence.beforeCacheAccess(cacheContext);\r\n            }\r\n            await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));\r\n        } finally {\r\n            if (this.persistence && cacheContext) {\r\n                await this.persistence.afterCacheAccess(cacheContext);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called when the cache has changed state.\r\n     */\r\n    private handleChangeEvent() {\r\n        this.cacheHasChanged = true;\r\n    }\r\n\r\n    /**\r\n     * Merge in memory cache with the cache snapshot.\r\n     * @param oldState - cache before changes\r\n     * @param currentState - current cache state in the library\r\n     */\r\n    private mergeState(oldState: JsonCache, currentState: JsonCache): JsonCache {\r\n        this.logger.trace(\"Merging in-memory cache with cache snapshot\");\r\n        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);\r\n        return this.mergeUpdates(stateAfterRemoval, currentState);\r\n    }\r\n\r\n    /**\r\n     * Deep update of oldState based on newState values\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\r\n    private mergeUpdates(oldState: object, newState: object): JsonCache {\r\n        Object.keys(newState).forEach((newKey: string) => {\r\n            const newValue = newState[newKey];\r\n\r\n            // if oldState does not contain value but newValue does, add it\r\n            if (!oldState.hasOwnProperty(newKey)) {\r\n                if (newValue !== null) {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            } else {\r\n                // both oldState and newState contain the key, do deep update\r\n                const newValueNotNull = newValue !== null;\r\n                const newValueIsObject = typeof newValue === \"object\";\r\n                const newValueIsNotArray = !Array.isArray(newValue);\r\n                const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== \"undefined\" && oldState[newKey] !== null;\r\n\r\n                if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {\r\n                    this.mergeUpdates(oldState[newKey], newValue);\r\n                } else {\r\n                    oldState[newKey] = newValue;\r\n                }\r\n            }\r\n        });\r\n\r\n        return oldState as JsonCache;\r\n    }\r\n\r\n    /**\r\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\r\n     * oldState that are not recognized, they are left untouched.\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\r\n    private mergeRemovals(oldState: JsonCache, newState: JsonCache): JsonCache {\r\n        this.logger.trace(\"Remove updated entries in cache\");\r\n        const accounts = oldState.Account ? this.mergeRemovalsDict<SerializedAccountEntity>(oldState.Account, newState.Account) : oldState.Account;\r\n        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict<SerializedAccessTokenEntity>(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;\r\n        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict<SerializedRefreshTokenEntity>(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;\r\n        const idTokens = oldState.IdToken ? this.mergeRemovalsDict<SerializedIdTokenEntity>(oldState.IdToken, newState.IdToken) : oldState.IdToken;\r\n        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict<SerializedAppMetadataEntity>(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;\r\n\r\n        return {\r\n            ...oldState,\r\n            Account: accounts,\r\n            AccessToken: accessTokens,\r\n            RefreshToken: refreshTokens,\r\n            IdToken: idTokens,\r\n            AppMetadata: appMetadata\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Helper to merge new cache with the old one\r\n     * @param oldState - cache before changes\r\n     * @param newState - updated cache\r\n     */\r\n    private mergeRemovalsDict<T>(oldState: Record<string, T>, newState?: Record<string, T>): Record<string, T> {\r\n        const finalState = { ...oldState };\r\n        Object.keys(oldState).forEach((oldKey) => {\r\n            if (!newState || !(newState.hasOwnProperty(oldKey))) {\r\n                delete finalState[oldKey];\r\n            }\r\n        });\r\n        return finalState;\r\n    }\r\n\r\n    /**\r\n     * Helper to overlay as a part of cache merge\r\n     * @param passedInCache - cache read from the blob\r\n     */\r\n    private overlayDefaults(passedInCache: JsonCache): JsonCache {\r\n        this.logger.trace(\"Overlaying input cache with the default cache\");\r\n        return {\r\n            Account: {\r\n                ...defaultSerializedCache.Account,\r\n                ...passedInCache.Account,\r\n            },\r\n            IdToken: {\r\n                ...defaultSerializedCache.IdToken,\r\n                ...passedInCache.IdToken,\r\n            },\r\n            AccessToken: {\r\n                ...defaultSerializedCache.AccessToken,\r\n                ...passedInCache.AccessToken,\r\n            },\r\n            RefreshToken: {\r\n                ...defaultSerializedCache.RefreshToken,\r\n                ...passedInCache.RefreshToken,\r\n            },\r\n            AppMetadata: {\r\n                ...defaultSerializedCache.AppMetadata,\r\n                ...passedInCache.AppMetadata,\r\n            },\r\n        };\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport {\r\n    AuthorizationCodeClient,\r\n    ClientConfiguration,\r\n    RefreshTokenClient,\r\n    AuthenticationResult,\r\n    Authority,\r\n    AuthorityFactory,\r\n    BaseAuthRequest,\r\n    SilentFlowClient,\r\n    Logger,\r\n    ServerTelemetryManager,\r\n    ServerTelemetryRequest,\r\n    CommonSilentFlowRequest,\r\n    CommonRefreshTokenRequest,\r\n    CommonAuthorizationCodeRequest,\r\n    CommonAuthorizationUrlRequest,\r\n    CommonUsernamePasswordRequest,\r\n    UsernamePasswordClient,\r\n    AuthenticationScheme,\r\n    ResponseMode,\r\n    AuthorityOptions,\r\n    OIDC_DEFAULT_SCOPES,\r\n    AzureRegionConfiguration,\r\n    AuthError\r\n} from \"@azure/msal-common\";\r\nimport { Configuration, buildAppConfiguration, NodeConfiguration } from \"../config/Configuration\";\r\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\r\nimport { NodeStorage } from \"../cache/NodeStorage\";\r\nimport { Constants as NodeConstants, ApiId } from \"../utils/Constants\";\r\nimport { TokenCache } from \"../cache/TokenCache\";\r\nimport { ClientAssertion } from \"./ClientAssertion\";\r\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\r\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\r\nimport { RefreshTokenRequest } from \"../request/RefreshTokenRequest\";\r\nimport { SilentFlowRequest } from \"../request/SilentFlowRequest\";\r\nimport { version, name } from \"../packageMetadata\";\r\nimport { UsernamePasswordRequest } from \"../request/UsernamePasswordRequest\";\r\n\r\n/**\r\n * Base abstract class for all ClientApplications - public and confidential\r\n * @public\r\n */\r\nexport abstract class ClientApplication {\r\n\r\n    private readonly cryptoProvider: CryptoProvider;\r\n    private tokenCache: TokenCache;\r\n\r\n    /**\r\n     * Platform storage object\r\n     */\r\n    protected storage: NodeStorage;\r\n    /**\r\n     * Logger object to log the application flow\r\n     */\r\n    protected logger: Logger;\r\n    /**\r\n     * Platform configuration initialized by the application\r\n     */\r\n    protected config: NodeConfiguration;\r\n    /**\r\n     * Client assertion passed by the user for confidential client flows\r\n     */\r\n    protected clientAssertion: ClientAssertion;\r\n    /**\r\n     * Client secret passed by the user for confidential client flows\r\n     */\r\n    protected clientSecret: string;\r\n\r\n    /**\r\n     * Constructor for the ClientApplication\r\n     */\r\n    protected constructor(configuration: Configuration) {\r\n        this.config = buildAppConfiguration(configuration);\r\n        this.cryptoProvider = new CryptoProvider();\r\n        this.logger = new Logger(this.config.system.loggerOptions, name, version);\r\n        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);\r\n        this.tokenCache = new TokenCache(\r\n            this.storage,\r\n            this.logger,\r\n            this.config.cache.cachePlugin\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates the URL of the authorization request, letting the user input credentials and consent to the\r\n     * application. The URL targets the /authorize endpoint of the authority configured in the\r\n     * application object.\r\n     *\r\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n     * `acquireTokenByCode(AuthorizationCodeRequest)`.\r\n     */\r\n    async getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string> {\r\n        this.logger.info(\"getAuthCodeUrl called\", request.correlationId);\r\n        const validRequest: CommonAuthorizationUrlRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request),\r\n            responseMode: request.responseMode || ResponseMode.QUERY,\r\n            authenticationScheme: AuthenticationScheme.BEARER\r\n        };\r\n\r\n        const authClientConfig = await this.buildOauthClientConfiguration(\r\n            validRequest.authority,\r\n            validRequest.correlationId\r\n        );\r\n        const authorizationCodeClient = new AuthorizationCodeClient(\r\n            authClientConfig\r\n        );\r\n        this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\r\n        return authorizationCodeClient.getAuthCodeUrl(validRequest);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\r\n     * Authorization Code flow.\r\n     *\r\n     * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0\r\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\r\n     * AuthorizationCodeRequest are the same.\r\n     */\r\n    async acquireTokenByCode(request: AuthorizationCodeRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByCode called\", request.correlationId);\r\n        const validRequest: CommonAuthorizationCodeRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request),\r\n            authenticationScheme: AuthenticationScheme.BEARER\r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);\r\n        try {\r\n            const authClientConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                validRequest.correlationId,\r\n                serverTelemetryManager\r\n            );\r\n            const authorizationCodeClient = new AuthorizationCodeClient(\r\n                authClientConfig\r\n            );\r\n            this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\r\n            return authorizationCodeClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\r\n     *\r\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is\r\n     * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will\r\n     * handle the caching and refreshing of tokens automatically.\r\n     */\r\n    async acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByRefreshToken called\", request.correlationId);\r\n        const validRequest: CommonRefreshTokenRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request),\r\n            authenticationScheme: AuthenticationScheme.BEARER\r\n        };\r\n\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);\r\n        try {\r\n            const refreshTokenClientConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                validRequest.correlationId,\r\n                serverTelemetryManager\r\n            );\r\n            const refreshTokenClient = new RefreshTokenClient(\r\n                refreshTokenClientConfig\r\n            );\r\n            this.logger.verbose(\"Refresh token client created\", validRequest.correlationId);\r\n            return refreshTokenClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Acquires a token silently when a user specifies the account the token is requested for.\r\n     *\r\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\r\n     * There is also an optional \"forceRefresh\" boolean the user can send to bypass the cache for access_token and id_token.\r\n     * In case the refresh_token is expired or not found, an error is thrown\r\n     * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).\r\n     */\r\n    async acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult | null> {\r\n        const validRequest: CommonSilentFlowRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request),\r\n            forceRefresh: request.forceRefresh || false\r\n        };\r\n\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);\r\n        try {\r\n            const silentFlowClientConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                validRequest.correlationId,\r\n                serverTelemetryManager\r\n            );\r\n            const silentFlowClient = new SilentFlowClient(\r\n                silentFlowClientConfig\r\n            );\r\n            this.logger.verbose(\"Silent flow client created\", validRequest.correlationId);\r\n            return silentFlowClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Acquires tokens with password grant by exchanging client applications username and password for credentials\r\n     *\r\n     * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.\r\n     * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4\r\n     * Microsoft's documentation and recommendations are at:\r\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword\r\n     *\r\n     * @param request - UsenamePasswordRequest\r\n     */\r\n    async acquireTokenByUsernamePassword(request: UsernamePasswordRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByUsernamePassword called\", request.correlationId);\r\n        const validRequest: CommonUsernamePasswordRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request)\r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);\r\n        try {\r\n            const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                validRequest.correlationId,\r\n                serverTelemetryManager\r\n            );\r\n            const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);\r\n            this.logger.verbose(\"Username password client created\", validRequest.correlationId);\r\n            return usernamePasswordClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the token cache for the application.\r\n     */\r\n    getTokenCache(): TokenCache {\r\n        this.logger.info(\"getTokenCache called\");\r\n        return this.tokenCache;\r\n    }\r\n\r\n    /**\r\n     * Returns the logger instance\r\n     */\r\n    getLogger(): Logger {\r\n        return this.logger;\r\n    }\r\n\r\n    /**\r\n     * Replaces the default logger set in configurations with new Logger with new configurations\r\n     * @param logger - Logger instance\r\n     */\r\n    setLogger(logger: Logger): void {\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Builds the common configuration to be passed to the common component based on the platform configurarion\r\n     * @param authority - user passed authority in configuration\r\n     * @param serverTelemetryManager - initializes servertelemetry if passed\r\n     */\r\n    protected async buildOauthClientConfiguration(authority: string, requestCorrelationId?: string, serverTelemetryManager?: ServerTelemetryManager, azureRegionConfiguration?: AzureRegionConfiguration): Promise<ClientConfiguration> {\r\n        this.logger.verbose(\"buildOauthClientConfiguration called\", requestCorrelationId);\r\n        // using null assertion operator as we ensure that all config values have default values in buildConfiguration()\r\n        this.logger.verbose(`building oauth client configuration with the authority: ${authority}`, requestCorrelationId);\r\n\r\n        const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId);\r\n\r\n        serverTelemetryManager?.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);\r\n\r\n        return {\r\n            authOptions: {\r\n                clientId: this.config.auth.clientId,\r\n                authority: discoveredAuthority,\r\n                clientCapabilities: this.config.auth.clientCapabilities\r\n            },\r\n            loggerOptions: {\r\n                logLevel: this.config.system.loggerOptions.logLevel,\r\n                loggerCallback: this.config.system.loggerOptions\r\n                    .loggerCallback,\r\n                piiLoggingEnabled: this.config.system.loggerOptions\r\n                    .piiLoggingEnabled,\r\n                correlationId: requestCorrelationId\r\n            },\r\n            cryptoInterface: this.cryptoProvider,\r\n            networkInterface: this.config.system.networkClient,\r\n            storageInterface: this.storage,\r\n            serverTelemetryManager: serverTelemetryManager,\r\n            clientCredentials: {\r\n                clientSecret: this.clientSecret,\r\n                clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : undefined,\r\n            },\r\n            libraryInfo: {\r\n                sku: NodeConstants.MSAL_SKU,\r\n                version: version,\r\n                cpu: process.arch || \"\",\r\n                os: process.platform || \"\",\r\n            },\r\n            persistencePlugin: this.config.cache.cachePlugin,\r\n            serializableCache: this.tokenCache,\r\n        };\r\n    }\r\n\r\n    private getClientAssertion(authority: Authority): { assertion: string, assertionType: string } {\r\n        return {\r\n            assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),\r\n            assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Generates a request with the default scopes & generates a correlationId.\r\n     * @param authRequest - BaseAuthRequest for initialization\r\n     */\r\n    protected initializeBaseRequest(authRequest: Partial<BaseAuthRequest>): BaseAuthRequest {\r\n        this.logger.verbose(\"initializeRequestScopes called\", authRequest.correlationId);\r\n        // Default authenticationScheme to Bearer, log that POP isn't supported yet\r\n        if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {\r\n            this.logger.verbose(\"Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request\", authRequest.correlationId);\r\n        }\r\n\r\n        authRequest.authenticationScheme = AuthenticationScheme.BEARER;\r\n\r\n        return {\r\n            ...authRequest,\r\n            scopes: [...((authRequest && authRequest.scopes) || []), ...OIDC_DEFAULT_SCOPES],\r\n            correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),\r\n            authority: authRequest.authority || this.config.auth.authority\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Initializes the server telemetry payload\r\n     * @param apiId - Id for a specific request\r\n     * @param correlationId - GUID\r\n     * @param forceRefresh - boolean to indicate network call\r\n     */\r\n    protected initializeServerTelemetryManager(apiId: number, correlationId: string, forceRefresh?: boolean): ServerTelemetryManager {\r\n        const telemetryPayload: ServerTelemetryRequest = {\r\n            clientId: this.config.auth.clientId,\r\n            correlationId: correlationId,\r\n            apiId: apiId,\r\n            forceRefresh: forceRefresh || false\r\n        };\r\n\r\n        return new ServerTelemetryManager(telemetryPayload, this.storage);\r\n    }\r\n\r\n    /**\r\n     * Create authority instance. If authority not passed in request, default to authority set on the application\r\n     * object. If no authority set in application object, then default to common authority.\r\n     * @param authorityString - authority from user configuration\r\n     */\r\n    private async createAuthority(authorityString: string, azureRegionConfiguration?: AzureRegionConfiguration, requestCorrelationId?: string): Promise<Authority> {\r\n        this.logger.verbose(\"createAuthority called\", requestCorrelationId);\r\n        const authorityOptions: AuthorityOptions = {\r\n            protocolMode: this.config.auth.protocolMode,\r\n            knownAuthorities: this.config.auth.knownAuthorities,\r\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\r\n            authorityMetadata: this.config.auth.authorityMetadata,\r\n            azureRegionConfiguration\r\n        };\r\n        return await AuthorityFactory.createDiscoveredInstance(authorityString, this.config.system.networkClient, this.storage, authorityOptions);\r\n    }\r\n}\r\n","/* eslint-disable header/header */\r\nexport const name = \"@azure/msal-node\";\r\nexport const version = \"1.3.2\";\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { sign } from \"jsonwebtoken\";\r\nimport { TimeUtils, ClientAuthError } from \"@azure/msal-common\";\r\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\r\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\r\nimport { JwtConstants } from \"../utils/Constants\";\r\n\r\n/**\r\n * Client assertion of type jwt-bearer used in confidential client flows\r\n * @public\r\n */\r\nexport class ClientAssertion {\r\n\r\n    private jwt: string;\r\n    private privateKey: string;\r\n    private thumbprint: string;\r\n    private expirationTime: number;\r\n    private issuer: string;\r\n    private jwtAudience: string;\r\n    private publicCertificate: Array<string>;\r\n\r\n    /**\r\n     * Initialize the ClientAssertion class from the clientAssertion passed by the user\r\n     * @param assertion - refer https://tools.ietf.org/html/rfc7521\r\n     */\r\n    public static fromAssertion(assertion: string): ClientAssertion {\r\n        const clientAssertion = new ClientAssertion();\r\n        clientAssertion.jwt = assertion;\r\n        return clientAssertion;\r\n    }\r\n\r\n    /**\r\n     * Initialize the ClientAssertion class from the certificate passed by the user\r\n     * @param thumbprint - identifier of a certificate\r\n     * @param privateKey - secret key\r\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\r\n     */\r\n    public static fromCertificate(thumbprint: string, privateKey: string, publicCertificate?: string): ClientAssertion {\r\n        const clientAssertion = new ClientAssertion();\r\n        clientAssertion.privateKey = privateKey;\r\n        clientAssertion.thumbprint = thumbprint;\r\n        if (publicCertificate) {\r\n            clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);\r\n        }\r\n        return clientAssertion;\r\n    }\r\n\r\n    /**\r\n     * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is\r\n     * @param cryptoProvider - library's crypto helper\r\n     * @param issuer - iss claim\r\n     * @param jwtAudience - aud claim\r\n     */\r\n    public getJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\r\n        // if assertion was created from certificate, check if jwt is expired and create new one.\r\n        if (this.privateKey && this.thumbprint) {\r\n\r\n            if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {\r\n                return this.jwt;\r\n            }\r\n\r\n            return this.createJwt(cryptoProvider, issuer, jwtAudience);\r\n        }\r\n\r\n        /*\r\n         * if assertion was created by caller, then we just append it. It is up to the caller to\r\n         * ensure that it contains necessary claims and that it is not expired.\r\n         */\r\n        if (this.jwt) {\r\n            return this.jwt;\r\n        }\r\n\r\n        throw ClientAuthError.createInvalidAssertionError();\r\n    }\r\n\r\n    /**\r\n     * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3\r\n     */\r\n    private createJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\r\n\r\n        this.issuer = issuer;\r\n        this.jwtAudience = jwtAudience;\r\n        const issuedAt = TimeUtils.nowSeconds();\r\n        this.expirationTime = issuedAt + 600;\r\n\r\n        const header = {\r\n            [JwtConstants.ALGORITHM]: JwtConstants.RSA_256,\r\n            [JwtConstants.X5T]: EncodingUtils.base64EncodeUrl(this.thumbprint, \"hex\")\r\n        };\r\n\r\n        if (this.publicCertificate) {\r\n            Object.assign(header, {\r\n                [JwtConstants.X5C]: this.publicCertificate\r\n            });\r\n        }\r\n\r\n        const payload = {\r\n            [JwtConstants.AUDIENCE]: this.jwtAudience,\r\n            [JwtConstants.EXPIRATION_TIME]: this.expirationTime,\r\n            [JwtConstants.ISSUER]: this.issuer,\r\n            [JwtConstants.SUBJECT]: this.issuer,\r\n            [JwtConstants.NOT_BEFORE]: issuedAt,\r\n            [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()\r\n        };\r\n\r\n        this.jwt = sign(payload, this.privateKey, { header: header });\r\n        return this.jwt;\r\n    }\r\n\r\n    /**\r\n     * Utility API to check expiration\r\n     */\r\n    private isExpired(): boolean {\r\n        return this.expirationTime < TimeUtils.nowSeconds();\r\n    }\r\n\r\n    /**\r\n     * Extracts the raw certs from a given certificate string and returns them in an array.\r\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\r\n     */\r\n    public static parseCertificate(publicCertificate: string): Array<string> {\r\n        /**\r\n         * This is regex to identify the certs in a given certificate string.\r\n         * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.\r\n         * The information in parens \"(.+?)\" is the capture group to represent the cert we want isolated.\r\n         * \".\" means any string character, \"+\" means match 1 or more times, and \"?\" means the shortest match.\r\n         * The \"g\" at the end of the regex means search the string globally, and the \"s\" enables the \".\" to match newlines.\r\n         */\r\n        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\\n(.+?)\\n-----END CERTIFICATE-----/gs;\r\n        const certs: string[] = [];\r\n\r\n        let matches;\r\n        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {\r\n            // matches[1] represents the first parens capture group in the regex.\r\n            certs.push(matches[1].replace(/\\n/, \"\"));\r\n        }\r\n\r\n        return certs;\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ClientApplication } from \"./ClientApplication\";\r\nimport { Configuration } from \"../config/Configuration\";\r\nimport { ClientAssertion } from \"./ClientAssertion\";\r\nimport { ApiId , REGION_ENVIRONMENT_VARIABLE } from \"../utils/Constants\";\r\nimport {\r\n    ClientCredentialClient,\r\n    OnBehalfOfClient,\r\n    CommonClientCredentialRequest,\r\n    CommonOnBehalfOfRequest,\r\n    AuthenticationResult,\r\n    StringUtils,\r\n    ClientAuthError,\r\n    AzureRegionConfiguration,\r\n    AuthError\r\n} from \"@azure/msal-common\";\r\nimport { IConfidentialClientApplication } from \"./IConfidentialClientApplication\";\r\nimport { OnBehalfOfRequest } from \"../request/OnBehalfOfRequest\";\r\nimport { ClientCredentialRequest } from \"../request/ClientCredentialRequest\";\r\n\r\n/**\r\n *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications\r\n *  will configure application secrets, client certificates/assertions as applicable\r\n * @public\r\n */\r\nexport class ConfidentialClientApplication extends ClientApplication implements IConfidentialClientApplication{\r\n\r\n    /**\r\n     * Constructor for the ConfidentialClientApplication\r\n     *\r\n     * Required attributes in the Configuration object are:\r\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal\r\n     * - authority: the authority URL for your application.\r\n     * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.\r\n     *\r\n     * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\r\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n     *\r\n     * In Azure B2C, authority is of the form https://\\{instance\\}/tfp/\\{tenant\\}/\\{policyName\\}/\r\n     * Full B2C functionality will be available in this library in future versions.\r\n     *\r\n     * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance\r\n     */\r\n    constructor(configuration: Configuration) {\r\n        super(configuration);\r\n        this.setClientCredential(this.config);\r\n    }\r\n\r\n    /**\r\n     * Acquires tokens from the authority for the application (not for an end user).\r\n     */\r\n    public async acquireTokenByClientCredential(request: ClientCredentialRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByClientCredential called\", request.correlationId);\r\n        const validRequest: CommonClientCredentialRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request)\r\n        };\r\n        const azureRegionConfiguration: AzureRegionConfiguration = {\r\n            azureRegion: validRequest.azureRegion,\r\n            environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE] \r\n        };\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);\r\n        try {\r\n            const clientCredentialConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                validRequest.correlationId,\r\n                serverTelemetryManager,\r\n                azureRegionConfiguration,\r\n            );\r\n            const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig);\r\n            this.logger.verbose(\"Client credential client created\", validRequest.correlationId);\r\n            return clientCredentialClient.acquireToken(validRequest);\r\n        } catch(e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Acquires tokens from the authority for the application.\r\n     *\r\n     * Used in scenarios where the current app is a middle-tier service which was called with a token\r\n     * representing an end user. The current app can use the token (oboAssertion) to request another\r\n     * token to access downstream web API, on behalf of that user.\r\n     *\r\n     * The current middle-tier app has no user interaction to obtain consent.\r\n     * See how to gain consent upfront for your middle-tier app from this article.\r\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application\r\n     */\r\n    public async acquireTokenOnBehalfOf(request: OnBehalfOfRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenOnBehalfOf called\", request.correlationId);\r\n        const validRequest: CommonOnBehalfOfRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request)\r\n        };\r\n        try {\r\n            const clientCredentialConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                validRequest.correlationId\r\n            );\r\n            const oboClient = new OnBehalfOfClient(clientCredentialConfig);\r\n            this.logger.verbose(\"On behalf of client created\", validRequest.correlationId);\r\n            return oboClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    private setClientCredential(configuration: Configuration): void {\r\n\r\n        const clientSecretNotEmpty = !StringUtils.isEmpty(configuration.auth.clientSecret);\r\n        const clientAssertionNotEmpty = !StringUtils.isEmpty(configuration.auth.clientAssertion);\r\n        const certificate = configuration.auth.clientCertificate || {\r\n            thumbprint: \"\",\r\n            privateKey: \"\"\r\n        };\r\n        const certificateNotEmpty = !StringUtils.isEmpty(certificate.thumbprint) || !StringUtils.isEmpty(certificate.privateKey);\r\n\r\n        // Check that at most one credential is set on the application\r\n        if (\r\n            clientSecretNotEmpty && clientAssertionNotEmpty ||\r\n            clientAssertionNotEmpty && certificateNotEmpty ||\r\n            clientSecretNotEmpty && certificateNotEmpty) {\r\n            throw ClientAuthError.createInvalidCredentialError();\r\n        }\r\n\r\n        if (configuration.auth.clientSecret) {\r\n            this.clientSecret = configuration.auth.clientSecret;\r\n            return;\r\n        }\r\n\r\n        if (configuration.auth.clientAssertion) {\r\n            this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion);\r\n            return;\r\n        }\r\n\r\n        if (!certificateNotEmpty) {\r\n            throw ClientAuthError.createInvalidCredentialError();\r\n        } else {\r\n            this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, configuration.auth.clientCertificate?.x5c);\r\n        }\r\n    }\r\n}\r\n","/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ApiId } from \"../utils/Constants\";\r\nimport {\r\n    DeviceCodeClient,\r\n    AuthenticationResult,\r\n    CommonDeviceCodeRequest,\r\n    AuthError\r\n} from \"@azure/msal-common\";\r\nimport { Configuration } from \"../config/Configuration\";\r\nimport { ClientApplication } from \"./ClientApplication\";\r\nimport { IPublicClientApplication } from \"./IPublicClientApplication\";\r\nimport { DeviceCodeRequest } from \"../request/DeviceCodeRequest\";\r\n\r\n/**\r\n * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\r\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\r\n * @public\r\n */\r\nexport class PublicClientApplication extends ClientApplication implements IPublicClientApplication {\r\n    /**\r\n     * Important attributes in the Configuration object for auth are:\r\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.\r\n     * - authority: the authority URL for your application.\r\n     *\r\n     * AAD authorities are of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\r\n     * - If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * - If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n     * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n     * - To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n     *\r\n     * Azure B2C authorities are of the form https://\\{instance\\}/\\{tenant\\}/\\{policy\\}. Each policy is considered\r\n     * its own authority. You will have to set the all of the knownAuthorities at the time of the client application\r\n     * construction.\r\n     *\r\n     * ADFS authorities are of the form https://\\{instance\\}/adfs.\r\n     */\r\n    constructor(configuration: Configuration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Acquires a token from the authority using OAuth2.0 device code flow.\r\n     * This flow is designed for devices that do not have access to a browser or have input constraints.\r\n     * The authorization server issues a DeviceCode object with a verification code, an end-user code,\r\n     * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be\r\n     * instructed to use another device to navigate to the verification URI to input credentials.\r\n     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\r\n     * until the end-user completes input of credentials.\r\n     */\r\n    public async acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<AuthenticationResult | null> {\r\n        this.logger.info(\"acquireTokenByDeviceCode called\", request.correlationId);\r\n        const validRequest: CommonDeviceCodeRequest = Object.assign(request, this.initializeBaseRequest(request));\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);\r\n        try {\r\n            const deviceCodeConfig = await this.buildOauthClientConfiguration(\r\n                validRequest.authority,\r\n                validRequest.correlationId,\r\n                serverTelemetryManager\r\n            );\r\n            const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\r\n            this.logger.verbose(\"Device code client created\", validRequest.correlationId);\r\n            return deviceCodeClient.acquireToken(validRequest);\r\n        } catch (e) {\r\n            if (e instanceof AuthError) {\r\n                e.setCorrelationId(validRequest.correlationId);\r\n            }\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n    }\r\n}\r\n"],"names":["HttpMethod","CharSet","ApiId","HttpClient","url","options","request","method","GET","headers","validateStatus","response","axios","body","data","status","cancellationToken","POST","timeout","DEFAULT_AUTH_OPTIONS","clientId","authority","Constants","DEFAULT_AUTHORITY","clientSecret","clientAssertion","clientCertificate","thumbprint","privateKey","x5c","knownAuthorities","cloudDiscoveryMetadata","authorityMetadata","clientCapabilities","protocolMode","ProtocolMode","AAD","DEFAULT_CACHE_OPTIONS","DEFAULT_SYSTEM_OPTIONS","loggerOptions","loggerCallback","piiLoggingEnabled","logLevel","LogLevel","Info","networkClient","getNetworkClient","buildAppConfiguration","auth","cache","system","EncodingUtils","str","encoding","Buffer","from","toString","base64Encode","replace","base64Str","length","base64Decode","PkceGenerator","verifier","this","generateCodeVerifier","challenge","generateCodeChallengeFromVerifier","charArr","maxNumber","byte","crypto","randomBytes","push","join","base64EncodeUrl","codeVerifier","sha256","buffer","createHash","update","digest","CryptoProvider","constructor","pkceGenerator","createNewGuid","uuidv4","guid","test","generateGuid","input","generatePkceCodes","getPublicKeyThumbprint","Error","removeTokenBindingKey","clearKeystore","signJwt","Deserializer","jsonFile","StringUtils","isEmpty","JSON","parse","accounts","accountObjects","Object","keys","map","key","serializedAcc","mappedAcc","homeAccountId","home_account_id","environment","realm","localAccountId","local_account_id","username","authorityType","authority_type","name","clientInfo","client_info","lastModificationTime","last_modification_time","lastModificationApp","last_modification_app","account","AccountEntity","CacheManager","toObject","idTokens","idObjects","serializedIdT","mappedIdT","credentialType","credential_type","client_id","secret","idToken","IdTokenEntity","accessTokens","atObjects","serializedAT","mappedAT","target","cachedAt","cached_at","expiresOn","expires_on","extendedExpiresOn","extended_expires_on","refreshOn","refresh_on","keyId","key_id","tokenType","token_type","accessToken","AccessTokenEntity","refreshTokens","rtObjects","serializedRT","mappedRT","familyId","family_id","refreshToken","RefreshTokenEntity","appMetadata","appMetadataObjects","serializedAmdt","mappedAmd","amd","AppMetadataEntity","jsonCache","Account","deserializeAccounts","IdToken","deserializeIdTokens","AccessToken","deserializeAccessTokens","RefreshToken","deserializeRefreshTokens","AppMetadata","deserializeAppMetadata","Serializer","stringify","accCache","accountEntity","idTCache","idTEntity","atCache","atEntity","rtCache","rtEntity","amdtCache","amdtEntity","inMemCache","serializeAccounts","serializeIdTokens","serializeAccessTokens","serializeRefreshTokens","serializeAppMetadata","NodeStorage","logger","cryptoImpl","registerChangeEmitter","func","changeEmitters","emitChange","forEach","call","cacheToInMemoryCache","inMemoryCache","inMemoryCacheToCache","getCache","getInMemoryCache","trace","setInMemoryCache","setCache","getItem","tracePii","setItem","value","getAccount","accountKey","isAccountEntity","setAccount","generateAccountKey","getIdTokenCredential","idTokenKey","isIdTokenEntity","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","isAccessTokenEntity","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","isRefreshTokenEntity","setRefreshTokenCredential","getAppMetadata","appMetadataKey","isAppMetadataEntity","setAppMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetrykey","serverTelemetryEntity","ServerTelemetryEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetryKey","serverTelemetry","getAuthorityMetadata","authorityMetadataEntity","AuthorityMetadataEntity","isAuthorityMetadataEntity","getAuthorityMetadataKeys","getKeys","filter","isAuthorityMetadata","setAuthorityMetadata","metadata","getThrottlingCache","throttlingCacheKey","throttlingCache","ThrottlingEntity","isThrottlingEntity","setThrottlingCache","removeItem","result","containsKey","includes","deserializeAllCache","deserializeJSONBlob","serializeAllCache","defaultSerializedCache","TokenCache","storage","cachePlugin","cacheHasChanged","handleChangeEvent","bind","persistence","hasChanged","serialize","finalState","cacheSnapshot","mergeState","deserialize","deserializedCache","overlayDefaults","getKVStore","cacheContext","TokenCacheContext","beforeCacheAccess","getAllAccounts","afterCacheAccess","allAccounts","accountObj","removeAccount","generateAccountCacheKey","oldState","currentState","stateAfterRemoval","mergeRemovals","mergeUpdates","newState","newKey","newValue","hasOwnProperty","newValueNotNull","newValueIsObject","newValueIsNotArray","Array","isArray","oldStateNotUndefinedOrNull","mergeRemovalsDict","oldKey","passedInCache","ClientApplication","configuration","config","cryptoProvider","Logger","tokenCache","info","correlationId","validRequest","initializeBaseRequest","responseMode","ResponseMode","QUERY","authenticationScheme","AuthenticationScheme","BEARER","authClientConfig","buildOauthClientConfiguration","authorizationCodeClient","AuthorizationCodeClient","verbose","getAuthCodeUrl","serverTelemetryManager","initializeServerTelemetryManager","acquireTokenByCode","acquireToken","e","AuthError","setCorrelationId","cacheFailedRequest","acquireTokenByRefreshToken","refreshTokenClientConfig","refreshTokenClient","RefreshTokenClient","forceRefresh","acquireTokenSilent","silentFlowClientConfig","silentFlowClient","SilentFlowClient","acquireTokenByUsernamePassword","usernamePasswordClientConfig","usernamePasswordClient","UsernamePasswordClient","getTokenCache","getLogger","setLogger","requestCorrelationId","azureRegionConfiguration","discoveredAuthority","createAuthority","updateRegionDiscoveryMetadata","regionDiscoveryMetadata","authOptions","cryptoInterface","networkInterface","storageInterface","clientCredentials","getClientAssertion","undefined","libraryInfo","sku","version","cpu","process","arch","os","platform","persistencePlugin","serializableCache","assertion","getJwt","tokenEndpoint","assertionType","authRequest","POP","scopes","OIDC_DEFAULT_SCOPES","apiId","ServerTelemetryManager","authorityString","authorityOptions","AuthorityFactory","createDiscoveredInstance","ClientAssertion","jwt","publicCertificate","parseCertificate","issuer","jwtAudience","isExpired","createJwt","ClientAuthError","createInvalidAssertionError","issuedAt","TimeUtils","nowSeconds","expirationTime","header","assign","payload","sign","regexToFindCerts","certs","matches","exec","setClientCredential","azureRegion","environmentRegion","env","acquireTokenByClientCredential","skipCache","clientCredentialConfig","clientCredentialClient","ClientCredentialClient","oboClient","OnBehalfOfClient","clientSecretNotEmpty","clientAssertionNotEmpty","certificate","certificateNotEmpty","createInvalidCredentialError","fromAssertion","fromCertificate","_configuration$auth$c","acquireTokenByDeviceCode","deviceCodeConfig","deviceCodeClient","DeviceCodeClient"],"mappings":"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"}