{"version":3,"file":"msal-node.cjs.production.min.js","sources":["../src/utils/Constants.ts","../src/network/HttpClient.ts","../src/config/Configuration.ts","../src/utils/NetworkUtils.ts","../src/crypto/GuidGenerator.ts","../src/utils/EncodingUtils.ts","../src/crypto/HashUtils.ts","../src/crypto/PkceGenerator.ts","../src/crypto/CryptoProvider.ts","../src/cache/serializer/Deserializer.ts","../src/cache/serializer/Serializer.ts","../src/cache/NodeStorage.ts","../src/cache/TokenCache.ts","../src/client/ClientApplication.ts","../src/packageMetadata.ts","../src/client/ClientAssertion.ts","../src/client/ConfidentialClientApplication.ts","../src/cache/distributed/DistributedCachePlugin.ts","../src/client/PublicClientApplication.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * http methods\n */\nexport enum HttpMethod {\n    GET = \"get\",\n    POST = \"post\",\n}\n\n/**\n * Constants used for region discovery\n */\nexport const REGION_ENVIRONMENT_VARIABLE = \"REGION_NAME\";\n\n/**\n * Constant used for PKCE\n */\nexport const RANDOM_OCTET_SIZE = 32;\n\n/**\n * Constants used in PKCE\n */\nexport const Hash = {\n    SHA256: \"sha256\",\n};\n\n/**\n * Constants for encoding schemes\n */\nexport const CharSet = {\n    CV_CHARSET:\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\",\n};\n\n/**\n * Cache Constants\n */\nexport const CACHE = {\n    FILE_CACHE: \"fileCache\",\n    EXTENSION_LIB: \"extenstion_library\",\n};\n\n/**\n * Constants\n */\nexport const Constants = {\n    MSAL_SKU: \"msal.js.node\",\n    JWT_BEARER_ASSERTION_TYPE: \"urn:ietf:params:oauth:client-assertion-type:jwt-bearer\",\n    AUTHORIZATION_PENDING: \"authorization_pending\",\n};\n\n/**\n * API Codes for Telemetry purposes.\n * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs\n * 0-99 Silent Flow\n * 600-699 Device Code Flow\n * 800-899 Auth Code Flow\n */\nexport enum ApiId {\n    acquireTokenSilent = 62,\n    acquireTokenByUsernamePassword = 371,\n    acquireTokenByDeviceCode = 671,\n    acquireTokenByClientCredential = 771,\n    acquireTokenByCode = 871,\n    acquireTokenByRefreshToken = 872\n}\n\n/**\n * JWT  constants\n */\nexport const JwtConstants = {\n    ALGORITHM: \"alg\",\n    RSA_256: \"RS256\",\n    X5T: \"x5t\", \n    X5C: \"x5c\",\n    AUDIENCE: \"aud\",\n    EXPIRATION_TIME: \"exp\",\n    ISSUER: \"iss\",\n    SUBJECT: \"sub\",\n    NOT_BEFORE: \"nbf\",\n    JWT_ID: \"jti\",\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    INetworkModule,\n    NetworkRequestOptions,\n    NetworkResponse,\n} from \"@azure/msal-common\";\nimport { HttpMethod, Constants } from \"../utils/Constants\";\nimport http from \"http\";\nimport https from \"https\";\n\n/**\n * This class implements the API for network requests.\n */\nexport class HttpClient implements INetworkModule {\n\n    /**\n     * Http Get request\n     * @param url\n     * @param options\n     */\n    async sendGetRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions,\n    ): Promise<NetworkResponse<T>> {\n        if (options?.proxyUrl) {\n            return networkRequestViaProxy(url, HttpMethod.GET, options);\n        } else {\n            return networkRequestViaHttps(url, HttpMethod.GET, options);\n        }\n    }\n\n    /**\n     * Http Post request\n     * @param url\n     * @param options\n     */\n    async sendPostRequestAsync<T>(\n        url: string,\n        options?: NetworkRequestOptions,\n        cancellationToken?: number,\n    ): Promise<NetworkResponse<T>> {\n        if (options?.proxyUrl) {\n            return networkRequestViaProxy(url, HttpMethod.POST, options, cancellationToken);\n        } else {\n            return networkRequestViaHttps(url, HttpMethod.POST, options, cancellationToken);\n        }\n    }\n}\n\nconst networkRequestViaProxy = <T>(\n    url: string,\n    httpMethod: string,\n    options: NetworkRequestOptions,\n    timeout?: number,\n): Promise<NetworkResponse<T>> => {\n    const headers = options?.headers || {} as Record<string, string>;\n    const proxyUrl = new URL(options?.proxyUrl || \"\");\n    const destinationUrl = new URL(url);\n\n    // \"method: connect\" must be used to establish a connection to the proxy\n    const tunnelRequestOptions: https.RequestOptions = {\n        host: proxyUrl.hostname,\n        port: proxyUrl.port,\n        method: \"CONNECT\",\n        path: destinationUrl.hostname,\n        headers: headers,\n    };\n\n    if (timeout) {\n        tunnelRequestOptions.timeout = timeout;\n    }\n\n    // compose a request string for the socket\n    let postRequestStringContent: string = \"\";\n    if (httpMethod === HttpMethod.POST) {\n        const body = options?.body || \"\";\n        postRequestStringContent =\n            \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n            `Content-Length: ${body.length}\\r\\n` +\n            `\\r\\n${body}`;\n    }\n    const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\\r\\n` +\n        `Host: ${destinationUrl.host}\\r\\n` +\n        \"Connection: close\\r\\n\" +\n        postRequestStringContent +\n        \"\\r\\n\";\n\n    return new Promise<NetworkResponse<T>>(((resolve, reject) => {\n        const request = http.request(tunnelRequestOptions);\n\n        if (tunnelRequestOptions.timeout) {\n            request.on(\"timeout\", () => {\n                request.destroy();\n                reject(new Error(\"Request time out\"));\n            });\n        }\n\n        request.end();\n\n        // establish connection to the proxy\n        request.on(\"connect\", (response, socket) => {\n            const statusCode = response?.statusCode || 500;\n            if (statusCode < 200 || statusCode > 299) {\n                request.destroy();\n                socket.destroy();\n                reject(new Error(`HTTP status code ${statusCode}`));\n            }\n\n            if (tunnelRequestOptions.timeout) {\n                socket.setTimeout(tunnelRequestOptions.timeout);\n                socket.on(\"timeout\", () => {\n                    request.destroy();\n                    socket.destroy();\n                    reject(new Error(\"Request time out\"));\n                });\n            }\n\n            // make a request over an HTTP tunnel\n            socket.write(outgoingRequestString);\n\n            const data: Buffer[] = [];\n            socket.on(\"data\", (chunk) => {\n                data.push(chunk);\n            });\n\n            socket.on(\"end\", () => {\n                // combine all received buffer streams into one buffer, and then into a string\n                const dataString = Buffer.concat([...data]).toString();\n\n                // separate each line into it's own entry in an arry\n                const dataStringArray = dataString.split(\"\\r\\n\");\n                // the first entry will contain the statusCode\n                const statusCode = parseInt(dataStringArray[0].split(\" \")[1]);\n                // the last entry will contain the body\n                const body = dataStringArray[dataStringArray.length - 1];\n\n                // everything in between the first and last entries are the headers\n                const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);\n\n                // build an object out of all the headers\n                const entries = new Map();\n                headersArray.forEach((header) => {\n                    /**\n                     * the header might look like \"Content-Length: 1531\", but that is just a string\n                     * it needs to be converted to a key/value pair\n                     * split the string at the first instance of \":\"\n                     * there may be more than one \":\" if the value of the header is supposed to be a JSON object\n                     */\n                    const headerKeyValue = header.split(new RegExp(/:\\s(.*)/s));\n                    const headerKey = headerKeyValue[0];\n                    let headerValue = headerKeyValue[1];\n\n                    // check if the value of the header is supposed to be a JSON object\n                    try {\n                        const object = JSON.parse(headerValue);\n\n                        // if it is, then convert it from a string to a JSON object\n                        if (object && (typeof object === \"object\")) {\n                            headerValue = object;\n                        }\n                    } catch (e) {\n                        // otherwise, leave it as a string\n                    }\n\n                    entries.set(headerKey, headerValue);\n                });\n                const headers = Object.fromEntries(entries);\n\n                const networkResponse: NetworkResponse<T> = {\n                    headers: headers as Record<string, string>,\n                    body: JSON.parse(body) as T,\n                    status: statusCode as number,\n                };\n\n                if ((statusCode < 200 || statusCode > 299) &&\n                    // do not destroy the request for the device code flow\n                    networkResponse.body[\"error\"] !== Constants.AUTHORIZATION_PENDING) {\n                    request.destroy();\n                    socket.destroy();\n                    reject(new Error(`HTTP status code ${statusCode}`));\n                }\n\n                resolve(networkResponse);\n            });\n\n            socket.on(\"error\", (chunk) => {\n                request.destroy();\n                socket.destroy();\n                reject(new Error(chunk.toString()));\n            });\n        });\n\n        request.on(\"error\", (chunk) => {\n            request.destroy();\n            reject(new Error(chunk.toString()));\n        });\n    }));\n};\n\nconst networkRequestViaHttps = <T>(\n    url: string,\n    httpMethod: string,\n    options?: NetworkRequestOptions,\n    timeout?: number,\n): Promise<NetworkResponse<T>> => {\n    const isPostRequest = httpMethod === HttpMethod.POST;\n    const body: string = options?.body || \"\";\n\n    const emptyHeaders: Record<string, string> = {};\n    const customOptions: https.RequestOptions = {\n        method: httpMethod,\n        headers: options?.headers || emptyHeaders,\n    };\n\n    if (timeout) {\n        customOptions.timeout = timeout;\n    }\n\n    if (isPostRequest) {\n        // needed for post request to work\n        customOptions.headers = {\n            ...customOptions.headers,\n            \"Content-Length\": body.length,\n        };\n    }\n\n    return new Promise<NetworkResponse<T>>((resolve, reject) => {\n        const request = https.request(url, customOptions);\n\n        if (timeout) {\n            request.on(\"timeout\", () => {\n                request.destroy();\n                reject(new Error(\"Request time out\"));\n            });\n        }\n\n        if (isPostRequest) {\n            request.write(body);\n        }\n\n        request.end();\n\n        request.on(\"response\", (response) => {\n            const headers = response.headers;\n            const statusCode = response.statusCode as number;\n\n            const data: Buffer[] = [];\n            response.on(\"data\", (chunk) => {\n                data.push(chunk);\n            });\n\n            response.on(\"end\", () => {\n                // combine all received buffer streams into one buffer, and then into a string\n                const body = Buffer.concat([...data]).toString();\n\n                const networkResponse: NetworkResponse<T> = {\n                    headers: headers as Record<string, string>,\n                    body: JSON.parse(body) as T,\n                    status: statusCode,\n                };\n\n                if ((statusCode < 200 || statusCode > 299) &&\n                    // do not destroy the request for the device code flow\n                    networkResponse.body[\"error\"] !== Constants.AUTHORIZATION_PENDING) {\n                    request.destroy();\n                    reject(new Error(`HTTP status code ${statusCode}`));\n                }\n\n                resolve(networkResponse);\n            });\n        });\n\n        request.on(\"error\", (chunk) => {\n            request.destroy();\n            reject(new Error(chunk.toString()));\n        });\n    });\n};\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    LoggerOptions,\n    INetworkModule,\n    LogLevel,\n    ProtocolMode,\n    ICachePlugin,\n    Constants,\n    AzureCloudInstance,\n    AzureCloudOptions,\n    ApplicationTelemetry\n} from \"@azure/msal-common\";\nimport { NetworkUtils } from \"../utils/NetworkUtils\";\n\n/**\n * - clientId               - Client id of the application.\n * - authority              - Url of the authority. If no value is set, defaults to https://login.microsoftonline.com/common.\n * - knownAuthorities       - Needed for Azure B2C and ADFS. All authorities that will be used in the client application. Only the host of the authority should be passed in.\n * - clientSecret           - Secret string that the application uses when requesting a token. Only used in confidential client applications. Can be created in the Azure app registration portal.\n * - clientAssertion        - Assertion string that the application uses when requesting a token. Only used in confidential client applications. Assertion should be of type urn:ietf:params:oauth:client-assertion-type:jwt-bearer.\n * - clientCertificate      - Certificate that the application uses when requesting a token. Only used in confidential client applications. Requires hex encoded X.509 SHA-1 thumbprint of the certificiate, and the PEM encoded private key (string should contain -----BEGIN PRIVATE KEY----- ... -----END PRIVATE KEY----- )\n * - protocolMode           - Enum that represents the protocol that msal follows. Used for configuring proper endpoints.\n * - skipAuthorityMetadataCache - A flag to choose whether to use or not use the local metadata cache during authority initialization. Defaults to false.\n * @public\n */\nexport type NodeAuthOptions = {\n    clientId: string;\n    authority?: string;\n    clientSecret?: string;\n    clientAssertion?: string;\n    clientCertificate?: {\n        thumbprint: string,\n        privateKey: string,\n        x5c?: string\n    };\n    knownAuthorities?: Array<string>;\n    cloudDiscoveryMetadata?: string;\n    authorityMetadata?: string;\n    clientCapabilities?: Array<string>;\n    protocolMode?: ProtocolMode;\n    azureCloudOptions?: AzureCloudOptions;\n    skipAuthorityMetadataCache?: boolean;\n};\n\n/**\n * Use this to configure the below cache configuration options:\n *\n * - cachePlugin   - Plugin for reading and writing token cache to disk.\n * @public\n */\nexport type CacheOptions = {\n    cachePlugin?: ICachePlugin;\n};\n\n/**\n * Type for configuring logger and http client options\n *\n * - logger                       - Used to initialize the Logger object; TODO: Expand on logger details or link to the documentation on logger\n * - networkClient                - Http client used for all http get and post calls. Defaults to using MSAL's default http client.\n * @public\n */\nexport type NodeSystemOptions = {\n    loggerOptions?: LoggerOptions;\n    networkClient?: INetworkModule;\n    proxyUrl?: string;\n};\n\nexport type NodeTelemetryOptions = {\n    application?: ApplicationTelemetry;\n};\n\n/**\n * Use the configuration object to configure MSAL and initialize the client application object\n *\n * - auth: this is where you configure auth elements like clientID, authority used for authenticating against the Microsoft Identity Platform\n * - cache: this is where you configure cache location\n * - system: this is where you can configure the network client, logger\n * @public\n */\nexport type Configuration = {\n    auth: NodeAuthOptions;\n    cache?: CacheOptions;\n    system?: NodeSystemOptions;\n    telemetry?: NodeTelemetryOptions;\n};\n\nconst DEFAULT_AUTH_OPTIONS: Required<NodeAuthOptions> = {\n    clientId: Constants.EMPTY_STRING,\n    authority: Constants.DEFAULT_AUTHORITY,\n    clientSecret: Constants.EMPTY_STRING,\n    clientAssertion: Constants.EMPTY_STRING,\n    clientCertificate: {\n        thumbprint: Constants.EMPTY_STRING,\n        privateKey: Constants.EMPTY_STRING,\n        x5c: Constants.EMPTY_STRING\n    },\n    knownAuthorities: [],\n    cloudDiscoveryMetadata: Constants.EMPTY_STRING,\n    authorityMetadata: Constants.EMPTY_STRING,\n    clientCapabilities: [],\n    protocolMode: ProtocolMode.AAD,\n    azureCloudOptions: {\n        azureCloudInstance: AzureCloudInstance.None,\n        tenant: Constants.EMPTY_STRING\n    },\n    skipAuthorityMetadataCache: false,\n};\n\nconst DEFAULT_CACHE_OPTIONS: CacheOptions = {};\n\nconst DEFAULT_LOGGER_OPTIONS: LoggerOptions = {\n    loggerCallback: (): void => {\n        // allow users to not set logger call back\n    },\n    piiLoggingEnabled: false,\n    logLevel: LogLevel.Info,\n};\n\nconst DEFAULT_SYSTEM_OPTIONS: Required<NodeSystemOptions> = {\n    loggerOptions: DEFAULT_LOGGER_OPTIONS,\n    networkClient: NetworkUtils.getNetworkClient(),\n    proxyUrl: Constants.EMPTY_STRING,\n};\n\nconst DEFAULT_TELEMETRY_OPTIONS: Required<NodeTelemetryOptions> = {\n    application: {\n        appName: Constants.EMPTY_STRING,\n        appVersion: Constants.EMPTY_STRING\n    }\n};\n\nexport type NodeConfiguration = {\n    auth: Required<NodeAuthOptions>;\n    cache: CacheOptions;\n    system: Required<NodeSystemOptions>;\n    telemetry: Required<NodeTelemetryOptions>;\n};\n\n/**\n * Sets the default options when not explicitly configured from app developer\n *\n * @param auth - Authentication options\n * @param cache - Cache options\n * @param system - System options\n * @param telemetry - Telemetry options\n *\n * @returns Configuration\n * @public\n */\nexport function buildAppConfiguration({\n    auth,\n    cache,\n    system,\n    telemetry\n}: Configuration): NodeConfiguration {\n\n    return {\n        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },\n        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },\n        system: { ...DEFAULT_SYSTEM_OPTIONS, ...system },\n        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry }\n    };\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule } from \"@azure/msal-common\";\nimport { HttpClient } from \"../network/HttpClient\";\n\nexport class NetworkUtils {\n    /**\n     * Returns best compatible network client object.\n     */\n    static getNetworkClient(): INetworkModule {\n        return new HttpClient();\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { IGuidGenerator } from \"@azure/msal-common\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nexport class GuidGenerator implements IGuidGenerator {\n    /**\n     *\n     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.\n     * uuidv4 generates guids from cryprtographically-string random\n     */\n    generateGuid(): string {\n        return uuidv4();\n    }\n\n    /**\n     * verifies if a string is  GUID\n     * @param guid\n     */\n    isGuid(guid: string): boolean {\n        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n        return regexGuid.test(guid);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants } from \"@azure/msal-common\";\n\nexport class EncodingUtils {\n    /**\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\n     * 'base64': Base64 encoding.\n     *\n     * @param str text\n     */\n    static base64Encode(str: string, encoding?: BufferEncoding): string {\n        return Buffer.from(str, encoding).toString(\"base64\");\n    }\n\n    /**\n     * encode a URL\n     * @param str\n     */\n    static base64EncodeUrl(str: string, encoding?: BufferEncoding): string {\n        return EncodingUtils.base64Encode(str, encoding)\n            .replace(/=/g, Constants.EMPTY_STRING)\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\");\n    }\n\n    /**\n     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.\n     * 'base64': Base64 encoding.\n     *\n     * @param base64Str Base64 encoded text\n     */\n    static base64Decode(base64Str: string): string {\n        return Buffer.from(base64Str, \"base64\").toString(\"utf8\");\n    }\n\n    /**\n     * @param base64Str Base64 encoded Url\n     */\n    static base64DecodeUrl(base64Str: string): string {\n        let str = base64Str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n        while (str.length % 4) {\n            str += \"=\";\n        }\n        return EncodingUtils.base64Decode(str);\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Hash } from \"../utils/Constants\";\nimport crypto from \"crypto\";\n\nexport class HashUtils {\n    /**\n     * generate 'SHA256' hash\n     * @param buffer\n     */\n    sha256(buffer: string): Buffer {\n        return crypto\n            .createHash(Hash.SHA256)\n            .update(buffer)\n            .digest();\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants, PkceCodes } from \"@azure/msal-common\";\nimport { CharSet, RANDOM_OCTET_SIZE } from \"../utils/Constants\";\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\nimport { HashUtils } from \"./HashUtils\";\nimport crypto from \"crypto\";\n\n/**\n * https://tools.ietf.org/html/rfc7636#page-8\n */\nexport class PkceGenerator {\n    private hashUtils: HashUtils;\n\n    constructor() {\n        this.hashUtils = new HashUtils();\n    }\n    /**\n     * generates the codeVerfier and the challenge from the codeVerfier\n     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2\n     */\n    async generatePkceCodes(): Promise<PkceCodes> {\n        const verifier = this.generateCodeVerifier();\n        const challenge = this.generateCodeChallengeFromVerifier(verifier);\n        return { verifier, challenge };\n    }\n\n    /**\n     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1\n     */\n    private generateCodeVerifier(): string {\n        const charArr = [];\n        const maxNumber = 256 - (256 % CharSet.CV_CHARSET.length);\n        while (charArr.length <= RANDOM_OCTET_SIZE) {\n            const byte = crypto.randomBytes(1)[0];\n            if (byte >= maxNumber) {\n                /* \n                 * Ignore this number to maintain randomness.\n                 * Including it would result in an unequal distribution of characters after doing the modulo\n                 */\n                continue;\n            }\n            const index = byte % CharSet.CV_CHARSET.length;\n            charArr.push(CharSet.CV_CHARSET[index]);\n        }\n        const verifier: string = charArr.join(Constants.EMPTY_STRING);\n        return EncodingUtils.base64EncodeUrl(verifier);\n    }\n\n    /**\n     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2\n     * @param codeVerifier\n     */\n    private generateCodeChallengeFromVerifier(codeVerifier: string): string {\n        return EncodingUtils.base64EncodeUrl(\n            this.hashUtils.sha256(codeVerifier).toString(\"base64\"), \n            \"base64\" \n        );\n    }\n\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ICrypto, PkceCodes } from \"@azure/msal-common\";\nimport { GuidGenerator } from \"./GuidGenerator\";\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\nimport { PkceGenerator } from \"./PkceGenerator\";\nimport { HashUtils } from \"./HashUtils\";\n\n/**\n * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\n * @public\n */\nexport class CryptoProvider implements ICrypto {\n    private pkceGenerator: PkceGenerator;\n    private guidGenerator: GuidGenerator;\n    private hashUtils: HashUtils;\n\n    constructor() {\n        // Browser crypto needs to be validated first before any other classes can be set.\n        this.pkceGenerator = new PkceGenerator();\n        this.guidGenerator = new GuidGenerator();\n        this.hashUtils = new HashUtils();\n    }\n\n    /**\n     * Creates a new random GUID - used to populate state and nonce.\n     * @returns string (GUID)\n     */\n    createNewGuid(): string {\n        return this.guidGenerator.generateGuid();\n    }\n\n    /**\n     * Encodes input string to base64.\n     * @param input - string to be encoded\n     */\n    base64Encode(input: string): string {\n        return EncodingUtils.base64Encode(input);\n    }\n\n    /**\n     * Decodes input string from base64.\n     * @param input - string to be decoded\n     */\n    base64Decode(input: string): string {\n        return EncodingUtils.base64Decode(input);\n    }\n\n    /**\n     * Generates PKCE codes used in Authorization Code Flow.\n     */\n    generatePkceCodes(): Promise<PkceCodes> {\n        return this.pkceGenerator.generatePkceCodes();\n    }\n\n    /**\n     * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node\n     */\n    getPublicKeyThumbprint(): Promise<string> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Removes cryptographic keypair from key store matching the keyId passed in\n     * @param kid \n     */\n    removeTokenBindingKey(): Promise<boolean> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Removes all cryptographic keys from Keystore\n     */\n    clearKeystore(): Promise<boolean> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node\n     */\n    signJwt(): Promise<string> {\n        throw new Error(\"Method not implemented.\");\n    }\n\n    /**\n     * Returns the SHA-256 hash of an input string\n     */\n    async hashString(plainText: string): Promise<string> {\n        return EncodingUtils.base64EncodeUrl(\n            this.hashUtils.sha256(plainText).toString(\"base64\"), \n            \"base64\" \n        );\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { StringUtils, AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager } from \"@azure/msal-common\";\nimport { JsonCache, InMemoryCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\n\n/**\n * This class deserializes cache entities read from the file into in memory object types defined internally\n */\nexport class Deserializer {\n    /**\n     * Parse the JSON blob in memory and deserialize the content\n     * @param cachedJson\n     */\n    static deserializeJSONBlob(jsonFile: string): JsonCache {\n        const deserializedCache = StringUtils.isEmpty(jsonFile)\n            ? {}\n            : JSON.parse(jsonFile);\n        return deserializedCache;\n    }\n\n    /**\n     * Deserializes accounts to AccountEntity objects\n     * @param accounts\n     */\n    static deserializeAccounts(accounts: Record<string, SerializedAccountEntity>): AccountCache {\n        const accountObjects: AccountCache = {};\n        if (accounts) {\n            Object.keys(accounts).map(function (key) {\n                const serializedAcc = accounts[key];\n                const mappedAcc = {\n                    homeAccountId: serializedAcc.home_account_id,\n                    environment: serializedAcc.environment,\n                    realm: serializedAcc.realm,\n                    localAccountId: serializedAcc.local_account_id,\n                    username: serializedAcc.username,\n                    authorityType: serializedAcc.authority_type,\n                    name: serializedAcc.name,\n                    clientInfo: serializedAcc.client_info,\n                    lastModificationTime: serializedAcc.last_modification_time,\n                    lastModificationApp: serializedAcc.last_modification_app,\n                };\n                const account: AccountEntity = new AccountEntity();\n                CacheManager.toObject(account, mappedAcc);\n                accountObjects[key] = account;\n            });\n        }\n\n        return accountObjects;\n    }\n\n    /**\n     * Deserializes id tokens to IdTokenEntity objects\n     * @param idTokens\n     */\n    static deserializeIdTokens(idTokens: Record<string, SerializedIdTokenEntity>): IdTokenCache {\n        const idObjects: IdTokenCache = {};\n        if (idTokens) {\n            Object.keys(idTokens).map(function (key) {\n                const serializedIdT = idTokens[key];\n                const mappedIdT = {\n                    homeAccountId: serializedIdT.home_account_id,\n                    environment: serializedIdT.environment,\n                    credentialType: serializedIdT.credential_type,\n                    clientId: serializedIdT.client_id,\n                    secret: serializedIdT.secret,\n                    realm: serializedIdT.realm,\n                };\n                const idToken: IdTokenEntity = new IdTokenEntity();\n                CacheManager.toObject(idToken, mappedIdT);\n                idObjects[key] = idToken;\n            });\n        }\n        return idObjects;\n    }\n\n    /**\n     * Deserializes access tokens to AccessTokenEntity objects\n     * @param accessTokens\n     */\n    static deserializeAccessTokens(accessTokens: Record<string, SerializedAccessTokenEntity>): AccessTokenCache {\n        const atObjects: AccessTokenCache = {};\n        if (accessTokens) {\n            Object.keys(accessTokens).map(function (key) {\n                const serializedAT = accessTokens[key];\n                const mappedAT = {\n                    homeAccountId: serializedAT.home_account_id,\n                    environment: serializedAT.environment,\n                    credentialType: serializedAT.credential_type,\n                    clientId: serializedAT.client_id,\n                    secret: serializedAT.secret,\n                    realm: serializedAT.realm,\n                    target: serializedAT.target,\n                    cachedAt: serializedAT.cached_at,\n                    expiresOn: serializedAT.expires_on,\n                    extendedExpiresOn: serializedAT.extended_expires_on,\n                    refreshOn: serializedAT.refresh_on,\n                    keyId: serializedAT.key_id,\n                    tokenType: serializedAT.token_type,\n                    requestedClaims: serializedAT.requestedClaims,\n                    requestedClaimsHash: serializedAT.requestedClaimsHash\n                };\n                const accessToken: AccessTokenEntity = new AccessTokenEntity();\n                CacheManager.toObject(accessToken, mappedAT);\n                atObjects[key] = accessToken;\n            });\n        }\n\n        return atObjects;\n    }\n\n    /**\n     * Deserializes refresh tokens to RefreshTokenEntity objects\n     * @param refreshTokens\n     */\n    static deserializeRefreshTokens(refreshTokens: Record<string, SerializedRefreshTokenEntity>): RefreshTokenCache {\n        const rtObjects: RefreshTokenCache = {};\n        if (refreshTokens) {\n            Object.keys(refreshTokens).map(function (key) {\n                const serializedRT = refreshTokens[key];\n                const mappedRT = {\n                    homeAccountId: serializedRT.home_account_id,\n                    environment: serializedRT.environment,\n                    credentialType: serializedRT.credential_type,\n                    clientId: serializedRT.client_id,\n                    secret: serializedRT.secret,\n                    familyId: serializedRT.family_id,\n                    target: serializedRT.target,\n                    realm: serializedRT.realm,\n                };\n                const refreshToken: RefreshTokenEntity = new RefreshTokenEntity();\n                CacheManager.toObject(refreshToken, mappedRT);\n                rtObjects[key] = refreshToken;\n            });\n        }\n\n        return rtObjects;\n    }\n\n    /**\n     * Deserializes appMetadata to AppMetaData objects\n     * @param appMetadata\n     */\n    static deserializeAppMetadata(appMetadata: Record<string, SerializedAppMetadataEntity>): AppMetadataCache {\n        const appMetadataObjects: AppMetadataCache = {};\n        if (appMetadata) {\n            Object.keys(appMetadata).map(function (key) {\n                const serializedAmdt = appMetadata[key];\n                const mappedAmd = {\n                    clientId: serializedAmdt.client_id,\n                    environment: serializedAmdt.environment,\n                    familyId: serializedAmdt.family_id,\n                };\n                const amd: AppMetadataEntity = new AppMetadataEntity();\n                CacheManager.toObject(amd, mappedAmd);\n                appMetadataObjects[key] = amd;\n            });\n        }\n\n        return appMetadataObjects;\n    }\n\n    /**\n     * Deserialize an inMemory Cache\n     * @param jsonCache\n     */\n    static deserializeAllCache(jsonCache: JsonCache): InMemoryCache {\n        return {\n            accounts: jsonCache.Account\n                ? this.deserializeAccounts(jsonCache.Account)\n                : {},\n            idTokens: jsonCache.IdToken\n                ? this.deserializeIdTokens(jsonCache.IdToken)\n                : {},\n            accessTokens: jsonCache.AccessToken\n                ? this.deserializeAccessTokens(jsonCache.AccessToken)\n                : {},\n            refreshTokens: jsonCache.RefreshToken\n                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)\n                : {},\n            appMetadata: jsonCache.AppMetadata\n                ? this.deserializeAppMetadata(jsonCache.AppMetadata)\n                : {},\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountCache, IdTokenCache, AccessTokenCache, RefreshTokenCache, AppMetadataCache } from \"@azure/msal-common\";\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedIdTokenEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedAppMetadataEntity } from \"./SerializerTypes\";\n\nexport class Serializer {\n    /**\n     * serialize the JSON blob\n     * @param data\n     */\n    static serializeJSONBlob(data: JsonCache): string {\n        return JSON.stringify(data);\n    }\n\n    /**\n     * Serialize Accounts\n     * @param accCache\n     */\n    static serializeAccounts(accCache: AccountCache): Record<string, SerializedAccountEntity> {\n        const accounts: Record<string, SerializedAccountEntity> = {};\n        Object.keys(accCache).map(function (key) {\n            const accountEntity = accCache[key];\n            accounts[key] = {\n                home_account_id: accountEntity.homeAccountId,\n                environment: accountEntity.environment,\n                realm: accountEntity.realm,\n                local_account_id: accountEntity.localAccountId,\n                username: accountEntity.username,\n                authority_type: accountEntity.authorityType,\n                name: accountEntity.name,\n                client_info: accountEntity.clientInfo,\n                last_modification_time: accountEntity.lastModificationTime,\n                last_modification_app: accountEntity.lastModificationApp,\n            };\n        });\n\n        return accounts;\n    }\n\n    /**\n     * Serialize IdTokens\n     * @param idTCache\n     */\n    static serializeIdTokens(idTCache: IdTokenCache): Record<string, SerializedIdTokenEntity> {\n        const idTokens: Record<string, SerializedIdTokenEntity> = {};\n        Object.keys(idTCache).map(function (key) {\n            const idTEntity = idTCache[key];\n            idTokens[key] = {\n                home_account_id: idTEntity.homeAccountId,\n                environment: idTEntity.environment,\n                credential_type: idTEntity.credentialType,\n                client_id: idTEntity.clientId,\n                secret: idTEntity.secret,\n                realm: idTEntity.realm,\n            };\n        });\n\n        return idTokens;\n    }\n\n    /**\n     * Serializes AccessTokens\n     * @param atCache\n     */\n    static serializeAccessTokens(atCache: AccessTokenCache): Record<string, SerializedAccessTokenEntity> {\n        const accessTokens: Record<string, SerializedAccessTokenEntity> = {};\n        Object.keys(atCache).map(function (key) {\n            const atEntity = atCache[key];\n            accessTokens[key] = {\n                home_account_id: atEntity.homeAccountId,\n                environment: atEntity.environment,\n                credential_type: atEntity.credentialType,\n                client_id: atEntity.clientId,\n                secret: atEntity.secret,\n                realm: atEntity.realm,\n                target: atEntity.target,\n                cached_at: atEntity.cachedAt,\n                expires_on: atEntity.expiresOn,\n                extended_expires_on: atEntity.extendedExpiresOn,\n                refresh_on: atEntity.refreshOn,\n                key_id: atEntity.keyId,\n                token_type: atEntity.tokenType,\n                requestedClaims: atEntity.requestedClaims,\n                requestedClaimsHash: atEntity.requestedClaimsHash\n            };\n        });\n\n        return accessTokens;\n    }\n\n    /**\n     * Serialize refreshTokens\n     * @param rtCache\n     */\n    static serializeRefreshTokens(rtCache: RefreshTokenCache): Record<string, SerializedRefreshTokenEntity> {\n        const refreshTokens: Record<string, SerializedRefreshTokenEntity> = {};\n        Object.keys(rtCache).map(function (key) {\n            const rtEntity = rtCache[key];\n            refreshTokens[key] = {\n                home_account_id: rtEntity.homeAccountId,\n                environment: rtEntity.environment,\n                credential_type: rtEntity.credentialType,\n                client_id: rtEntity.clientId,\n                secret: rtEntity.secret,\n                family_id: rtEntity.familyId,\n                target: rtEntity.target,\n                realm: rtEntity.realm\n            };\n        });\n\n        return refreshTokens;\n    }\n\n    /**\n     * Serialize amdtCache\n     * @param amdtCache\n     */\n    static serializeAppMetadata(amdtCache: AppMetadataCache): Record<string, SerializedAppMetadataEntity> {\n        const appMetadata: Record<string, SerializedAppMetadataEntity> = {};\n        Object.keys(amdtCache).map(function (key) {\n            const amdtEntity = amdtCache[key];\n            appMetadata[key] = {\n                client_id: amdtEntity.clientId,\n                environment: amdtEntity.environment,\n                family_id: amdtEntity.familyId,\n            };\n        });\n\n        return appMetadata;\n    }\n\n    /**\n     * Serialize the cache\n     * @param jsonContent\n     */\n    static serializeAllCache(inMemCache: InMemoryCache): JsonCache {\n        return {\n            Account: this.serializeAccounts(inMemCache.accounts),\n            IdToken: this.serializeIdTokens(inMemCache.idTokens),\n            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),\n            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),\n            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccountEntity,\n    IdTokenEntity,\n    AccessTokenEntity,\n    RefreshTokenEntity,\n    AppMetadataEntity,\n    ServerTelemetryEntity,\n    ThrottlingEntity,\n    CacheManager,\n    Logger,\n    ValidCacheType,\n    ICrypto,\n    AuthorityMetadataEntity,\n    ValidCredentialType\n} from \"@azure/msal-common\";\nimport { Deserializer } from \"./serializer/Deserializer\";\nimport { Serializer } from \"./serializer/Serializer\";\nimport { InMemoryCache, JsonCache, CacheKVStore } from \"./serializer/SerializerTypes\";\n\n/**\n * This class implements Storage for node, reading cache from user specified storage location or an  extension library\n * @public\n */\nexport class NodeStorage extends CacheManager {\n    // Cache configuration, either set by user or default values.\n    private logger: Logger;\n    private cache: CacheKVStore = {};\n    private changeEmitters: Array<Function> = [];\n\n    constructor(logger: Logger, clientId: string, cryptoImpl: ICrypto) {\n        super(clientId, cryptoImpl);\n        this.logger = logger;\n    }\n\n    /**\n     * Queue up callbacks\n     * @param func - a callback function for cache change indication\n     */\n    registerChangeEmitter(func: () => void): void {\n        this.changeEmitters.push(func);\n    }\n\n    /**\n     * Invoke the callback when cache changes\n     */\n    emitChange(): void {\n        this.changeEmitters.forEach(func => func.call(null));\n    }\n\n    /**\n     * Converts cacheKVStore to InMemoryCache\n     * @param cache - key value store\n     */\n    cacheToInMemoryCache(cache: CacheKVStore): InMemoryCache {\n        const inMemoryCache: InMemoryCache = {\n            accounts: {},\n            idTokens: {},\n            accessTokens: {},\n            refreshTokens: {},\n            appMetadata: {},\n        };\n\n        for (const key in cache) {\n            if (cache[key as string] instanceof AccountEntity) {\n                inMemoryCache.accounts[key] = cache[key] as AccountEntity;\n            } else if (cache[key] instanceof IdTokenEntity) {\n                inMemoryCache.idTokens[key] = cache[key] as IdTokenEntity;\n            } else if (cache[key] instanceof AccessTokenEntity) {\n                inMemoryCache.accessTokens[key] = cache[key] as AccessTokenEntity;\n            } else if (cache[key] instanceof RefreshTokenEntity) {\n                inMemoryCache.refreshTokens[key] = cache[key] as RefreshTokenEntity;\n            } else if (cache[key] instanceof AppMetadataEntity) {\n                inMemoryCache.appMetadata[key] = cache[key] as AppMetadataEntity;\n            } else {\n                continue;\n            }\n        }\n\n        return inMemoryCache;\n    }\n\n    /**\n     * converts inMemoryCache to CacheKVStore\n     * @param inMemoryCache - kvstore map for inmemory\n     */\n    inMemoryCacheToCache(inMemoryCache: InMemoryCache): CacheKVStore {\n\n        // convert in memory cache to a flat Key-Value map\n        let cache = this.getCache();\n\n        cache = {\n            ...cache,\n            ...inMemoryCache.accounts,\n            ...inMemoryCache.idTokens,\n            ...inMemoryCache.accessTokens,\n            ...inMemoryCache.refreshTokens,\n            ...inMemoryCache.appMetadata\n        };\n\n        // convert in memory cache to a flat Key-Value map\n        return cache;\n    }\n\n    /**\n     * gets the current in memory cache for the client\n     */\n    getInMemoryCache(): InMemoryCache {\n        this.logger.trace(\"Getting in-memory cache\");\n\n        // convert the cache key value store to inMemoryCache\n        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());\n        return inMemoryCache;\n    }\n\n    /**\n     * sets the current in memory cache for the client\n     * @param inMemoryCache - key value map in memory\n     */\n    setInMemoryCache(inMemoryCache: InMemoryCache): void{\n        this.logger.trace(\"Setting in-memory cache\");\n\n        // convert and append the inMemoryCache to cacheKVStore\n        const cache = this.inMemoryCacheToCache(inMemoryCache);\n        this.setCache(cache);\n\n        this.emitChange();\n    }\n\n    /**\n     * get the current cache key-value store\n     */\n    getCache(): CacheKVStore {\n        this.logger.trace(\"Getting cache key-value store\");\n        return this.cache;\n    }\n\n    /**\n     * sets the current cache (key value store)\n     * @param cacheMap - key value map\n     */\n    setCache(cache: CacheKVStore): void {\n        this.logger.trace(\"Setting cache key value store\");\n        this.cache = cache;\n\n        // mark change in cache\n        this.emitChange();\n    }\n\n    /**\n     * Gets cache item with given key.\n     * @param key - lookup key for the cache entry\n     */\n    getItem(key: string): ValidCacheType {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read cache\n        const cache = this.getCache();\n        return cache[key];\n    }\n\n    /**\n     * Gets cache item with given key-value\n     * @param key - lookup key for the cache entry\n     * @param value - value of the cache entry\n     */\n    setItem(key: string, value: ValidCacheType): void {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read cache\n        const cache = this.getCache();\n        cache[key] = value;\n\n        // write to cache\n        this.setCache(cache);\n    }\n\n    /**\n     * fetch the account entity\n     * @param accountKey - lookup key to fetch cache type AccountEntity\n     */\n    getAccount(accountKey: string): AccountEntity | null {\n        const account = this.getItem(accountKey) as AccountEntity;\n        if (AccountEntity.isAccountEntity(account)) {\n            return account;\n        }\n        return null;\n    }\n\n    /**\n     * set account entity\n     * @param account - cache value to be set of type AccountEntity\n     */\n    setAccount(account: AccountEntity): void {\n        const accountKey = account.generateAccountKey();\n        this.setItem(accountKey, account);\n    }\n\n    /**\n     * fetch the idToken credential\n     * @param idTokenKey - lookup key to fetch cache type IdTokenEntity\n     */\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\n        const idToken = this.getItem(idTokenKey) as IdTokenEntity;\n        if (IdTokenEntity.isIdTokenEntity(idToken)) {\n            return idToken;\n        }\n        return null;\n    }\n\n    /**\n     * set idToken credential\n     * @param idToken - cache value to be set of type IdTokenEntity\n     */\n    setIdTokenCredential(idToken: IdTokenEntity): void {\n        const idTokenKey = idToken.generateCredentialKey();\n        this.setItem(idTokenKey, idToken);\n    }\n\n    /**\n     * fetch the accessToken credential\n     * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity\n     */\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\n        const accessToken = this.getItem(accessTokenKey) as AccessTokenEntity;\n        if (AccessTokenEntity.isAccessTokenEntity(accessToken)) {\n            return accessToken;\n        }\n        return null;\n    }\n\n    /**\n     * set accessToken credential\n     * @param accessToken -  cache value to be set of type AccessTokenEntity\n     */\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\n        const accessTokenKey = accessToken.generateCredentialKey();\n        this.setItem(accessTokenKey, accessToken);\n    }\n\n    /**\n     * fetch the refreshToken credential\n     * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity\n     */\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\n        const refreshToken = this.getItem(refreshTokenKey) as RefreshTokenEntity;\n        if (RefreshTokenEntity.isRefreshTokenEntity(refreshToken)) {\n            return refreshToken as RefreshTokenEntity;\n        }\n        return null;\n    }\n\n    /**\n     * set refreshToken credential\n     * @param refreshToken - cache value to be set of type RefreshTokenEntity\n     */\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\n        const refreshTokenKey = refreshToken.generateCredentialKey();\n        this.setItem(refreshTokenKey, refreshToken);\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const appMetadata: AppMetadataEntity = this.getItem(appMetadataKey) as AppMetadataEntity;\n        if (AppMetadataEntity.isAppMetadataEntity(appMetadataKey, appMetadata)) {\n            return appMetadata;\n        }\n        return null;\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata - cache value to be set of type AppMetadataEntity\n     */\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\n        this.setItem(appMetadataKey, appMetadata);\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity\n     */\n    getServerTelemetry(serverTelemetrykey: string): ServerTelemetryEntity | null {\n        const serverTelemetryEntity: ServerTelemetryEntity = this.getItem(serverTelemetrykey) as ServerTelemetryEntity;\n        if (serverTelemetryEntity && ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {\n            return serverTelemetryEntity;\n        }\n        return null;\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity\n     * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity\n     */\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\n        this.setItem(serverTelemetryKey, serverTelemetry);\n    }\n\n    /**\n     * fetch authority metadata entity from the platform cache\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\n     */\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\n        const authorityMetadataEntity: AuthorityMetadataEntity = this.getItem(key) as AuthorityMetadataEntity;\n        if (authorityMetadataEntity && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, authorityMetadataEntity)) {\n            return authorityMetadataEntity;\n        }\n        return null;\n    }\n\n    /**\n     * Get all authority metadata keys\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        return this.getKeys().filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * set authority metadata entity to the platform cache\n     * @param key - lookup key to fetch cache type AuthorityMetadataEntity\n     * @param metadata - cache value to be set of type AuthorityMetadataEntity\n     */\n    setAuthorityMetadata(key: string, metadata: AuthorityMetadataEntity): void {\n        this.setItem(key, metadata);\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const throttlingCache: ThrottlingEntity = this.getItem(throttlingCacheKey) as ThrottlingEntity;\n        if (throttlingCache && ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, throttlingCache)) {\n            return throttlingCache;\n        }\n        return null;\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity\n     * @param throttlingCache - cache value to be set of type ThrottlingEntity\n     */\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\n        this.setItem(throttlingCacheKey, throttlingCache);\n    }\n\n    /**\n     * Removes the cache item from memory with the given key.\n     * @param key - lookup key to remove a cache entity\n     * @param inMemory - key value map of the cache\n     */\n    removeItem(key: string): boolean {\n        this.logger.tracePii(`Item key: ${key}`);\n\n        // read inMemoryCache\n        let result: boolean = false;\n        const cache = this.getCache();\n\n        if (!!cache[key]) {\n            delete cache[key];\n            result = true;\n        }\n\n        // write to the cache after removal\n        if (result) {\n            this.setCache(cache);\n            this.emitChange();\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether key is in cache.\n     * @param key - look up key for a cache entity\n     */\n    containsKey(key: string): boolean {\n        return this.getKeys().includes(key);\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        this.logger.trace(\"Retrieving all cache keys\");\n\n        // read cache\n        const cache = this.getCache();\n        return [ ...Object.keys(cache)];\n    }\n\n    /**\n     * Clears all cache entries created by MSAL (except tokens).\n     */\n    async clear(): Promise<void> {\n        this.logger.trace(\"Clearing cache entries created by MSAL\");\n\n        // read inMemoryCache\n        const cacheKeys = this.getKeys();\n\n        // delete each element\n        cacheKeys.forEach(key => {\n            this.removeItem(key);\n        });\n        this.emitChange();\n    }\n\n    /**\n     * Initialize in memory cache from an exisiting cache vault\n     * @param cache - blob formatted cache (JSON)\n     */\n    static generateInMemoryCache(cache: string): InMemoryCache {\n        return Deserializer.deserializeAllCache(\n            Deserializer.deserializeJSONBlob(cache)\n        );\n    }\n\n    /**\n     * retrieves the final JSON\n     * @param inMemoryCache - itemised cache read from the JSON\n     */\n    static generateJsonCache(inMemoryCache: InMemoryCache): JsonCache {\n        return Serializer.serializeAllCache(inMemoryCache);\n    }\n\n    /**\n     * Updates a credential's cache key if the current cache key is outdated\n     */\n    updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string {\n        const updatedCacheKey = credential.generateCredentialKey();\n\n        if (currentCacheKey !== updatedCacheKey) {\n            const cacheItem = this.getItem(currentCacheKey);\n            if (cacheItem) {\n                this.removeItem(currentCacheKey);\n                this.setItem(updatedCacheKey, cacheItem);\n                this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\n                return updatedCacheKey;\n            } else {\n                this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\n            }\n        }\n\n        return currentCacheKey;\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { NodeStorage } from \"./NodeStorage\";\nimport { StringUtils, AccountEntity, AccountInfo, Logger, ISerializableTokenCache, ICachePlugin, TokenCacheContext } from \"@azure/msal-common\";\nimport { InMemoryCache, JsonCache, SerializedAccountEntity, SerializedAccessTokenEntity, SerializedRefreshTokenEntity, SerializedIdTokenEntity, SerializedAppMetadataEntity, CacheKVStore } from \"./serializer/SerializerTypes\";\nimport { Deserializer } from \"./serializer/Deserializer\";\nimport { Serializer } from \"./serializer/Serializer\";\nimport { ITokenCache } from \"./ITokenCache\";\n\nconst defaultSerializedCache: JsonCache = {\n    Account: {},\n    IdToken: {},\n    AccessToken: {},\n    RefreshToken: {},\n    AppMetadata: {},\n};\n\n/**\n * In-memory token cache manager\n * @public\n */\nexport class TokenCache implements ISerializableTokenCache, ITokenCache {\n\n    private storage: NodeStorage;\n    private cacheHasChanged: boolean;\n    private cacheSnapshot: string;\n    private readonly persistence: ICachePlugin;\n    private logger: Logger;\n\n    constructor(storage: NodeStorage, logger: Logger, cachePlugin?: ICachePlugin) {\n        this.cacheHasChanged = false;\n        this.storage = storage;\n        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));\n        if (cachePlugin) {\n            this.persistence = cachePlugin;\n        }\n        this.logger = logger;\n    }\n\n    /**\n     * Set to true if cache state has changed since last time serialize or writeToPersistence was called\n     */\n    hasChanged(): boolean {\n        return this.cacheHasChanged;\n    }\n\n    /**\n     * Serializes in memory cache to JSON\n     */\n    serialize(): string {\n        this.logger.trace(\"Serializing in-memory cache\");\n        let finalState = Serializer.serializeAllCache(\n            this.storage.getInMemoryCache() as InMemoryCache\n        );\n\n        // if cacheSnapshot not null or empty, merge\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\n            this.logger.trace(\"Reading cache snapshot from disk\");\n            finalState = this.mergeState(\n                JSON.parse(this.cacheSnapshot),\n                finalState\n            );\n        } else {\n            this.logger.trace(\"No cache snapshot to merge\");\n        }\n        this.cacheHasChanged = false;\n\n        return JSON.stringify(finalState);\n    }\n\n    /**\n     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format\n     * @param cache - blob formatted cache\n     */\n    deserialize(cache: string): void {\n        this.logger.trace(\"Deserializing JSON to in-memory cache\");\n        this.cacheSnapshot = cache;\n\n        if (!StringUtils.isEmpty(this.cacheSnapshot)) {\n            this.logger.trace(\"Reading cache snapshot from disk\");\n            const deserializedCache = Deserializer.deserializeAllCache(\n                this.overlayDefaults(JSON.parse(this.cacheSnapshot))\n            );\n            this.storage.setInMemoryCache(deserializedCache);\n        } else {\n            this.logger.trace(\"No cache snapshot to deserialize\");\n        }\n    }\n\n    /**\n     * Fetches the cache key-value map\n     */\n    getKVStore(): CacheKVStore {\n        return this.storage.getCache();\n    }\n\n    /**\n     * API that retrieves all accounts currently in cache to the user\n     */\n    async getAllAccounts(): Promise<AccountInfo[]> {\n\n        this.logger.trace(\"getAllAccounts called\");\n        let cacheContext;\n        try {\n            if (this.persistence) {\n                cacheContext = new TokenCacheContext(this, false);\n                await this.persistence.beforeCacheAccess(cacheContext);\n            }\n            return this.storage.getAllAccounts();\n        } finally {\n            if (this.persistence && cacheContext) {\n                await this.persistence.afterCacheAccess(cacheContext);\n            }\n        }\n    }\n\n    /**\n     * Returns the signed in account matching homeAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param homeAccountId - unique identifier for an account (uid.utid)\n     */\n    async getAccountByHomeId(homeAccountId: string): Promise<AccountInfo | null> {\n        const allAccounts = await this.getAllAccounts();\n        if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {\n            return allAccounts.filter(accountObj => accountObj.homeAccountId === homeAccountId)[0] || null;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the signed in account matching localAccountId.\n     * (the account object is created at the time of successful login)\n     * or null when no matching account is found\n     * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)\n     */\n    async getAccountByLocalId(localAccountId: string): Promise<AccountInfo | null> {\n        const allAccounts = await this.getAllAccounts();\n        if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {\n            return allAccounts.filter(accountObj => accountObj.localAccountId === localAccountId)[0] || null;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * API to remove a specific account and the relevant data from cache\n     * @param account - AccountInfo passed by the user\n     */\n    async removeAccount(account: AccountInfo): Promise<void> {\n        this.logger.trace(\"removeAccount called\");\n        let cacheContext;\n        try {\n            if (this.persistence) {\n                cacheContext = new TokenCacheContext(this, true);\n                await this.persistence.beforeCacheAccess(cacheContext);\n            }\n            await this.storage.removeAccount(AccountEntity.generateAccountCacheKey(account));\n        } finally {\n            if (this.persistence && cacheContext) {\n                await this.persistence.afterCacheAccess(cacheContext);\n            }\n        }\n    }\n\n    /**\n     * Called when the cache has changed state.\n     */\n    private handleChangeEvent() {\n        this.cacheHasChanged = true;\n    }\n\n    /**\n     * Merge in memory cache with the cache snapshot.\n     * @param oldState - cache before changes\n     * @param currentState - current cache state in the library\n     */\n    private mergeState(oldState: JsonCache, currentState: JsonCache): JsonCache {\n        this.logger.trace(\"Merging in-memory cache with cache snapshot\");\n        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);\n        return this.mergeUpdates(stateAfterRemoval, currentState);\n    }\n\n    /**\n     * Deep update of oldState based on newState values\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeUpdates(oldState: object, newState: object): JsonCache {\n        Object.keys(newState).forEach((newKey: string) => {\n            const newValue = newState[newKey];\n\n            // if oldState does not contain value but newValue does, add it\n            if (!oldState.hasOwnProperty(newKey)) {\n                if (newValue !== null) {\n                    oldState[newKey] = newValue;\n                }\n            } else {\n                // both oldState and newState contain the key, do deep update\n                const newValueNotNull = newValue !== null;\n                const newValueIsObject = typeof newValue === \"object\";\n                const newValueIsNotArray = !Array.isArray(newValue);\n                const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== \"undefined\" && oldState[newKey] !== null;\n\n                if (newValueNotNull && newValueIsObject && newValueIsNotArray && oldStateNotUndefinedOrNull) {\n                    this.mergeUpdates(oldState[newKey], newValue);\n                } else {\n                    oldState[newKey] = newValue;\n                }\n            }\n        });\n\n        return oldState as JsonCache;\n    }\n\n    /**\n     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of\n     * oldState that are not recognized, they are left untouched.\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeRemovals(oldState: JsonCache, newState: JsonCache): JsonCache {\n        this.logger.trace(\"Remove updated entries in cache\");\n        const accounts = oldState.Account ? this.mergeRemovalsDict<SerializedAccountEntity>(oldState.Account, newState.Account) : oldState.Account;\n        const accessTokens = oldState.AccessToken ? this.mergeRemovalsDict<SerializedAccessTokenEntity>(oldState.AccessToken, newState.AccessToken) : oldState.AccessToken;\n        const refreshTokens = oldState.RefreshToken ? this.mergeRemovalsDict<SerializedRefreshTokenEntity>(oldState.RefreshToken, newState.RefreshToken) : oldState.RefreshToken;\n        const idTokens = oldState.IdToken ? this.mergeRemovalsDict<SerializedIdTokenEntity>(oldState.IdToken, newState.IdToken) : oldState.IdToken;\n        const appMetadata = oldState.AppMetadata ? this.mergeRemovalsDict<SerializedAppMetadataEntity>(oldState.AppMetadata, newState.AppMetadata) : oldState.AppMetadata;\n\n        return {\n            ...oldState,\n            Account: accounts,\n            AccessToken: accessTokens,\n            RefreshToken: refreshTokens,\n            IdToken: idTokens,\n            AppMetadata: appMetadata\n        };\n    }\n\n    /**\n     * Helper to merge new cache with the old one\n     * @param oldState - cache before changes\n     * @param newState - updated cache\n     */\n    private mergeRemovalsDict<T>(oldState: Record<string, T>, newState?: Record<string, T>): Record<string, T> {\n        const finalState = { ...oldState };\n        Object.keys(oldState).forEach((oldKey) => {\n            if (!newState || !(newState.hasOwnProperty(oldKey))) {\n                delete finalState[oldKey];\n            }\n        });\n        return finalState;\n    }\n\n    /**\n     * Helper to overlay as a part of cache merge\n     * @param passedInCache - cache read from the blob\n     */\n    private overlayDefaults(passedInCache: JsonCache): JsonCache {\n        this.logger.trace(\"Overlaying input cache with the default cache\");\n        return {\n            Account: {\n                ...defaultSerializedCache.Account,\n                ...passedInCache.Account,\n            },\n            IdToken: {\n                ...defaultSerializedCache.IdToken,\n                ...passedInCache.IdToken,\n            },\n            AccessToken: {\n                ...defaultSerializedCache.AccessToken,\n                ...passedInCache.AccessToken,\n            },\n            RefreshToken: {\n                ...defaultSerializedCache.RefreshToken,\n                ...passedInCache.RefreshToken,\n            },\n            AppMetadata: {\n                ...defaultSerializedCache.AppMetadata,\n                ...passedInCache.AppMetadata,\n            },\n        };\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodeClient,\n    ClientConfiguration,\n    RefreshTokenClient,\n    AuthenticationResult,\n    Authority,\n    AuthorityFactory,\n    BaseAuthRequest,\n    SilentFlowClient,\n    Logger,\n    ServerTelemetryManager,\n    ServerTelemetryRequest,\n    CommonSilentFlowRequest,\n    CommonRefreshTokenRequest,\n    CommonAuthorizationCodeRequest,\n    CommonAuthorizationUrlRequest,\n    CommonUsernamePasswordRequest,\n    UsernamePasswordClient,\n    AuthenticationScheme,\n    ResponseMode,\n    AuthorityOptions,\n    OIDC_DEFAULT_SCOPES,\n    AzureRegionConfiguration,\n    AuthError,\n    AzureCloudOptions,\n    AuthorizationCodePayload,\n    StringUtils,\n    Constants,\n} from \"@azure/msal-common\";\nimport { Configuration, buildAppConfiguration, NodeConfiguration } from \"../config/Configuration\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\nimport { NodeStorage } from \"../cache/NodeStorage\";\nimport { Constants as NodeConstants, ApiId } from \"../utils/Constants\";\nimport { TokenCache } from \"../cache/TokenCache\";\nimport { ClientAssertion } from \"./ClientAssertion\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\nimport { AuthorizationCodeRequest } from \"../request/AuthorizationCodeRequest\";\nimport { RefreshTokenRequest } from \"../request/RefreshTokenRequest\";\nimport { SilentFlowRequest } from \"../request/SilentFlowRequest\";\nimport { version, name } from \"../packageMetadata\";\nimport { UsernamePasswordRequest } from \"../request/UsernamePasswordRequest\";\n\n/**\n * Base abstract class for all ClientApplications - public and confidential\n * @public\n */\nexport abstract class ClientApplication {\n\n    private readonly cryptoProvider: CryptoProvider;\n    private tokenCache: TokenCache;\n\n    /**\n     * Platform storage object\n     */\n    protected storage: NodeStorage;\n    /**\n     * Logger object to log the application flow\n     */\n    protected logger: Logger;\n    /**\n     * Platform configuration initialized by the application\n     */\n    protected config: NodeConfiguration;\n    /**\n     * Client assertion passed by the user for confidential client flows\n     */\n    protected clientAssertion: ClientAssertion;\n    /**\n     * Client secret passed by the user for confidential client flows\n     */\n    protected clientSecret: string;\n\n    /**\n     * Constructor for the ClientApplication\n     */\n    protected constructor(configuration: Configuration) {\n        this.config = buildAppConfiguration(configuration);\n        this.cryptoProvider = new CryptoProvider();\n        this.logger = new Logger(this.config.system.loggerOptions, name, version);\n        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider);\n        this.tokenCache = new TokenCache(\n            this.storage,\n            this.logger,\n            this.config.cache.cachePlugin\n        );\n    }\n\n    /**\n     * Creates the URL of the authorization request, letting the user input credentials and consent to the\n     * application. The URL targets the /authorize endpoint of the authority configured in the\n     * application object.\n     *\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n     * `acquireTokenByCode(AuthorizationCodeRequest)`.\n     */\n    async getAuthCodeUrl(request: AuthorizationUrlRequest): Promise<string> {\n        this.logger.info(\"getAuthCodeUrl called\", request.correlationId);\n        const validRequest: CommonAuthorizationUrlRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            responseMode: request.responseMode || ResponseMode.QUERY,\n            authenticationScheme: AuthenticationScheme.BEARER\n        };\n\n        const authClientConfig = await this.buildOauthClientConfiguration(\n            validRequest.authority,\n            validRequest.correlationId,\n            undefined,\n            undefined,\n            request.azureCloudOptions\n        );\n        const authorizationCodeClient = new AuthorizationCodeClient(\n            authClientConfig\n        );\n        this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\n        return authorizationCodeClient.getAuthCodeUrl(validRequest);\n    }\n\n    /**\n     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0\n     * Authorization Code flow.\n     *\n     * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0\n     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and\n     * AuthorizationCodeRequest are the same.\n     */\n    async acquireTokenByCode(request: AuthorizationCodeRequest, authCodePayLoad?: AuthorizationCodePayload): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByCode called\", request.correlationId);\n        const validRequest: CommonAuthorizationCodeRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            authenticationScheme: AuthenticationScheme.BEARER\n        };\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);\n        try {\n            const authClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const authorizationCodeClient = new AuthorizationCodeClient(\n                authClientConfig\n            );\n            this.logger.verbose(\"Auth code client created\", validRequest.correlationId);\n            return authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token by exchanging the refresh token provided for a new set of tokens.\n     *\n     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is\n     * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will\n     * handle the caching and refreshing of tokens automatically.\n     */\n    async acquireTokenByRefreshToken(request: RefreshTokenRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByRefreshToken called\", request.correlationId);\n        const validRequest: CommonRefreshTokenRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            authenticationScheme: AuthenticationScheme.BEARER\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);\n        try {\n            const refreshTokenClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const refreshTokenClient = new RefreshTokenClient(\n                refreshTokenClientConfig\n            );\n            this.logger.verbose(\"Refresh token client created\", validRequest.correlationId);\n            return refreshTokenClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires a token silently when a user specifies the account the token is requested for.\n     *\n     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.\n     * There is also an optional \"forceRefresh\" boolean the user can send to bypass the cache for access_token and id_token.\n     * In case the refresh_token is expired or not found, an error is thrown\n     * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).\n     */\n    async acquireTokenSilent(request: SilentFlowRequest): Promise<AuthenticationResult | null> {\n        const validRequest: CommonSilentFlowRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request),\n            forceRefresh: request.forceRefresh || false\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);\n        try {\n            const silentFlowClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const silentFlowClient = new SilentFlowClient(\n                silentFlowClientConfig\n            );\n            this.logger.verbose(\"Silent flow client created\", validRequest.correlationId);\n            return silentFlowClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires tokens with password grant by exchanging client applications username and password for credentials\n     *\n     * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.\n     * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4\n     * Microsoft's documentation and recommendations are at:\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword\n     *\n     * @param request - UsenamePasswordRequest\n     */\n    async acquireTokenByUsernamePassword(request: UsernamePasswordRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByUsernamePassword called\", request.correlationId);\n        const validRequest: CommonUsernamePasswordRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request)\n        };\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);\n        try {\n            const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);\n            this.logger.verbose(\"Username password client created\", validRequest.correlationId);\n            return usernamePasswordClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Gets the token cache for the application.\n     */\n    getTokenCache(): TokenCache {\n        this.logger.info(\"getTokenCache called\");\n        return this.tokenCache;\n    }\n\n    /**\n     * Returns the logger instance\n     */\n    getLogger(): Logger {\n        return this.logger;\n    }\n\n    /**\n     * Replaces the default logger set in configurations with new Logger with new configurations\n     * @param logger - Logger instance\n     */\n    setLogger(logger: Logger): void {\n        this.logger = logger;\n    }\n\n    /**\n     * Builds the common configuration to be passed to the common component based on the platform configurarion\n     * @param authority - user passed authority in configuration\n     * @param serverTelemetryManager - initializes servertelemetry if passed\n     */\n    protected async buildOauthClientConfiguration(\n        authority: string,\n        requestCorrelationId?: string, \n        serverTelemetryManager?: ServerTelemetryManager,\n        azureRegionConfiguration?: AzureRegionConfiguration, \n        azureCloudOptions?: AzureCloudOptions): Promise<ClientConfiguration> {\n        \n        this.logger.verbose(\"buildOauthClientConfiguration called\", requestCorrelationId);\n\n        // precedence - azureCloudInstance + tenant >> authority and request  >> config\n        const userAzureCloudOptions = azureCloudOptions ? azureCloudOptions : this.config.auth.azureCloudOptions;\n\n        // using null assertion operator as we ensure that all config values have default values in buildConfiguration()\n        this.logger.verbose(`building oauth client configuration with the authority: ${authority}`, requestCorrelationId);\n        const discoveredAuthority = await this.createAuthority(authority, azureRegionConfiguration, requestCorrelationId, userAzureCloudOptions);\n\n        serverTelemetryManager?.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);\n\n        const clientConfiguration: ClientConfiguration = {\n            authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities\n            },\n            systemOptions: {\n                proxyUrl: this.config.system.proxyUrl,\n            },\n            loggerOptions: {\n                logLevel: this.config.system.loggerOptions.logLevel,\n                loggerCallback: this.config.system.loggerOptions\n                    .loggerCallback,\n                piiLoggingEnabled: this.config.system.loggerOptions\n                    .piiLoggingEnabled,\n                correlationId: requestCorrelationId\n            },\n            cryptoInterface: this.cryptoProvider,\n            networkInterface: this.config.system.networkClient,\n            storageInterface: this.storage,\n            serverTelemetryManager: serverTelemetryManager,\n            clientCredentials: {\n                clientSecret: this.clientSecret,\n                clientAssertion: this.clientAssertion ? this.getClientAssertion(discoveredAuthority) : undefined,\n            },\n            libraryInfo: {\n                sku: NodeConstants.MSAL_SKU,\n                version: version,\n                cpu: process.arch || Constants.EMPTY_STRING,\n                os: process.platform || Constants.EMPTY_STRING,\n            },\n            telemetry: this.config.telemetry,\n            persistencePlugin: this.config.cache.cachePlugin,\n            serializableCache: this.tokenCache            \n        };\n\n        return clientConfiguration;\n    }\n\n    private getClientAssertion(authority: Authority): { assertion: string, assertionType: string } {\n        return {\n            assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),\n            assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE\n        };\n    }\n\n    /**\n     * Generates a request with the default scopes & generates a correlationId.\n     * @param authRequest - BaseAuthRequest for initialization\n     */\n    protected async initializeBaseRequest(authRequest: Partial<BaseAuthRequest>): Promise<BaseAuthRequest> {\n        this.logger.verbose(\"initializeRequestScopes called\", authRequest.correlationId);\n        // Default authenticationScheme to Bearer, log that POP isn't supported yet\n        if (authRequest.authenticationScheme && authRequest.authenticationScheme === AuthenticationScheme.POP) {\n            this.logger.verbose(\"Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request\", authRequest.correlationId);\n        }\n\n        authRequest.authenticationScheme = AuthenticationScheme.BEARER;\n\n        // Set requested claims hash if claims were requested\n        if (authRequest.claims && !StringUtils.isEmpty(authRequest.claims)) {\n            authRequest.requestedClaimsHash = await this.cryptoProvider.hashString(authRequest.claims);\n        }\n\n        return {\n            ...authRequest,\n            scopes: [...((authRequest && authRequest.scopes) || []), ...OIDC_DEFAULT_SCOPES],\n            correlationId: authRequest && authRequest.correlationId || this.cryptoProvider.createNewGuid(),\n            authority: authRequest.authority || this.config.auth.authority\n        };\n    }\n\n    /**\n     * Initializes the server telemetry payload\n     * @param apiId - Id for a specific request\n     * @param correlationId - GUID\n     * @param forceRefresh - boolean to indicate network call\n     */\n    protected initializeServerTelemetryManager(apiId: number, correlationId: string, forceRefresh?: boolean): ServerTelemetryManager {\n        const telemetryPayload: ServerTelemetryRequest = {\n            clientId: this.config.auth.clientId,\n            correlationId: correlationId,\n            apiId: apiId,\n            forceRefresh: forceRefresh || false\n        };\n\n        return new ServerTelemetryManager(telemetryPayload, this.storage);\n    }\n\n    /**\n     * Create authority instance. If authority not passed in request, default to authority set on the application\n     * object. If no authority set in application object, then default to common authority.\n     * @param authorityString - authority from user configuration\n     */\n    private async createAuthority(authorityString: string, azureRegionConfiguration?: AzureRegionConfiguration, requestCorrelationId?: string, azureCloudOptions?: AzureCloudOptions): Promise<Authority> {\n        this.logger.verbose(\"createAuthority called\", requestCorrelationId);\n\n        // build authority string based on auth params - azureCloudInstance is prioritized if provided\n        const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions);\n\n        const authorityOptions: AuthorityOptions = {\n            protocolMode: this.config.auth.protocolMode,\n            knownAuthorities: this.config.auth.knownAuthorities,\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n            authorityMetadata: this.config.auth.authorityMetadata,\n            azureRegionConfiguration,\n            skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache,\n        };\n\n        return await AuthorityFactory.createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.config.system.proxyUrl);\n    }\n\n    /**\n     * Clear the cache\n     */\n    clearCache(): void {\n        this.storage.clear();\n    }\n}\n","/* eslint-disable header/header */\nexport const name = \"@azure/msal-node\";\nexport const version = \"1.12.1\";\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { JwtHeader, sign } from \"jsonwebtoken\";\nimport { TimeUtils, ClientAuthError, Constants } from \"@azure/msal-common\";\nimport { CryptoProvider } from \"../crypto/CryptoProvider\";\nimport { EncodingUtils } from \"../utils/EncodingUtils\";\nimport { JwtConstants } from \"../utils/Constants\";\n\n/**\n * Client assertion of type jwt-bearer used in confidential client flows\n * @public\n */\nexport class ClientAssertion {\n\n    private jwt: string;\n    private privateKey: string;\n    private thumbprint: string;\n    private expirationTime: number;\n    private issuer: string;\n    private jwtAudience: string;\n    private publicCertificate: Array<string>;\n\n    /**\n     * Initialize the ClientAssertion class from the clientAssertion passed by the user\n     * @param assertion - refer https://tools.ietf.org/html/rfc7521\n     */\n    public static fromAssertion(assertion: string): ClientAssertion {\n        const clientAssertion = new ClientAssertion();\n        clientAssertion.jwt = assertion;\n        return clientAssertion;\n    }\n\n    /**\n     * Initialize the ClientAssertion class from the certificate passed by the user\n     * @param thumbprint - identifier of a certificate\n     * @param privateKey - secret key\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\n     */\n    public static fromCertificate(thumbprint: string, privateKey: string, publicCertificate?: string): ClientAssertion {\n        const clientAssertion = new ClientAssertion();\n        clientAssertion.privateKey = privateKey;\n        clientAssertion.thumbprint = thumbprint;\n        if (publicCertificate) {\n            clientAssertion.publicCertificate = this.parseCertificate(publicCertificate);\n        }\n        return clientAssertion;\n    }\n\n    /**\n     * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is\n     * @param cryptoProvider - library's crypto helper\n     * @param issuer - iss claim\n     * @param jwtAudience - aud claim\n     */\n    public getJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\n        // if assertion was created from certificate, check if jwt is expired and create new one.\n        if (this.privateKey && this.thumbprint) {\n\n            if (this.jwt && !this.isExpired() && issuer === this.issuer && jwtAudience === this.jwtAudience) {\n                return this.jwt;\n            }\n\n            return this.createJwt(cryptoProvider, issuer, jwtAudience);\n        }\n\n        /*\n         * if assertion was created by caller, then we just append it. It is up to the caller to\n         * ensure that it contains necessary claims and that it is not expired.\n         */\n        if (this.jwt) {\n            return this.jwt;\n        }\n\n        throw ClientAuthError.createInvalidAssertionError();\n    }\n\n    /**\n     * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3\n     */\n    private createJwt(cryptoProvider: CryptoProvider, issuer: string, jwtAudience: string): string {\n\n        this.issuer = issuer;\n        this.jwtAudience = jwtAudience;\n        const issuedAt = TimeUtils.nowSeconds();\n        this.expirationTime = issuedAt + 600;\n\n        const header: JwtHeader = {\n            alg: JwtConstants.RSA_256,\n            x5t: EncodingUtils.base64EncodeUrl(this.thumbprint, \"hex\")\n        };\n\n        if (this.publicCertificate) {\n            Object.assign(header, {\n                x5c: this.publicCertificate\n            } as Partial<JwtHeader>);\n        }\n\n        const payload = {\n            [JwtConstants.AUDIENCE]: this.jwtAudience,\n            [JwtConstants.EXPIRATION_TIME]: this.expirationTime,\n            [JwtConstants.ISSUER]: this.issuer,\n            [JwtConstants.SUBJECT]: this.issuer,\n            [JwtConstants.NOT_BEFORE]: issuedAt,\n            [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid()\n        };\n\n        this.jwt = sign(payload, this.privateKey, { header });\n        return this.jwt;\n    }\n\n    /**\n     * Utility API to check expiration\n     */\n    private isExpired(): boolean {\n        return this.expirationTime < TimeUtils.nowSeconds();\n    }\n\n    /**\n     * Extracts the raw certs from a given certificate string and returns them in an array.\n     * @param publicCertificate - electronic document provided to prove the ownership of the public key\n     */\n    public static parseCertificate(publicCertificate: string): Array<string> {\n        /**\n         * This is regex to identify the certs in a given certificate string.\n         * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.\n         * The information in parens \"(.+?)\" is the capture group to represent the cert we want isolated.\n         * \".\" means any string character, \"+\" means match 1 or more times, and \"?\" means the shortest match.\n         * The \"g\" at the end of the regex means search the string globally, and the \"s\" enables the \".\" to match newlines.\n         */\n        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\\r*\\n(.+?)\\r*\\n-----END CERTIFICATE-----/gs;\n        const certs: string[] = [];\n\n        let matches;\n        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {\n            // matches[1] represents the first parens capture group in the regex.\n            certs.push(matches[1].replace(/\\r*\\n/g, Constants.EMPTY_STRING));\n        }\n\n        return certs;\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ClientApplication } from \"./ClientApplication\";\nimport { Configuration } from \"../config/Configuration\";\nimport { ClientAssertion } from \"./ClientAssertion\";\nimport { Constants as NodeConstants, ApiId, REGION_ENVIRONMENT_VARIABLE } from \"../utils/Constants\";\nimport {\n    ClientCredentialClient,\n    OnBehalfOfClient,\n    CommonClientCredentialRequest,\n    CommonOnBehalfOfRequest,\n    AuthenticationResult,\n    StringUtils,\n    ClientAuthError,\n    AzureRegionConfiguration,\n    AuthError,\n    Constants,\n    IAppTokenProvider\n} from \"@azure/msal-common\";\nimport { IConfidentialClientApplication } from \"./IConfidentialClientApplication\";\nimport { OnBehalfOfRequest } from \"../request/OnBehalfOfRequest\";\nimport { ClientCredentialRequest } from \"../request/ClientCredentialRequest\";\n\n/**\n *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications\n *  will configure application secrets, client certificates/assertions as applicable\n * @public\n */\nexport class ConfidentialClientApplication extends ClientApplication implements IConfidentialClientApplication {\n\n    private appTokenProvider?: IAppTokenProvider;\n\n    /**\n     * Constructor for the ConfidentialClientApplication\n     *\n     * Required attributes in the Configuration object are:\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal\n     * - authority: the authority URL for your application.\n     * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.\n     *\n     * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n     *\n     * In Azure B2C, authority is of the form https://\\{instance\\}/tfp/\\{tenant\\}/\\{policyName\\}/\n     * Full B2C functionality will be available in this library in future versions.\n     *\n     * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance\n     */\n    constructor(configuration: Configuration) {\n        super(configuration);\n        this.setClientCredential(this.config);\n        this.appTokenProvider = undefined;\n    }\n\n    /**               \n     * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and\n     * is meant for Azure SDK to enhance Managed Identity support.\n     * \n     * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.     \n     */\n    SetAppTokenProvider(provider: IAppTokenProvider): void {\n        this.appTokenProvider = provider;\n    }\n\n    /**\n     * Acquires tokens from the authority for the application (not for an end user).\n     */\n    public async acquireTokenByClientCredential(request: ClientCredentialRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByClientCredential called\", request.correlationId);\n\n        // If there is a client assertion present in the request, it overrides the one present in the client configuration\n        let clientAssertion;\n        if (request.clientAssertion) {\n            clientAssertion = {\n                assertion: request.clientAssertion,\n                assertionType: NodeConstants.JWT_BEARER_ASSERTION_TYPE\n            };\n        }\n\n        const validRequest: CommonClientCredentialRequest = {\n            ...request,\n            ...await this.initializeBaseRequest(request),\n            clientAssertion\n        };\n\n        const azureRegionConfiguration: AzureRegionConfiguration = {\n            azureRegion: validRequest.azureRegion,\n            environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE]\n        };\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);\n        try {\n            const clientCredentialConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                azureRegionConfiguration,\n                request.azureCloudOptions\n            );\n            const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);\n            this.logger.verbose(\"Client credential client created\", validRequest.correlationId);\n            return clientCredentialClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n\n    /**\n     * Acquires tokens from the authority for the application.\n     *\n     * Used in scenarios where the current app is a middle-tier service which was called with a token\n     * representing an end user. The current app can use the token (oboAssertion) to request another\n     * token to access downstream web API, on behalf of that user.\n     *\n     * The current middle-tier app has no user interaction to obtain consent.\n     * See how to gain consent upfront for your middle-tier app from this article.\n     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application\n     */\n    public async acquireTokenOnBehalfOf(request: OnBehalfOfRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenOnBehalfOf called\", request.correlationId);\n        const validRequest: CommonOnBehalfOfRequest = {\n            ...request,\n            ... await this.initializeBaseRequest(request)\n        };\n        try {\n            const onBehalfOfConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                undefined,\n                undefined,\n                request.azureCloudOptions\n            );\n            const oboClient = new OnBehalfOfClient(onBehalfOfConfig);\n            this.logger.verbose(\"On behalf of client created\", validRequest.correlationId);\n            return oboClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            throw e;\n        }\n    }\n\n    private setClientCredential(configuration: Configuration): void {\n        const clientSecretNotEmpty = !StringUtils.isEmpty(configuration.auth.clientSecret);\n        const clientAssertionNotEmpty = !StringUtils.isEmpty(configuration.auth.clientAssertion);\n        const certificate = configuration.auth.clientCertificate || {\n            thumbprint: Constants.EMPTY_STRING,\n            privateKey: Constants.EMPTY_STRING\n        };\n        const certificateNotEmpty = !StringUtils.isEmpty(certificate.thumbprint) || !StringUtils.isEmpty(certificate.privateKey);\n\n        /*\n         * If app developer configures this callback, they don't need a credential\n         * i.e. AzureSDK can get token from Managed Identity without a cert / secret\n         */\n        if (this.appTokenProvider) {\n            return;\n        }\n\n        // Check that at most one credential is set on the application\n        if (\n            clientSecretNotEmpty && clientAssertionNotEmpty ||\n            clientAssertionNotEmpty && certificateNotEmpty ||\n            clientSecretNotEmpty && certificateNotEmpty) {\n            throw ClientAuthError.createInvalidCredentialError();\n        }\n\n        if (configuration.auth.clientSecret) {\n            this.clientSecret = configuration.auth.clientSecret;\n            return;\n        }\n\n        if (configuration.auth.clientAssertion) {\n            this.clientAssertion = ClientAssertion.fromAssertion(configuration.auth.clientAssertion);\n            return;\n        }\n\n        if (!certificateNotEmpty) {\n            throw ClientAuthError.createInvalidCredentialError();\n        } else {\n            this.clientAssertion = ClientAssertion.fromCertificate(certificate.thumbprint, certificate.privateKey, configuration.auth.clientCertificate?.x5c);\n        }\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountEntity, ICachePlugin, TokenCacheContext } from \"@azure/msal-common\";\nimport { TokenCache } from \"../TokenCache\";\nimport { IPartitionManager } from \"./IPartitionManager\";\nimport { ICacheClient } from \"./ICacheClient\";\n\nexport class DistributedCachePlugin implements ICachePlugin {\n    private client: ICacheClient;\n    private partitionManager: IPartitionManager;\n\n    constructor(client: ICacheClient, partitionManager: IPartitionManager) {\n        this.client = client;\n        this.partitionManager = partitionManager;\n    }\n  \n    public async beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void> {\n        const partitionKey = await this.partitionManager.getKey();\n        const cacheData = await this.client.get(partitionKey);\n        cacheContext.tokenCache.deserialize(cacheData);\n    }\n  \n    public async afterCacheAccess(cacheContext: TokenCacheContext): Promise<void> {\n        if (cacheContext.cacheHasChanged) {\n            const kvStore = (cacheContext.tokenCache as TokenCache).getKVStore();\n            const accountEntities = Object.values(kvStore).filter(value => AccountEntity.isAccountEntity(value as object));\n\n            if (accountEntities.length > 0) {\n                const accountEntity = accountEntities[0] as AccountEntity;\n                const partitionKey = await this.partitionManager.extractKey(accountEntity);\n                          \n                await this.client.set(partitionKey, cacheContext.tokenCache.serialize());           \n            }\n        }\n    }\n}\n","/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ApiId } from \"../utils/Constants\";\nimport {\n    DeviceCodeClient,\n    AuthenticationResult,\n    CommonDeviceCodeRequest,\n    AuthError\n} from \"@azure/msal-common\";\nimport { Configuration } from \"../config/Configuration\";\nimport { ClientApplication } from \"./ClientApplication\";\nimport { IPublicClientApplication } from \"./IPublicClientApplication\";\nimport { DeviceCodeRequest } from \"../request/DeviceCodeRequest\";\n\n/**\n * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications\n * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.\n * @public\n */\nexport class PublicClientApplication extends ClientApplication implements IPublicClientApplication {\n    /**\n     * Important attributes in the Configuration object for auth are:\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.\n     * - authority: the authority URL for your application.\n     *\n     * AAD authorities are of the form https://login.microsoftonline.com/\\{Enter_the_Tenant_Info_Here\\}.\n     * - If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\n     * - If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\n     * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\n     * - To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\n     *\n     * Azure B2C authorities are of the form https://\\{instance\\}/\\{tenant\\}/\\{policy\\}. Each policy is considered\n     * its own authority. You will have to set the all of the knownAuthorities at the time of the client application\n     * construction.\n     *\n     * ADFS authorities are of the form https://\\{instance\\}/adfs.\n     */\n    constructor(configuration: Configuration) {\n        super(configuration);\n    }\n\n    /**\n     * Acquires a token from the authority using OAuth2.0 device code flow.\n     * This flow is designed for devices that do not have access to a browser or have input constraints.\n     * The authorization server issues a DeviceCode object with a verification code, an end-user code,\n     * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be\n     * instructed to use another device to navigate to the verification URI to input credentials.\n     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly\n     * until the end-user completes input of credentials.\n     */\n    public async acquireTokenByDeviceCode(request: DeviceCodeRequest): Promise<AuthenticationResult | null> {\n        this.logger.info(\"acquireTokenByDeviceCode called\", request.correlationId);\n        const validRequest: CommonDeviceCodeRequest = Object.assign(request,  await this.initializeBaseRequest(request));\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);\n        try {\n            const deviceCodeConfig = await this.buildOauthClientConfiguration(\n                validRequest.authority,\n                validRequest.correlationId,\n                serverTelemetryManager,\n                undefined,\n                request.azureCloudOptions\n            );\n            const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);\n            this.logger.verbose(\"Device code client created\", validRequest.correlationId);\n            return deviceCodeClient.acquireToken(validRequest);\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(validRequest.correlationId);\n            }\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n    }\n}\n"],"names":["HttpMethod","CharSet","ApiId","HttpClient","[object Object]","url","options","proxyUrl","networkRequestViaProxy","GET","networkRequestViaHttps","cancellationToken","POST","httpMethod","timeout","headers","URL","destinationUrl","tunnelRequestOptions","host","hostname","port","method","path","postRequestStringContent","body","length","outgoingRequestString","toUpperCase","href","Promise","resolve","reject","request","http","on","destroy","Error","end","response","socket","statusCode","setTimeout","write","data","chunk","push","dataStringArray","Buffer","concat","toString","split","parseInt","headersArray","slice","entries","Map","forEach","header","headerKeyValue","RegExp","headerKey","headerValue","object","JSON","parse","e","set","networkResponse","Object","fromEntries","status","isPostRequest","customOptions","Content-Length","https","DEFAULT_AUTH_OPTIONS","clientId","Constants","EMPTY_STRING","authority","DEFAULT_AUTHORITY","clientSecret","clientAssertion","clientCertificate","thumbprint","privateKey","x5c","knownAuthorities","cloudDiscoveryMetadata","authorityMetadata","clientCapabilities","protocolMode","ProtocolMode","AAD","azureCloudOptions","azureCloudInstance","AzureCloudInstance","None","tenant","skipAuthorityMetadataCache","DEFAULT_CACHE_OPTIONS","DEFAULT_SYSTEM_OPTIONS","loggerOptions","loggerCallback","piiLoggingEnabled","logLevel","LogLevel","Info","networkClient","getNetworkClient","DEFAULT_TELEMETRY_OPTIONS","application","appName","appVersion","buildAppConfiguration","auth","cache","system","telemetry","GuidGenerator","generateGuid","uuidv4","isGuid","guid","test","EncodingUtils","str","encoding","from","base64Encode","replace","base64Str","base64Decode","HashUtils","sha256","buffer","crypto","createHash","update","digest","PkceGenerator","constructor","this","hashUtils","verifier","generateCodeVerifier","challenge","generateCodeChallengeFromVerifier","charArr","maxNumber","byte","randomBytes","join","base64EncodeUrl","codeVerifier","CryptoProvider","pkceGenerator","guidGenerator","createNewGuid","input","generatePkceCodes","getPublicKeyThumbprint","removeTokenBindingKey","clearKeystore","signJwt","plainText","Deserializer","jsonFile","StringUtils","isEmpty","accounts","accountObjects","keys","map","key","serializedAcc","mappedAcc","homeAccountId","home_account_id","environment","realm","localAccountId","local_account_id","username","authorityType","authority_type","name","clientInfo","client_info","lastModificationTime","last_modification_time","lastModificationApp","last_modification_app","account","AccountEntity","CacheManager","toObject","idTokens","idObjects","serializedIdT","mappedIdT","credentialType","credential_type","client_id","secret","idToken","IdTokenEntity","accessTokens","atObjects","serializedAT","mappedAT","target","cachedAt","cached_at","expiresOn","expires_on","extendedExpiresOn","extended_expires_on","refreshOn","refresh_on","keyId","key_id","tokenType","token_type","requestedClaims","requestedClaimsHash","accessToken","AccessTokenEntity","refreshTokens","rtObjects","serializedRT","mappedRT","familyId","family_id","refreshToken","RefreshTokenEntity","appMetadata","appMetadataObjects","serializedAmdt","mappedAmd","amd","AppMetadataEntity","jsonCache","Account","deserializeAccounts","IdToken","deserializeIdTokens","AccessToken","deserializeAccessTokens","RefreshToken","deserializeRefreshTokens","AppMetadata","deserializeAppMetadata","Serializer","stringify","accCache","accountEntity","idTCache","idTEntity","atCache","atEntity","rtCache","rtEntity","amdtCache","amdtEntity","inMemCache","serializeAccounts","serializeIdTokens","serializeAccessTokens","serializeRefreshTokens","serializeAppMetadata","NodeStorage","logger","cryptoImpl","super","registerChangeEmitter","func","changeEmitters","emitChange","call","cacheToInMemoryCache","inMemoryCache","inMemoryCacheToCache","getCache","getInMemoryCache","trace","setInMemoryCache","setCache","getItem","tracePii","setItem","value","getAccount","accountKey","isAccountEntity","setAccount","generateAccountKey","getIdTokenCredential","idTokenKey","isIdTokenEntity","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","isAccessTokenEntity","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","isRefreshTokenEntity","setRefreshTokenCredential","getAppMetadata","appMetadataKey","isAppMetadataEntity","setAppMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetrykey","serverTelemetryEntity","ServerTelemetryEntity","isServerTelemetryEntity","setServerTelemetry","serverTelemetryKey","serverTelemetry","getAuthorityMetadata","authorityMetadataEntity","AuthorityMetadataEntity","isAuthorityMetadataEntity","getAuthorityMetadataKeys","getKeys","filter","isAuthorityMetadata","setAuthorityMetadata","metadata","getThrottlingCache","throttlingCacheKey","throttlingCache","ThrottlingEntity","isThrottlingEntity","setThrottlingCache","removeItem","result","containsKey","includes","deserializeAllCache","deserializeJSONBlob","serializeAllCache","updateCredentialCacheKey","currentCacheKey","credential","updatedCacheKey","cacheItem","verbose","error","defaultSerializedCache","TokenCache","storage","cachePlugin","cacheHasChanged","handleChangeEvent","bind","persistence","hasChanged","serialize","finalState","cacheSnapshot","mergeState","deserialize","deserializedCache","overlayDefaults","getKVStore","cacheContext","TokenCacheContext","beforeCacheAccess","getAllAccounts","afterCacheAccess","allAccounts","accountObj","removeAccount","generateAccountCacheKey","oldState","currentState","stateAfterRemoval","mergeRemovals","mergeUpdates","newState","newKey","newValue","hasOwnProperty","newValueNotNull","newValueIsObject","newValueIsNotArray","Array","isArray","oldStateNotUndefinedOrNull","mergeRemovalsDict","oldKey","passedInCache","ClientApplication","configuration","config","cryptoProvider","Logger","tokenCache","info","correlationId","validRequest","initializeBaseRequest","responseMode","ResponseMode","QUERY","authenticationScheme","AuthenticationScheme","BEARER","authClientConfig","buildOauthClientConfiguration","undefined","authorizationCodeClient","AuthorizationCodeClient","getAuthCodeUrl","authCodePayLoad","serverTelemetryManager","initializeServerTelemetryManager","acquireTokenByCode","acquireToken","AuthError","setCorrelationId","cacheFailedRequest","acquireTokenByRefreshToken","refreshTokenClientConfig","refreshTokenClient","RefreshTokenClient","forceRefresh","acquireTokenSilent","silentFlowClientConfig","silentFlowClient","SilentFlowClient","acquireTokenByUsernamePassword","usernamePasswordClientConfig","usernamePasswordClient","UsernamePasswordClient","getTokenCache","getLogger","setLogger","requestCorrelationId","azureRegionConfiguration","userAzureCloudOptions","discoveredAuthority","createAuthority","updateRegionDiscoveryMetadata","regionDiscoveryMetadata","authOptions","systemOptions","cryptoInterface","networkInterface","storageInterface","clientCredentials","getClientAssertion","libraryInfo","sku","version","cpu","process","arch","os","platform","persistencePlugin","serializableCache","assertion","getJwt","tokenEndpoint","assertionType","authRequest","POP","claims","hashString","scopes","OIDC_DEFAULT_SCOPES","apiId","ServerTelemetryManager","authorityString","authorityUrl","Authority","generateAuthority","authorityOptions","AuthorityFactory","createDiscoveredInstance","clearCache","clear","ClientAssertion","jwt","publicCertificate","parseCertificate","issuer","jwtAudience","isExpired","createJwt","ClientAuthError","createInvalidAssertionError","issuedAt","TimeUtils","nowSeconds","expirationTime","alg","x5t","assign","payload","aud","exp","iss","sub","nbf","jti","sign","regexToFindCerts","certs","matches","exec","setClientCredential","appTokenProvider","SetAppTokenProvider","provider","azureRegion","environmentRegion","env","acquireTokenByClientCredential","skipCache","clientCredentialConfig","clientCredentialClient","ClientCredentialClient","onBehalfOfConfig","oboClient","OnBehalfOfClient","clientSecretNotEmpty","clientAssertionNotEmpty","certificate","certificateNotEmpty","createInvalidCredentialError","fromAssertion","fromCertificate","_configuration$auth$c","client","partitionManager","partitionKey","getKey","cacheData","get","kvStore","accountEntities","values","extractKey","acquireTokenByDeviceCode","deviceCodeConfig","deviceCodeClient","DeviceCodeClient"],"mappings":"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"}